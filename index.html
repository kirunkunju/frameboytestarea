<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="FrameBoy - Create frame-by-frame animations">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="FrameBoy">
    <meta name="theme-color" content="#2b2d31">
    <link rel="manifest" href="manifest.json">
    <title>FrameBoy</title>
    <!-- GIF encoder is built-in, no external dependency needed -->
    <script>
    window.GIFEncoder = class GIFEncoder {
        constructor(w, h) { this.w = w; this.h = h; this.frames = []; }
        addFrame(data, delay) { this.frames.push({ data, delay: delay || 100 }); }
        encode() {
            const o = [];
            const w = v => o.push(v & 0xFF);
            const w2 = v => { o.push(v & 0xFF); o.push((v >> 8) & 0xFF); };
            const { palette, indexed } = this._quant();
            [0x47,0x49,0x46,0x38,0x39,0x61].forEach(w);
            w2(this.w); w2(this.h);
            w(0xF7); w(0); w(0);
            for (let i = 0; i < 256; i++) { w(palette[i*3]||0); w(palette[i*3+1]||0); w(palette[i*3+2]||0); }
            w(0x21); w(0xFF); w(0x0B);
            [0x4E,0x45,0x54,0x53,0x43,0x41,0x50,0x45,0x32,0x2E,0x30].forEach(w);
            w(3); w(1); w2(0); w(0);
            for (let f = 0; f < this.frames.length; f++) {
                const dl = Math.round(this.frames[f].delay / 10);
                w(0x21); w(0xF9); w(4); w(0); w2(dl); w(0); w(0);
                w(0x2C); w2(0); w2(0); w2(this.w); w2(this.h); w(0);
                this._lzw(indexed[f], 8, o);
            }
            w(0x3B);
            return new Uint8Array(o);
        }
        _quant() {
            const px = this.w * this.h;
            const sr = Math.max(1, Math.floor((px * this.frames.length) / 40000));
            const cols = [];
            for (const fr of this.frames) { const d = fr.data; for (let i = 0; i < d.length; i += 4 * sr) cols.push([d[i], d[i+1], d[i+2]]); }
            const pc = this._mcut(cols, 256);
            const palette = new Uint8Array(768);
            for (let i = 0; i < pc.length && i < 256; i++) { palette[i*3] = pc[i][0]; palette[i*3+1] = pc[i][1]; palette[i*3+2] = pc[i][2]; }
            const indexed = [];
            for (const fr of this.frames) {
                const d = fr.data, idx = new Uint8Array(px);
                for (let i = 0; i < px; i++) { const r = d[i*4], g = d[i*4+1], b = d[i*4+2]; let best = 0, bd = Infinity; for (let j = 0; j < pc.length; j++) { const dr = r-pc[j][0], dg = g-pc[j][1], db = b-pc[j][2], dd = dr*dr+dg*dg+db*db; if (dd < bd) { bd = dd; best = j; } } idx[i] = best; }
                indexed.push(idx);
            }
            return { palette, indexed };
        }
        _mcut(colors, max) {
            if (!colors.length) { const p = []; for (let i = 0; i < max; i++) p.push([0,0,0]); return p; }
            let bk = [colors];
            while (bk.length < max) {
                let bi = 0, br = -1;
                for (let i = 0; i < bk.length; i++) { const b = bk[i]; if (b.length < 2) continue; for (let c = 0; c < 3; c++) { let mn = 255, mx = 0; for (const cl of b) { mn = Math.min(mn, cl[c]); mx = Math.max(mx, cl[c]); } if (mx-mn > br) { br = mx-mn; bi = i; } } }
                if (br <= 0) break;
                const b = bk[bi]; let sc = 0, mr = 0;
                for (let c = 0; c < 3; c++) { let mn = 255, mx = 0; for (const cl of b) { mn = Math.min(mn, cl[c]); mx = Math.max(mx, cl[c]); } if (mx-mn > mr) { mr = mx-mn; sc = c; } }
                b.sort((a, c) => a[sc] - c[sc]); const m = b.length >> 1;
                bk.splice(bi, 1, b.slice(0, m), b.slice(m));
            }
            return bk.map(b => { let r=0,g=0,bl=0; for (const c of b){r+=c[0];g+=c[1];bl+=c[2];} const n=b.length||1; return [Math.round(r/n),Math.round(g/n),Math.round(bl/n)]; });
        }
        _lzw(indexed, mcs, out) {
            const w = v => out.push(v & 0xFF);
            w(mcs);
            const cc = 1 << mcs, eoi = cc + 1;
            let cs = mcs + 1, nc = eoi + 1;
            let bits = 0, bc = 0; const sb = [];
            const wb = (code, sz) => { bits |= (code << bc); bc += sz; while (bc >= 8) { sb.push(bits & 0xFF); bits >>= 8; bc -= 8; if (sb.length === 255) { w(255); sb.forEach(b => w(b)); sb.length = 0; } } };
            let tbl = new Map();
            const reset = () => { tbl = new Map(); for (let i = 0; i < cc; i++) tbl.set(String(i), i); nc = eoi + 1; cs = mcs + 1; };
            wb(cc, cs); reset();
            let cur = String(indexed[0]);
            for (let i = 1; i < indexed.length; i++) {
                const nx = cur + ',' + indexed[i];
                if (tbl.has(nx)) { cur = nx; } else { wb(tbl.get(cur), cs); if (nc < 4096) { tbl.set(nx, nc++); if (nc > (1 << cs) && cs < 12) cs++; } else { wb(cc, cs); reset(); } cur = String(indexed[i]); }
            }
            wb(tbl.get(cur), cs); wb(eoi, cs);
            if (bc > 0) sb.push(bits & 0xFF);
            if (sb.length) { w(sb.length); sb.forEach(b => w(b)); }
            w(0);
        }
    };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #2b2d31;
            color: #d0d0d0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            height: 100dvh;
        }

        html {
            width: 100%;
            height: 100%;
            height: 100dvh;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100vh;
            height: 100dvh;
            height: var(--app-height, 100dvh);
            min-height: 400px;
            max-height: 100vh;
            max-height: 100dvh;
            max-height: var(--app-height, 100dvh);
            overflow: hidden;
            -webkit-touch-callout: none;
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }


        /* Toolbar */
        .toolbar {
            background: #2b2d31;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4), 0 1px 0 rgba(255,255,255,0.03) inset;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: relative;
            z-index: 100;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            padding: 0 10px;
            border-right: 1px solid rgba(255,255,255,0.04);
            align-items: center;
        }

        .tool-group:last-child {
            border-right: none;
        }

        button {
            background: #2b2d31;
            border: none;
            color: #c0c0c0;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            box-shadow: 3px 3px 6px rgba(0,0,0,0.4), -2px -2px 5px rgba(255,255,255,0.04);
        }
        
        button svg {
            flex-shrink: 0;
            vertical-align: middle;
        }
        
        .dropdown-item svg {
            flex-shrink: 0;
            vertical-align: middle;
            opacity: 0.85;
        }

        .btn-label {
            display: inline;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
        }

        .toolbar .btn-label {
            display: none;
        }

        /* Apple Pencil / touch: instant feedback on all interactive elements */
        input, select, label, .shape-icon, .dropdown-item, .frame, .add-frame,
        .layer-item, .add-layer-btn-inline, .delete-layer-btn-inline {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        button:hover {
            background: #30323a;
            color: #e0e0e0;
        }
        
        /* Instant press feedback for Apple Pencil & touch */
        button:active {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.03);
            transition: none;
            color: #ddd;
        }

        button.active {
            background: #2b2d31;
            color: #6aadff;
            box-shadow: inset 3px 3px 6px rgba(0,0,0,0.45), inset -2px -2px 5px rgba(255,255,255,0.04);
        }
        
        .dropdown-container {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            margin-top: 4px;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03);
            overflow: visible;
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 8px 12px;
            background: transparent;
            border: none;
            color: #c0c0c0;
            text-align: left;
            cursor: pointer;
            border-radius: 0;
            font-size: 14px;
            box-shadow: none;
        }
        
        .dropdown-menu > .dropdown-item:first-child,
        .dropdown-menu > :first-child .dropdown-item {
            border-radius: 10px 10px 0 0;
        }
        
        .dropdown-menu > .dropdown-item:last-child,
        .dropdown-menu > :last-child .dropdown-item,
        .dropdown-menu > :last-child .submenu-trigger {
            border-radius: 0 0 10px 10px;
        }
        
        .dropdown-item .shortcut {
            font-size: 11px;
            color: #888;
            margin-left: auto;
        }
        
        .dropdown-divider {
            height: 1px;
            background: rgba(255,255,255,0.05);
            margin: 4px 0;
        }
        
        .dropdown-submenu-container {
            position: relative;
        }
        
        .dropdown-submenu-container .submenu-trigger {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .submenu-arrow {
            font-size: 10px;
            color: #888;
            margin-left: 12px;
        }
        
        .dropdown-submenu {
            display: none;
            position: absolute;
            left: calc(100% - 4px);
            top: -1px;
            padding-left: 4px; /* invisible bridge so hover doesn't break crossing the gap */
            z-index: 1001;
        }
        
        .dropdown-submenu-inner {
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            min-width: 180px;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03);
            overflow: hidden;
        }
        
        .dropdown-submenu-container:hover > .dropdown-submenu,
        .dropdown-submenu-container.touch-open > .dropdown-submenu {
            display: block;
        }
        
        .dropdown-submenu .dropdown-item:first-child {
            border-radius: 10px 10px 0 0;
        }
        
        .dropdown-submenu .dropdown-item:last-child {
            border-radius: 0 0 10px 10px;
        }
        
        .dropdown-item:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .dropdown-item:first-child {
            border-radius: 10px 10px 0 0;
        }
        
        .dropdown-item:last-child {
            border-radius: 0 0 10px 10px;
        }

        input[type="color"] {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4), -1px -1px 3px rgba(255,255,255,0.03);
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            overflow: hidden;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }
        
        /* Color pickers wrap */
        .color-pickers-wrap {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .color-b-picker {
            display: none; /* shown when gradient tool active */
        }
        
        .gradient-active .color-b-picker {
            display: block;
        }
        
        .swap-colors-btn {
            display: none;
            width: 22px !important;
            height: 22px !important;
            min-width: 22px;
            padding: 0 !important;
            font-size: 12px;
            line-height: 1;
            border-radius: 50% !important;
            background: #26282c !important;
            color: #aaa;
            border: none;
            cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3), -1px -1px 2px rgba(255,255,255,0.03);
        }
        
        .swap-colors-btn:hover {
            color: #fff;
            background: #32343a !important;
        }
        
        .gradient-active .swap-colors-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .gradient-swatch {
            display: none;
            width: 40px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3), 1px 1px 3px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.08);
            flex-shrink: 0;
            position: relative;
            transition: box-shadow 0.2s, border-color 0.2s;
        }
        
        .gradient-active .gradient-swatch {
            display: block;
        }
        
        /* Show swatch on ANY tool when a gradient is stored */
        .gradient-stored .gradient-swatch {
            display: block;
        }
        
        .gradient-swatch.has-gradient {
            border-color: rgba(106,173,255,0.35);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3), 0 0 6px rgba(106,173,255,0.25);
        }
        
        .gradient-swatch .swatch-clear {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3a3c42;
            color: #aaa;
            font-size: 9px;
            line-height: 14px;
            text-align: center;
            display: none;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }
        
        .gradient-swatch.has-gradient .swatch-clear {
            display: block;
        }
        
        .gradient-swatch .swatch-clear:hover {
            background: #e04040;
            color: #fff;
            border-color: rgba(255,255,255,0.2);
        }
        
        /* Stored gradient indicator badge on the fill tool button */
        .gradient-badge {
            display: none;
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: linear-gradient(135deg, #5b8def, #ef5b8d);
            border: 1.5px solid #1e2024;
            box-shadow: 0 0 4px rgba(106,173,255,0.4);
        }
        
        .has-stored-gradient .gradient-badge {
            display: block;
        }
        
        #fillTool {
            position: relative;
        }
        
        .gradient-type-toggle {
            display: none;
            gap: 2px;
        }
        
        .gradient-active .gradient-type-toggle {
            display: flex;
        }
        
        .grad-type-btn {
            width: 26px !important;
            height: 26px !important;
            min-width: 26px;
            padding: 0 !important;
            border-radius: 6px !important;
            background: transparent !important;
            color: #888;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: none !important;
        }
        
        .grad-type-btn:hover {
            color: #ccc;
            background: #2a2c30 !important;
        }
        
        .grad-type-btn.active {
            color: #6aadff !important;
            background: #26282c !important;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03) !important;
        }

        input[type="range"] {
            width: 100px;
            accent-color: #5b8def;
        }

        label {
            font-size: 12px;
            margin-right: 5px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Main content area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Layer items (now in timeline) */
        .layers-list {
            flex: 1;
            overflow-y: auto;
        }

        .layer-item {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 6px;
            border-bottom: 1px solid rgba(0,0,0,0.15);
            font-size: 11px;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
        }
        
        .layer-item.dragging {
            opacity: 0.4;
        }
        
        .layer-item.drop-before::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
            z-index: 10;
        }
        
        .layer-item.drop-after::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
            z-index: 10;
        }
        
        .layer-drag-handle {
            cursor: grab;
            color: #666;
            font-size: 12px;
            padding: 0 4px;
            display: flex;
            align-items: center;
            flex-shrink: 0;
            touch-action: none;
        }
        
        .layer-drag-handle:active {
            cursor: grabbing;
        }
        
        .layer-header {
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            -webkit-user-select: none;
        }

        .layer-item:hover {
            background: rgba(255,255,255,0.03);
        }

        .layer-item.active {
            background: rgba(91, 141, 239, 0.12);
            box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2), inset -2px -2px 4px rgba(255,255,255,0.02);
        }

        .layer-visibility {
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            align-items: center;
        }

        .layer-name {
            flex: 1;
            font-size: 11px;
            user-select: none;
            -webkit-user-select: none;
            cursor: text;
        }
        
        .parent-select-inline {
            flex-shrink: 0;
            max-width: 64px;
            height: 18px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 3px;
            color: #777;
            font-size: 9px;
            padding: 0 2px;
            outline: none;
            cursor: pointer;
            margin-left: auto;
            text-overflow: ellipsis;
            transition: border-color 0.15s, color 0.15s;
        }
        .parent-select-inline:hover {
            border-color: #444;
            color: #bbb;
        }
        .parent-select-inline:focus {
            border-color: #5588cc;
            color: #ccc;
        }
        .parent-select-inline.has-parent {
            color: #5588cc;
            border-color: #334;
        }
        .parent-select-inline.has-parent:hover {
            border-color: #5588cc;
            color: #88bbee;
        }
        .parent-select-inline option {
            background: #2b2d31;
            color: #ccc;
        }
        
        .layer-opacity-control {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            padding-left: 22px;
            padding-right: 8px;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .layer-opacity-control > span:first-child {
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .layer-opacity-control input[type="range"] {
            width: 70px;
            height: 3px;
            flex-shrink: 0;
        }
        
        .layer-opacity-value {
            min-width: 35px;
            text-align: right;
            font-size: 10px;
            user-select: none;
            -webkit-user-select: none;
            flex-shrink: 0;
        }

        /* Canvas area */
        .canvas-container {
            flex: 1;
            background: #26282c;
            position: relative;
            overflow: auto;
            min-height: 200px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            box-shadow: inset 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .canvas-wrapper {
            position: relative;
            margin: auto;
            /* Centering when wrapper is smaller than container */
            background: white;
        }

        canvas {
            border: none;
            cursor: crosshair;
            display: block;
            touch-action: none;
            will-change: contents;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            box-shadow: 4px 4px 12px rgba(0,0,0,0.5), -2px -2px 8px rgba(255,255,255,0.02);
            border-radius: 2px;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            background: #2b2d31;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 4px 6px;
            border-radius: 14px;
            z-index: 20;
            border: none;
            box-shadow: 4px 4px 10px rgba(0,0,0,0.45), -2px -2px 6px rgba(255,255,255,0.03);
            pointer-events: auto;
        }
        
        .zoom-controls .pill-divider {
            width: 1px;
            height: 18px;
            background: rgba(255, 255, 255, 0.12);
            margin: 0 2px;
            flex-shrink: 0;
        }
        
        .zoom-controls button {
            padding: 4px 6px;
            font-size: 12px;
            min-width: 28px;
            min-height: 28px;
            justify-content: center;
            background: transparent;
            border-radius: 8px;
            box-shadow: none;
        }
        
        .zoom-controls button:hover {
            background: rgba(255, 255, 255, 0.06);
        }
        
        .zoom-controls button:active {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: none;
        }
        
        .zoom-controls button.pill-active {
            background: rgba(91, 141, 239, 0.2);
            color: #6aadff;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3), inset -1px -1px 3px rgba(255,255,255,0.02);
        }
        
        .zoom-controls button.pill-active:hover {
            background: rgba(91, 141, 239, 0.25);
        }

        .magnifier-marquee {
            display: none;
            position: absolute;
            border: 1.5px dashed rgba(0, 102, 204, 0.9);
            background: rgba(0, 102, 204, 0.08);
            pointer-events: none;
            z-index: 15;
            border-radius: 2px;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.15);
        }
        
        .zoom-label {
            color: #ccc;
            font-size: 12px;
            min-width: 42px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        #mainCanvas {
            position: relative;
            z-index: 2;
        }

        #onionCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }
        
        #gridCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 4;
            opacity: 0.18;
            display: none;
        }
        
        #selectionCanvas {
            position: absolute;
            pointer-events: auto;
            z-index: 5;
        }
        
        .transform-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #2b2d31;
            border: 2px solid #5b8def;
            border-radius: 50%;
            cursor: pointer;
            z-index: 6;
            transform: translate(-50%, -50%);
            touch-action: none;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }
        
        .transform-handle.corner { cursor: nwse-resize; }
        .transform-handle.side-h { cursor: ew-resize; }
        .transform-handle.side-v { cursor: ns-resize; }
        .transform-handle.rotate { cursor: grab; background: #5b8def; }

        /* Timeline */
        .timeline-resize-handle {
            height: 10px;
            cursor: row-resize;
            background: transparent;
            position: relative;
            flex-shrink: 0;
            touch-action: none;
        }
        
        .timeline-resize-handle::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 4px;
            background: #3a3c42;
            border-radius: 2px;
        }
        
        .timeline-resize-handle:hover::before,
        .timeline-resize-handle:active::before {
            background: #5b8def;
        }
        
        .timeline {
            min-height: 180px;
            max-height: 280px;
            height: 25vh;
            background: #2b2d31;
            border-top: none;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.3), 0 -1px 0 rgba(255,255,255,0.03) inset;
        }
        
        .timeline-header {
            background: #2b2d31;
            border-bottom: 1px solid rgba(0,0,0,0.2);
        }

        .timeline-controls {
            padding: 8px;
            display: flex;
            gap: 5px;
            align-items: center;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .playback-controls {
            display: flex;
            gap: 5px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .play-btn-group {
            display: flex;
            position: relative;
            gap: 0;
        }
        
        .play-btn-group #playBtn {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
            margin-right: 0;
        }
        
        .playback-controls .play-mode-arrow {
            width: 18px;
            min-width: 18px;
            padding: 0;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .play-mode-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 3px;
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 3px;
            z-index: 1000;
            min-width: 180px;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03);
        }
        
        .play-mode-menu.show {
            display: block;
        }
        
        .play-mode-item {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            text-align: left;
            white-space: nowrap;
        }
        
        .play-mode-item:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .play-mode-item.active {
            background: rgba(91, 141, 239, 0.15);
            color: #6aadff;
        }
        
        .play-mode-item .shortcut {
            margin-left: auto;
            font-size: 10px;
            color: #777;
        }

        .fps-control {
            display: flex;
            align-items: center;
            gap: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: relative;
        }
        
        .fps-step-btn {
            width: 22px;
            height: 26px;
            padding: 0;
            border: none;
            background: transparent;
            color: #888;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: color 0.15s, background 0.15s;
        }
        
        .fps-step-btn:hover {
            color: #ddd;
            background: rgba(255,255,255,0.08);
        }
        
        .fps-step-btn:active {
            color: #fff;
            background: rgba(255,255,255,0.15);
        }
        
        .fps-badge {
            display: flex;
            align-items: baseline;
            gap: 2px;
            padding: 3px 6px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .fps-badge:hover {
            background: rgba(255,255,255,0.08);
        }
        
        .fps-badge-value {
            font-size: 14px;
            font-weight: 700;
            color: #e0e0e0;
            font-variant-numeric: tabular-nums;
            min-width: 18px;
            text-align: center;
            letter-spacing: -0.5px;
        }
        
        .fps-badge-label {
            font-size: 9px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .fps-popover {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            right: 0;
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 14px;
            padding: 12px;
            z-index: 1000;
            box-shadow: 6px 6px 20px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03);
            min-width: 180px;
        }
        
        .fps-popover.show {
            display: block;
        }
        
        .fps-popover-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 8px;
        }
        
        .fps-presets {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }
        
        .fps-preset {
            padding: 6px 0;
            border: none;
            border-radius: 8px;
            background: #2b2d31;
            color: #bbb;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .fps-preset:hover {
            background: #30323a;
            color: #e0e0e0;
        }
        
        .fps-preset.active {
            color: #6aadff;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .fps-custom-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .fps-custom-label {
            font-size: 11px;
            color: #888;
            flex-shrink: 0;
        }
        
        .fps-custom-input {
            flex: 1;
            background: #2b2d31;
            border: none;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 13px;
            font-weight: 600;
            padding: 5px 8px;
            text-align: center;
            outline: none;
            width: 100%;
            font-variant-numeric: tabular-nums;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .fps-custom-input:focus {
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.03), 0 0 0 2px rgba(91,141,239,0.3);
        }
        
        .timeline-zoom-controls {
            display: flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
        }
        
        .timeline-zoom-controls button {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: #2b2d31;
            color: #ccc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .timeline-zoom-controls button:hover {
            background: #30323a;
        }
        
        .timeline-zoom-controls button:active {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3), inset -1px -1px 3px rgba(255,255,255,0.02);
            color: #6aadff;
        }
        
        /* Layer disclosure & property panel */
        .tl-label-twirl {
            cursor: pointer;
            flex-shrink: 0;
            font-size: 8px;
            color: #666;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .tl-label-twirl.open {
            transform: rotate(90deg);
            color: #bbb;
        }
        
        .tl-props {
            display: none;
            padding: 6px 6px 6px 10px;
            border-top: 1px solid #333;
            margin-top: 4px;
        }
        
        .tl-props.open {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        /* Each property row */
        .tl-prop {
            display: flex;
            align-items: center;
            gap: 5px;
            height: 24px;
        }
        
        .tl-prop-diamond {
            width: 16px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .tl-prop-diamond svg {
            width: 10px;
            height: 10px;
        }
        
        .tl-prop-diamond .diamond-fill {
            fill: #444;
            transition: fill 0.1s;
        }
        
        .tl-prop-diamond.has-key .diamond-fill {
            fill: #dda520;
        }
        
        .tl-prop-diamond:hover .diamond-fill {
            fill: #eebb00;
        }
        
        .tl-prop-name {
            font-size: 10px;
            color: #999;
            width: 56px;
            flex-shrink: 0;
        }
        
        /* Scrub slider â€” the main control */
        .scrub-slider {
            flex: 1;
            height: 20px;
            background: #2b2d31;
            border: none;
            border-radius: 6px;
            position: relative;
            cursor: ew-resize;
            overflow: hidden;
            min-width: 60px;
            user-select: none;
            -webkit-user-select: none;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .scrub-slider:hover {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.04);
        }
        
        .scrub-slider:active, .scrub-slider.dragging {
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.45), inset -1px -1px 3px rgba(255,255,255,0.03), 0 0 0 1px rgba(91,141,239,0.3);
        }
        
        .scrub-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, rgba(91,141,239,0.15), rgba(91,141,239,0.25));
            border-radius: 5px 0 0 5px;
            pointer-events: none;
            transition: none;
        }
        
        .scrub-value {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            color: #d0d8e8;
            pointer-events: none;
            z-index: 1;
            letter-spacing: 0.3px;
        }
        
        .scrub-value .scrub-unit {
            font-size: 9px;
            color: #667;
            margin-left: 2px;
        }
        
        /* Editable input overlay (appears on double-click) */
        .scrub-input {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 5px;
            background: #22242a;
            color: #e0e8f0;
            font-size: 11px;
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            text-align: center;
            z-index: 2;
            outline: none;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.4), 0 0 0 2px rgba(91,141,239,0.4);
            display: none;
            -moz-appearance: textfield;
        }
        
        .scrub-input::-webkit-outer-spin-button,
        .scrub-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Paired values (Position X/Y, Scale X/Y) */
        .tl-prop-pair-wrap {
            flex: 1;
            display: flex;
            gap: 4px;
            min-width: 0;
        }
        
        .tl-prop-pair-wrap .scrub-pair {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0;
            min-width: 0;
        }
        
        .tl-prop-pair-wrap .pair-lbl {
            font-size: 9px;
            color: #667;
            width: 12px;
            flex-shrink: 0;
            text-align: center;
        }
        
        .tl-prop-pair-wrap .scrub-slider {
            flex: 1;
            min-width: 40px;
        }
        
        /* Keyframe action buttons */
        .tl-key-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding-top: 4px;
            margin-top: 2px;
            border-top: 1px solid rgba(0,0,0,0.15);
        }
        
        .tl-key-actions button {
            padding: 4px 10px;
            font-size: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #2b2d31;
            color: #bbb;
            transition: all 0.1s;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .tl-key-actions button:hover {
            background: #30323a;
            color: #eee;
        }
        
        .tl-key-actions .act-set {
            color: #eec840;
        }
        
        .tl-key-actions .act-set:hover {
            background: #33301e;
        }
        
        .tl-key-actions .act-del {
            color: #d88;
        }
        
        .tl-key-actions .act-del:hover {
            background: #331e1e;
        }
        
        .tl-key-actions .act-copy {
            color: #88bbdd;
        }
        .tl-key-actions .act-copy:hover { background: #1e2a33; }
        .tl-key-actions .act-copy:disabled {
            opacity: 0.35;
            cursor: default;
            color: #666;
            box-shadow: none;
        }
        .tl-key-actions .act-copy:disabled:hover { background: #2b2d31; }
        
        .tl-key-actions .act-paste {
            color: #88cc88;
        }
        .tl-key-actions .act-paste:hover { background: #1e331e; }
        .tl-key-actions .act-paste:disabled {
            opacity: 0.35;
            cursor: default;
            color: #666;
            box-shadow: none;
        }
        .tl-key-actions .act-paste:disabled:hover { background: #2b2d31; }
        
        /* Curve Editor (Graph Editor overlay) */
        .curve-editor {
            display: none;
            position: absolute;
            top: 32px;
            left: 0;
            right: 0;
            bottom: 0;
            background: #22242a;
            z-index: 20;
            flex-direction: column;
        }
        
        .curve-editor.active {
            display: flex;
        }
        
        .ce-toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #2b2d31;
            border-bottom: 1px solid rgba(0,0,0,0.2);
            flex-shrink: 0;
            flex-wrap: wrap;
        }
        
        .ce-prop-tabs {
            display: flex;
            gap: 2px;
        }
        
        .ce-prop-tab {
            padding: 3px 8px;
            font-size: 10px;
            border: 1px solid #3a3a44;
            border-radius: 3px;
            background: #2a2a34;
            color: #888;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .ce-prop-tab:hover {
            background: #333340;
            color: #aaa;
        }
        
        .ce-prop-tab.active {
            background: #334;
            border-color: #5588cc;
            color: #8ac;
        }
        
        .ce-presets {
            display: flex;
            gap: 2px;
            margin-left: auto;
        }
        
        .ce-preset-btn {
            padding: 3px 7px;
            font-size: 9px;
            border: 1px solid #3a3a44;
            border-radius: 3px;
            background: #2a2a34;
            color: #999;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .ce-preset-btn:hover {
            background: #383844;
            color: #ddd;
        }
        
        .ce-close-btn {
            padding: 3px 8px;
            font-size: 10px;
            border: 1px solid #5a3a3a;
            border-radius: 3px;
            background: #2a2a34;
            color: #d88;
            cursor: pointer;
            margin-left: 6px;
        }
        
        .ce-close-btn:hover {
            background: #3a2a2a;
        }
        
        .ce-canvas-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .ce-canvas-wrap canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .ce-hint {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #556;
            pointer-events: none;
        }
        
        /* Curve editor toggle button in key actions */
        .tl-key-actions .act-curve {
            border-color: #3a4a6a;
            color: #8ac;
        }
        
        .tl-key-actions .act-curve:hover {
            background: #2a3a4a;
        }
        
        .tl-key-actions .act-curve.active {
            background: #2a3a5a;
            border-color: #5588cc;
            color: #adf;
        }

        /* Keyframe diamonds on timeline */
        .keyframe-diamond {
            position: absolute;
            bottom: 2px;
            width: 7px;
            height: 7px;
            background: #ffcc00;
            transform: rotate(45deg);
            z-index: 3;
            pointer-events: none;
        }
        
        /* Pen tool floating confirm/cancel buttons */
        .pen-confirm-btns {
            position: absolute;
            display: none;
            gap: 6px;
            z-index: 100;
            pointer-events: auto;
        }
        .pen-confirm-btns.show {
            display: flex;
        }
        .pen-confirm-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.06);
            transition: transform 0.15s, background 0.15s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .pen-confirm-btn:active { transform: scale(0.9); }
        .pen-confirm-btn.confirm {
            background: #4a9eff;
            color: #fff;
        }
        .pen-confirm-btn.confirm:hover { background: #5aadff; }
        .pen-confirm-btn.cancel {
            background: #3a3d42;
            color: #999;
        }
        .pen-confirm-btn.cancel:hover { background: #4a4d52; color: #ccc; }
        
        .timeline-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }
        
        /* Scrub ruler + playhead */
        .timeline-right-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .scrub-ruler {
            height: 32px;
            background: #26282c;
            border-bottom: 1px solid rgba(0,0,0,0.2);
            flex-shrink: 0;
            overflow-x: auto;
            overflow-y: hidden;
            cursor: pointer;
            position: relative;
            touch-action: none;
            scrollbar-width: none;
        }
        
        .scrub-ruler::-webkit-scrollbar {
            display: none;
        }
        
        .scrub-ruler-inner {
            position: relative;
            height: 100%;
            min-width: 100%;
        }
        
        .scrub-tick {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .scrub-tick-line {
            width: 1px;
            background: #444;
            flex: 1;
        }
        
        .scrub-tick-label {
            font-size: 8px;
            color: #888;
            position: absolute;
            top: 1px;
            white-space: nowrap;
            pointer-events: none;
        }
        
        .timeline-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff4444;
            z-index: 20;
            pointer-events: none;
            display: none;
        }
        
        .timeline-playhead.visible {
            display: block;
        }
        
        .playhead-handle {
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #ff4444;
            pointer-events: none;
        }
        
        .timeline-layers-section {
            width: 220px;
            min-width: 160px;
            max-width: 400px;
            background: #2b2d31;
            border-right: 1px solid rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }
        
        .layer-panel-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 10;
            background: transparent;
            transition: background 0.2s;
        }
        
        .layer-panel-resize-handle:hover {
            background: rgba(91, 141, 239, 0.2);
        }
        
        .layer-panel-resize-handle:active {
            background: rgba(91, 141, 239, 0.35);
        }
        
        .layer-panel-resize-handle::before {
            content: '';
            position: absolute;
            right: 3px;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 30px;
            background: #3a3c42;
            border-radius: 1px;
        }
        
        .layers-header {
            padding: 6px 10px;
            background: #2b2d31;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            -webkit-user-select: none;
            min-height: 32px;
            box-sizing: border-box;
            color: #888;
            letter-spacing: 0.5px;
        }
        
        .tl-label {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(0,0,0,0.15);
            min-height: calc(var(--frame-w, 80px) + 24px);
            box-sizing: border-box;
            cursor: pointer;
            font-size: 12px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            background: #2b2d31;
        }
        
        .tl-label-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .quick-key-btn {
            margin-left: auto;
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            color: #555;
            transition: color 0.15s;
            box-shadow: none;
        }
        .quick-key-btn:hover { color: #eebb00; }
        .quick-key-btn.has-key { color: #dda520; }
        .quick-key-btn.has-key:hover { color: #eedd44; }
        
        .tl-label.active-row {
            background: rgba(91, 141, 239, 0.08);
        }
        
        .tl-label.inactive-row {
            opacity: 0.65;
        }
        
        .tl-label .layer-visibility {
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            width: 18px;
            height: 18px;
        }
        
        .tl-label .layer-visibility:hover {
            color: #ddd;
        }
        
        .tl-label .layer-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        
        .tl-label .layer-drag-handle {
            cursor: grab;
            color: #555;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            touch-action: none;
        }
        
        .tl-label .layer-drag-handle:active {
            cursor: grabbing;
        }
        
        .tl-label.dragging {
            opacity: 0.4;
        }
        
        .tl-label.drop-before::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
            z-index: 10;
        }
        
        .tl-label.drop-after::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
            z-index: 10;
        }
        
        .layer-buttons {
            display: flex;
            gap: 5px;
        }
        
        .add-layer-btn-inline {
            padding: 3px 9px;
            font-size: 14px;
            background: #2b2d31;
            border: none;
            color: #6aadff;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .add-layer-btn-inline:hover {
            background: #30323a;
        }
        
        .delete-layer-btn-inline {
            padding: 3px 9px;
            font-size: 14px;
            background: #2b2d31;
            border: none;
            color: #e07070;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .delete-layer-btn-inline:hover {
            background: #30323a;
        }
        
        .timeline-layers-section .layers-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        .timeline-layers-section .layers-list::-webkit-scrollbar {
            display: none;
        }
        
        .timeline-frames-section {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            background: #26282c;
        }
        
        /* Audio Timeline (multi-track) */
        .audio-tracks-container {
            flex-shrink: 0;
        }
        
        .audio-timeline {
            display: flex;
            border-top: 1px solid #3a3a3a;
            height: 54px;
            flex-shrink: 0;
        }
        
        .audio-timeline-label {
            background: #1a1a2e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 4px 8px;
            gap: 4px;
            flex-shrink: 0;
            min-width: 0;
        }
        
        .audio-track-header {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            color: #8888cc;
            white-space: nowrap;
            overflow: hidden;
        }
        
        .audio-track-header svg {
            flex-shrink: 0;
        }
        
        .audio-track-name {
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .audio-controls button {
            width: 18px;
            height: 18px;
            padding: 0;
            border: 1px solid #444;
            border-radius: 3px;
            background: #2a2a3e;
            color: #aaa;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .audio-controls button:hover {
            background: #3a3a4e;
            border-color: #666;
        }
        
        .audio-controls button.audio-remove-btn {
            background: #4a2020;
            border-color: #633;
            color: #cc6666;
            margin-left: 2px;
        }
        
        .audio-controls button.audio-remove-btn:hover {
            background: #6a3030;
        }
        
        .audio-controls button.audio-mute-btn.muted {
            background: #6a4000;
            border-color: #885500;
            color: #ffaa33;
        }
        
        .layer-item.audio-layer-item {
            background: #1a1a2e;
            border-bottom: none;
            border-top: 1px solid #3a3a3a;
        }
        
        .layer-item.audio-layer-item .layer-name {
            color: #8888cc;
        }
        
        .layer-item.audio-layer-item.active {
            background: #252540;
        }
        
        .audio-vol-display {
            font-size: 9px;
            color: #999;
            min-width: 28px;
            text-align: center;
        }
        
        .audio-timeline-waveform {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
            background: #1a1a2e;
            scrollbar-width: none;
        }
        
        .audio-timeline-waveform::-webkit-scrollbar {
            display: none;
        }
        
        .audio-waveform-canvas {
            display: block;
            height: 100%;
        }
        
        .audio-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff4444;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        .frames-container {
            display: flex;
            flex-direction: column;
            min-width: fit-content;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
        }
        
        .layer-frames-row {
            display: flex;
            padding: 6px 10px;
            gap: 0;
            border-bottom: 1px solid #333;
            align-items: center;
            min-height: calc(var(--frame-w, 80px) + 24px);
        }
        
        .frame-offset-spacer {
            flex-shrink: 0;
            height: 100%;
            position: relative;
            cursor: pointer;
        }
        
        .frame-offset-spacer::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: repeating-linear-gradient(90deg, transparent 0, transparent 6px, rgba(255,255,255,0.08) 6px, rgba(255,255,255,0.08) 12px);
            transform: translateY(-50%);
        }
        
        .frame-block {
            display: flex;
            gap: 5px;
            position: relative;
            align-items: center;
            border-radius: 6px;
            border: 2px solid transparent;
            transition: border-color 0.15s;
            padding: 0 2px;
            overflow: visible;
        }
        
        .frame-block:hover {
            border-color: rgba(255,255,255,0.08);
        }
        
        .frame-block.sliding {
            border-color: rgba(0, 180, 255, 0.4);
            background: rgba(0, 180, 255, 0.05);
        }
        
        .frame-block .slide-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            background: linear-gradient(90deg, rgba(0, 180, 255, 0.4), transparent);
            border-radius: 3px 0 0 3px;
            cursor: ew-resize;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
        }
        
        .frame-block .slide-handle::after {
            content: 'â‹®';
            position: absolute;
            top: 50%;
            left: 2px;
            transform: translateY(-50%);
            font-size: 10px;
            color: rgba(255,255,255,0.8);
            line-height: 1;
        }
        
        .frame-block:hover .slide-handle,
        .frame-block.sliding .slide-handle {
            opacity: 1;
        }
        
        .layer-frames-row.inactive-row {
            opacity: 0.55;
        }
        
        .layer-frames-row.active-row {
            background: rgba(91, 141, 239, 0.05);
        }

        .frame {
            width: var(--frame-w, 80px);
            height: auto;
            border: none;
            border-radius: 4px;
            cursor: grab;
            position: relative;
            flex-shrink: 0;
            background: transparent;
            transition: transform 0.15s, opacity 0.15s;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            overflow: visible;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .frame-thumb {
            width: 100%;
            height: var(--frame-w, 80px);
            border: none;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            background: #26282c;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
            transition: box-shadow 0.15s;
        }
        
        .frame:active {
            cursor: grabbing;
        }
        
        /* Single frame right-edge drag handle (to create hold frames) */
        .frame-extend-handle {
            position: absolute;
            right: -2px;
            top: 0;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            z-index: 4;
            border-radius: 0 6px 6px 0;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .frame-extend-handle::after {
            content: '';
            position: absolute;
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 20px;
            background: rgba(255,255,255,0.15);
            border-radius: 1px;
        }
        .frame:hover .frame-extend-handle,
        .frame-extend-handle:hover {
            opacity: 1;
        }
        .frame-extend-handle:hover::after {
            background: rgba(91,141,239,0.6);
            height: 28px;
        }
        
        .frame.dragging {
            opacity: 0.3;
            transform: scale(0.9);
        }

        .frames-container.is-dragging .frame:not(.dragging) {
            cursor: grabbing;
        }
        
        .frame-drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.85;
            border: none;
            border-radius: 8px;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03), 0 0 0 2px rgba(91,141,239,0.4);
            transform: translate(-50%, -50%) scale(1.05);
            background: #2b2d31;
            overflow: hidden;
        }
        
        .frame-drag-ghost .drag-count-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            min-width: 20px;
            height: 20px;
            background: #5b8def;
            color: #fff;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            z-index: 1;
        }
        
        .frame-drop-indicator {
            position: absolute;
            width: 3px;
            height: var(--frame-w, 80px);
            background: #4a9eff;
            border-radius: 2px;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(74, 158, 255, 0.6);
            top: 10px;
        }

        .frame:hover .frame-thumb {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.04);
        }

        .frame.active .frame-thumb {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3), inset -1px -1px 3px rgba(255,255,255,0.03), 0 0 0 2px rgba(91,141,239,0.5);
        }
        
        .frame.selected .frame-thumb {
            background: rgba(91,141,239,0.08);
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3), inset -1px -1px 3px rgba(255,255,255,0.03), 0 0 0 2px rgba(91,141,239,0.3);
        }
        
        .frame.active.selected .frame-thumb {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.3), inset -1px -1px 3px rgba(255,255,255,0.03), 0 0 0 2px rgba(91,141,239,0.5);
        }
        
        .hold-block.selected {
            outline: 2px solid rgba(91,141,239,0.4);
            outline-offset: -1px;
            border-radius: 8px;
            background: rgba(91,141,239,0.06);
        }
        .hold-block.selected.has-active {
            outline-color: rgba(91,141,239,0.55);
        }
        
        .frame-select-banner {
            display: none;
            background: rgba(91,141,239,0.1);
            color: #6aadff;
            font-size: 12px;
            font-weight: 600;
            padding: 4px 12px;
            text-align: center;
            border-bottom: 1px solid rgba(91,141,239,0.15);
            letter-spacing: 0.3px;
        }
        
        .frame-select-banner.show {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .frame-select-banner .done-btn {
            background: #2b2d31;
            color: #6aadff;
            border: none;
            border-radius: 6px;
            padding: 2px 10px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .frame.hold-frame {
            /* legacy â€” no longer used for block-style holds */
        }
        
        .hold-badge {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 7px;
            font-weight: bold;
            padding: 1px 3px;
            border-radius: 2px;
            pointer-events: none;
            z-index: 2;
            letter-spacing: 0.5px;
        }
        
        .hold-tint {
            position: absolute;
            inset: 0;
            border-radius: 2px;
            pointer-events: none;
            z-index: 1;
        }
        
        /* === Hold Block: merged continuous bar for held frames === */
        .hold-block {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            overflow: visible;
        }
        
        .hold-block:active {
            cursor: grabbing;
        }
        
        .hold-block.dragging {
            opacity: 0.35;
            transform: scale(0.97);
        }
        
        .hold-block-bar {
            display: flex;
            align-items: stretch;
            height: var(--frame-w, 80px);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            width: 100%;
        }
        
        /* Source cell â€” first frame in the hold group */
        .hold-block-source {
            width: var(--frame-w, 80px);
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #26282c;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
            z-index: 1;
        }
        
        /* Active source â€” playhead is on the first frame of the hold */
        .hold-block-source.source-active {
            box-shadow: inset 0 0 0 2px rgba(91,141,239,0.5), inset 2px 2px 4px rgba(0,0,0,0.3), inset -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        /* Single-frame hold block (length=1) rounds both sides */
        .hold-block[data-hold-length="1"] .hold-block-source {
            border-radius: 6px;
        }
        
        /* Tail region containing the connecting bar */
        .hold-block-tail {
            flex: 1;
            min-width: 0;
            position: relative;
            background: transparent;
        }
        
        /* Connecting rectangle running through the vertical center of the tail */
        .hold-block-connector {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 14px;
            transform: translateY(-50%);
            border-radius: 0 3px 3px 0;
            opacity: 0.7;
        }
        
        /* Tick marks inside tail showing frame divisions */
        .hold-block-tail-ticks {
            position: absolute;
            inset: 0;
            display: flex;
            pointer-events: none;
            z-index: 1;
        }
        
        .hold-block-tick {
            flex-shrink: 0;
            height: 100%;
            position: relative;
        }
        
        .hold-block-tick::after {
            content: '';
            position: absolute;
            right: 0;
            top: 25%;
            height: 50%;
            width: 1px;
            background: rgba(255,255,255,0.08);
        }
        
        /* Resize handle on right edge */
        .hold-block-handle {
            width: 10px;
            cursor: ew-resize;
            flex-shrink: 0;
            position: relative;
            z-index: 2;
            border-radius: 0 6px 6px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hold-block-handle::after {
            content: '';
            width: 2px;
            height: 20px;
            background: rgba(255,255,255,0.15);
            border-radius: 1px;
        }
        
        .hold-block-handle:hover::after {
            background: rgba(91,141,239,0.6);
            height: 28px;
        }
        
        /* Playhead highlight within hold block */
        .hold-block-playhead {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(91,141,239,0.12);
            pointer-events: none;
            z-index: 0;
            border-radius: 4px;
            box-shadow: inset 0 0 0 1.5px rgba(91,141,239,0.35);
        }
        
        .hold-block-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(91,141,239,0.30);
            pointer-events: none;
            z-index: 3;
            border-radius: 4px;
            box-shadow: inset 0 0 0 2px rgba(91,141,239,0.6);
        }
        
        .hold-block .frame-number {
            font-size: 9px;
            color: #888;
            text-align: left;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none;
            line-height: 1;
            white-space: nowrap;
            margin-top: 2px;
        }
        
        .hold-block.has-active .frame-number {
            color: #6aadff;
            font-weight: 600;
        }
        
        /* Connector extends into source cell too â€” rendered via a pseudo-element */
        .hold-block-source-connector {
            position: absolute;
            right: 0;
            top: 50%;
            width: 50%;
            height: 14px;
            transform: translateY(-50%);
            border-radius: 3px 0 0 3px;
            opacity: 0.7;
            z-index: 0;
        }

        .frame-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1;
        }
        
        .frame-indicator.circle {
            width: 35%;
            height: 0;
            padding-bottom: 35%;
            border-radius: 50%;
            background: #555;
        }
        
        .frame.active .frame-indicator.circle {
            background: #5b8def;
        }
        
        .frame-indicator.square {
            width: 22%;
            height: 0;
            padding-bottom: 22%;
            border-radius: 2px;
            background: #999;
        }
        
        .frame.active .frame-indicator.square {
            background: #4a9eff;
        }
        
        .frame-indicator.square-outline {
            width: 22%;
            height: 0;
            padding-bottom: 22%;
            border-radius: 2px;
            background: transparent;
            border: 1.5px solid #999;
        }
        
        .frame.active .frame-indicator.square-outline {
            border-color: #4a9eff;
        }

        .frame-number {
            font-size: 9px;
            color: #888;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none;
            line-height: 1;
            white-space: nowrap;
        }
        
        .frame.active .frame-number {
            color: #6aadff;
            font-weight: 600;
        }

        .add-frame {
            width: var(--frame-w, 80px);
            height: var(--frame-w, 80px);
            border: 2px dashed rgba(255,255,255,0.08);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #555;
            flex-shrink: 0;
            margin-left: 5px;
        }

        .add-frame:hover {
            border-color: rgba(255,255,255,0.15);
            color: #888;
        }
        /* Brush cursor overlay */
        .brush-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            border: 1.5px solid rgba(91, 141, 239, 0.8);
            display: none;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
        
        .brush-cursor.round {
            border-radius: 50%;
        }
        
        .brush-cursor.square {
            border-radius: 0;
        }
        
        .brush-cursor.oval-h,
        .brush-cursor.oval-v {
            border-radius: 50%;
        }
        
        /* Brush/Eraser dropdown panel */
        .brush-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 12px;
            margin-top: 4px;
            min-width: 200px;
            z-index: 1000;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03);
            padding: 10px;
        }
        
        .brush-dropdown.show {
            display: block;
        }
        
        .brush-setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .brush-setting-row:last-child {
            margin-bottom: 0;
        }
        
        .brush-setting-row label {
            margin-right: 8px;
            white-space: nowrap;
        }
        
        .brush-setting-row input[type="range"] {
            width: 80px;
        }
        
        .brush-setting-row select {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #e0e0e0;
            padding: 3px 6px;
            font-size: 12px;
        }
        
        .shape-picker {
            display: flex;
            gap: 4px;
        }
        
        .shape-icon {
            width: 30px;
            height: 30px;
            background: #2b2d31;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3), -1px -1px 3px rgba(255,255,255,0.03);
        }
        
        .shape-icon:hover {
            background: #30323a;
        }
        
        .shape-icon.active {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
            background: rgba(91,141,239,0.1);
        }
        
        .shape-icon svg {
            width: 20px;
            height: 20px;
        }
        
        .brush-setting-value {
            min-width: 28px;
            text-align: right;
            font-size: 11px;
            color: #aaa;
        }

        .smoothing-mode-toggle {
            display: flex;
            background: rgba(0,0,0,0.25);
            border-radius: 7px;
            padding: 2px;
        }
        .smoothing-mode-toggle .smt-btn {
            flex: 1;
            color: #555;
            font-size: 10px;
            font-weight: 600;
            padding: 4px 10px;
            cursor: pointer;
            letter-spacing: 0.4px;
            text-transform: uppercase;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
        }
        .smoothing-mode-toggle .smt-btn.active { color: #eee; }

        /* Onion skin dropdown panel */
        .onion-skin-dropdown {
            display: none;
            position: absolute;
            bottom: 100%;
            right: 0;
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.04);
            border-radius: 14px;
            margin-bottom: 6px;
            width: 224px;
            z-index: 1000;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.02);
            padding: 4px 0;
        }
        
        .onion-skin-dropdown.show {
            display: block;
        }
        
        .onion-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 7px 14px;
            font-size: 11px;
        }
        .onion-row + .onion-row {
            border-top: 1px solid rgba(255,255,255,0.04);
        }
        .onion-row-label {
            color: #888;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .onion-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1.5px solid rgba(255,255,255,0.1);
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            appearance: none;
            -webkit-appearance: none;
        }
        .onion-color-dot::-webkit-color-swatch-wrapper { padding: 0; }
        .onion-color-dot::-webkit-color-swatch { border: none; border-radius: 50%; }
        .onion-color-dot::-moz-color-swatch { border: none; border-radius: 50%; }
        .onion-inline-stepper {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.04);
            border-radius: 6px;
            overflow: hidden;
        }
        .onion-inline-stepper button {
            width: 22px;
            height: 22px;
            border: none;
            background: none;
            color: #888;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: background 0.1s;
        }
        .onion-inline-stepper button:hover {
            background: rgba(255,255,255,0.06);
        }
        .onion-inline-stepper button:active {
            background: rgba(255,255,255,0.1);
        }
        .onion-inline-stepper .onion-stepper-val {
            width: 20px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            color: #ddd;
        }
        .onion-inline-stepper .onion-stepper-val-wide {
            width: 32px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            color: #ddd;
        }
        .onion-mini-toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .onion-mini-toggle.on { background: #4a9eff; }
        .onion-mini-toggle.off { background: rgba(255,255,255,0.12); }
        .onion-mini-toggle::after {
            content: '';
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            transition: left 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .onion-mini-toggle.on::after { left: 16px; }
        .onion-mini-toggle.off::after { left: 2px; }
        .onion-opacity-row {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 7px 14px;
            border-top: 1px solid rgba(255,255,255,0.04);
            font-size: 11px;
        }
        .onion-opacity-label { color: #888; white-space: nowrap; }
        .onion-opacity-val {
            font-size: 10px;
            color: #999;
            min-width: 28px;
            text-align: right;
        }

        /* Frame context menu */
        .frame-context-menu {
            display: none;
            position: fixed;
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            min-width: 160px;
            z-index: 2000;
            box-shadow: 6px 6px 16px rgba(0,0,0,0.5), -3px -3px 10px rgba(255,255,255,0.03);
            padding: 4px 0;
        }
        
        .frame-context-menu.show {
            display: block;
        }
        
        .frame-context-menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 8px 14px;
            background: none;
            border: none;
            color: #c0c0c0;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            box-shadow: none;
        }
        
        .frame-context-menu-item:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .frame-context-menu-item.disabled {
            color: #555;
            cursor: default;
        }
        
        .frame-context-menu-item.disabled:hover {
            background: none;
        }
        
        .frame-context-menu-item .shortcut {
            font-size: 11px;
            color: #666;
            margin-left: 16px;
        }
        
        .frame-context-menu-divider {
            height: 1px;
            background: rgba(255,255,255,0.05);
            margin: 4px 0;
        }

        .pressure-toggle {
            width: 28px;
            height: 28px;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: #36393f;
            color: #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-left: 4px;
            transition: all 0.15s;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
        }
        .pressure-toggle:hover { background: #3e4147; }
        .pressure-toggle.active {
            color: #6aadff;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
            background: #2b2d31;
        }

        /* Make responsive for smaller screens */
        @media (max-width: 1024px) {
            .timeline-layers-section {
                width: 140px;
            }
            
            .add-frame {
                width: var(--frame-w, 80px);
                height: var(--frame-w, 80px);
            }
        }

        @media (max-width: 768px) {
            .app-container {
                min-height: 100vh;
                min-height: 100dvh;
                min-height: var(--app-height, 100dvh);
            }
            
            /* Toolbar: 2-row wrapping layout â€” all buttons visible */
            .toolbar {
                flex-wrap: wrap;
                padding: 4px 6px;
                gap: 2px;
                overflow: visible;
                max-height: none;
            }
            
            .tool-group {
                padding: 0 3px;
                border-right: 1px solid rgba(255,255,255,0.04);
                flex-shrink: 0;
                flex-wrap: nowrap;
                gap: 2px;
                align-items: center;
            }
            .tool-group:last-child { border-right: none; }
            
            /* Icon-only buttons on mobile */
            .btn-label {
                display: none;
            }
            
            button {
                padding: 7px;
                font-size: 15px;
                min-width: 38px;
                min-height: 38px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
            }
            
            /* Active press state â€” immediate feedback for Apple Pencil & touch */
            button:active {
                box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 3px rgba(255,255,255,0.03);
                transform: scale(0.93);
                transition: none;
            }
            
            input[type="range"] {
                width: 50px;
                min-height: 32px;
                flex-shrink: 0;
            }
            
            input[type="color"] {
                min-width: 34px;
                min-height: 34px;
                width: 34px;
                height: 34px;
                flex-shrink: 0;
                border-radius: 50%;
            }
            
            .gradient-swatch {
                width: 32px;
                height: 20px;
            }
            
            .swap-colors-btn {
                width: 20px !important;
                height: 20px !important;
                min-width: 20px;
                font-size: 10px;
            }
            
            .grad-type-btn {
                width: 24px !important;
                height: 24px !important;
                min-width: 24px;
            }
            
            /* Hide labels in toolbar */
            .tool-group > label {
                display: none;
            }
            #sizeValue {
                font-size: 10px;
                font-weight: 600;
                min-width: 26px;
                height: 22px;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #2b2d31;
                border: none;
                border-radius: 6px;
                color: #a0a0a0;
                font-variant-numeric: tabular-nums;
                box-sizing: border-box;
                box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
            }
            
            .size-step-btn {
                width: 22px;
                height: 22px;
                padding: 0;
                border: none;
                border-radius: 6px;
                background: #2b2d31;
                color: #999;
                font-size: 14px;
                line-height: 1;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
                box-shadow: 2px 2px 4px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
            }
            .size-step-btn:hover { background: #30323a; color: #ccc; }
            .size-step-btn:active { box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03); }
            
            .pressure-toggle {
                width: 24px;
                height: 22px;
                padding: 0;
                border: none;
                border-radius: 6px;
                background: #2b2d31;
                color: #555;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
                margin-left: 4px;
                transition: all 0.15s;
                box-shadow: 2px 2px 4px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
            }
            .pressure-toggle:hover { background: #30323a; }
            .pressure-toggle.active {
                color: #6aadff;
                box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
                background: #2b2d31;
            }
            
            /* Keep dropdown containers inline */
            .dropdown-container {
                flex-shrink: 0;
            }
            
            /* Timeline compact */
            .timeline {
                min-height: 120px;
                height: 20vh;
            }
            
            .timeline-layers-section {
                width: 85px;
            }
            
            /* Timeline controls: scrollable row */
            .timeline-header {
                overflow: hidden;
            }
            .timeline-controls {
                padding: 4px 6px;
                flex-wrap: wrap;
                gap: 4px;
            }
            .timeline-controls::-webkit-scrollbar { display: none; }
            
            .playback-controls {
                flex-shrink: 0;
                flex-wrap: wrap;
                gap: 2px;
            }
            
            .playback-controls button {
                padding: 5px;
                font-size: 13px;
                min-width: 34px;
                min-height: 34px;
            }
            
            .playback-controls .play-mode-arrow {
                min-width: 22px;
                width: 22px;
                padding: 0;
            }
            
            .fps-control {
                flex-shrink: 0;
            }
            .fps-badge-value {
                font-size: 13px;
            }
            .fps-step-btn {
                width: 28px;
                height: 28px;
            }
            .fps-popover {
                right: auto;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .add-frame {
                width: var(--frame-w, 80px);
                height: var(--frame-w, 80px);
            }
            
            .layer-name {
                font-size: 10px;
            }
            
            .layer-opacity-control {
                padding-left: 4px;
            }
            .layer-opacity-control input[type="range"] {
                width: 45px;
                min-height: 20px;
            }
            
            /* Layers header buttons */
            .add-layer-btn-inline,
            .delete-layer-btn-inline {
                min-width: 32px;
                min-height: 32px;
                padding: 4px;
                font-size: 14px;
            }
            
            /* Dropdowns: centered overlay on mobile */
            .dropdown-menu,
            .brush-dropdown,
            .onion-skin-dropdown {
                position: fixed;
                top: 50%;
                left: 50%;
                right: auto;
                transform: translate(-50%, -50%);
                min-width: 240px;
                max-width: calc(100vw - 32px);
                max-height: 70vh;
                overflow-y: auto;
                z-index: 2000;
            }
            
            /* Dropdown items: touch-friendly size */
            .dropdown-item {
                padding: 12px 14px;
                min-height: 44px;
            }
            
            /* Submenu: inline on mobile instead of fly-out */
            .dropdown-submenu {
                position: static !important;
                padding-left: 0 !important;
            }
            
            .dropdown-submenu-inner {
                border: none !important;
                box-shadow: none !important;
                border-radius: 0 !important;
                min-width: 0 !important;
                background: rgba(0,0,0,0.15) !important;
            }
            
            .dropdown-submenu .dropdown-item {
                padding-left: 28px;
            }
            
            /* Canvas area */
            .canvas-container {
                min-height: 140px;
            }
        }

        @media (max-width: 480px) {
            .toolbar {
                padding: 3px 4px;
                gap: 1px;
            }
            
            .toolbar button {
                padding: 5px;
                font-size: 14px;
                min-width: 34px;
                min-height: 34px;
            }
            
            .tool-group {
                gap: 1px;
                padding: 0 2px;
            }
            
            .timeline-layers-section {
                width: 70px;
            }
            
            .timeline {
                min-height: 110px;
                height: 18vh;
            }
            
            .playback-controls button {
                min-width: 30px;
                min-height: 30px;
                padding: 4px;
                font-size: 12px;
            }
            
            .playback-controls .play-mode-arrow {
                min-width: 20px;
                width: 20px;
                padding: 0;
            }
            
            .add-frame {
                width: var(--frame-w, 80px);
                height: var(--frame-w, 80px);
                font-size: 16px;
            }
            
            input[type="color"] {
                min-width: 30px;
                min-height: 30px;
                width: 30px;
                height: 30px;
                border-radius: 50%;
            }
            
            input[type="range"] {
                width: 44px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .timeline {
                min-height: 80px;
                height: 20vh;
            }
            
            .toolbar {
                padding: 3px 5px;
            }
            
            button {
                padding: 4px 6px;
            }
        }

        /* File drop zone overlay */
        .drop-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 120, 255, 0.15);
            border: 3px dashed #0078ff;
            z-index: 9999;
            pointer-events: none;
            align-items: center;
            justify-content: center;
        }
        
        .drop-overlay.active {
            display: flex;
        }
        
        .drop-overlay-label {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Canvas Size Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-overlay.show {
            display: flex;
        }
        .modal-dialog {
            background: #2b2d31;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 16px;
            width: 380px;
            max-width: 95vw;
            box-shadow: 10px 10px 30px rgba(0,0,0,0.5), -5px -5px 15px rgba(255,255,255,0.02);
            overflow: hidden;
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px 12px;
            border-bottom: 1px solid rgba(0,0,0,0.2);
        }
        .modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #d0d0d0;
        }
        .modal-close {
            background: none;
            border: none;
            color: #666;
            font-size: 22px;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
            box-shadow: none;
        }
        .modal-close:hover { color: #fff; }
        .modal-body {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .modal-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .modal-row > label {
            color: #aaa;
            font-size: 13px;
            min-width: 55px;
            flex-shrink: 0;
        }
        .modal-row select {
            flex: 1;
            background: #2b2d31;
            color: #d0d0d0;
            border: none;
            border-radius: 8px;
            padding: 7px 10px;
            font-size: 13px;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
        }
        .modal-size-row {
            justify-content: center;
            gap: 8px;
        }
        .modal-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }
        .modal-field label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .modal-input-wrap {
            display: flex;
            align-items: center;
            background: #2b2d31;
            border: none;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.35), inset -1px -1px 3px rgba(255,255,255,0.03);
        }
        .modal-input-wrap input {
            flex: 1;
            background: transparent;
            color: #d0d0d0;
            border: none;
            padding: 8px 10px;
            font-size: 14px;
            width: 60px;
            outline: none;
        }
        .modal-input-wrap input:focus {
            box-shadow: none;
        }
        .modal-unit {
            color: #666;
            font-size: 12px;
            padding-right: 10px;
            flex-shrink: 0;
        }
        .modal-link-btn {
            background: none;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: #666;
            cursor: pointer;
            padding: 6px;
            margin-top: 16px;
            transition: all 0.15s;
            box-shadow: none;
        }
        .modal-link-btn:hover { border-color: rgba(255,255,255,0.2); color: #aaa; }
        .modal-link-btn.linked { color: #6aadff; border-color: rgba(91,141,239,0.4); }
        .modal-info {
            font-size: 12px;
            color: #555;
            text-align: center;
            min-height: 16px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 20px 16px;
            border-top: 1px solid rgba(0,0,0,0.2);
        }
        .modal-btn {
            padding: 8px 20px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.35), -1px -1px 3px rgba(255,255,255,0.03);
        }
        .modal-btn-cancel {
            background: #2b2d31;
            color: #aaa;
        }
        .modal-btn-cancel:hover { background: #30323a; }
        .modal-btn-apply {
            background: #2b2d31;
            color: #6aadff;
        }
        .modal-btn-apply:hover { background: #30323a; }

    </style>
</head>
<body>
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-label"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 1.5h8l3 3V13a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13V3a1.5 1.5 0 011-1.5z"/><path d="M5 1.5v4h6v-4"/><path d="M5 14.5v-4h6v4"/></svg> Drop .fby file to open</div>
    </div>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <div class="dropdown-container">
                    <button id="fileMenuBtn" title="File (Save/Load/Export)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 1.5h8l3 3V13a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13V3a1.5 1.5 0 011-1.5z"/><path d="M5 1.5v4h6v-4"/><path d="M5 14.5v-4h6v4"/></svg> <span class="btn-label">File â–¼</span></button>
                    <div class="dropdown-menu" id="fileMenuDropdown">
                        <button class="dropdown-item" id="canvasSizeBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1.5" y="1.5" width="13" height="13" rx="1" stroke-dasharray="2 2"/><path d="M10 6l3-3M13 6V3h-3"/><path d="M6 10l-3 3M3 10v3h3"/></svg> Canvas Sizeâ€¦</button>
                        <button class="dropdown-item" id="gridToggleBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="5.5" x2="15" y2="5.5"/><line x1="1" y1="10.5" x2="15" y2="10.5"/><line x1="5.5" y1="1" x2="5.5" y2="15"/><line x1="10.5" y1="1" x2="10.5" y2="15"/><line x1="3" y1="2" x2="8" y2="8"/><line x1="8" y1="8" x2="13" y2="2"/><line x1="3" y1="14" x2="8" y2="8"/><line x1="8" y1="8" x2="13" y2="14"/></svg> <span id="gridToggleLabel">Show Grid</span> <span class="shortcut">â‡§G</span></button>
                        <div class="dropdown-divider"></div>
                        <button class="dropdown-item" id="saveProjectBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M3 1.5h8l3 3V13a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13V3a1.5 1.5 0 011-1.5z"/><path d="M5 1.5v4h6v-4"/><path d="M5 14.5v-4h6v4"/></svg> Save Project (.fby) <span class="shortcut">âŒ˜S</span></button>
                        <button class="dropdown-item" id="loadProjectBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M2 4v9a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H8L6.5 3H3a1 1 0 00-1 1z"/></svg> Load Project (.fby) <span class="shortcut">âŒ˜O</span></button>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-submenu-container">
                            <button class="dropdown-item submenu-trigger"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M8 1v5m-2-2l2 2 2-2"/><rect x="2" y="6" width="12" height="8" rx="1"/></svg> Import <span class="submenu-arrow">â–¶</span></button>
                            <div class="dropdown-submenu">
                              <div class="dropdown-submenu-inner">
                                <button class="dropdown-item" id="importSequenceBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="3" width="8" height="8" rx="1"/><rect x="4" y="1.5" width="8" height="8" rx="1"/><path d="M13 6v5M10.5 8.5h5"/></svg> Image Sequenceâ€¦</button>
                                <button class="dropdown-item" id="importAudioBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M8 2v9"/><circle cx="5.5" cy="11" r="2.5" fill="none"/><path d="M1 7v2c0 1 .5 1.5 1.5 1.5M15 7v2c0 1-.5 1.5-1.5 1.5"/><path d="M3 5v4M5 3.5v7M13 5v4M11 3.5v7"/></svg> Audioâ€¦</button>
                              </div>
                            </div>
                        </div>
                        <div class="dropdown-submenu-container">
                            <button class="dropdown-item submenu-trigger"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="12" height="10" rx="1"/><path d="M8 1v5m-2-2l2 2 2-2"/></svg> Export <span class="submenu-arrow">â–¶</span></button>
                            <div class="dropdown-submenu">
                              <div class="dropdown-submenu-inner">
                                <button class="dropdown-item" id="exportPngZip"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="2" width="12" height="12" rx="1"/><circle cx="6" cy="7" r="1.5"/><path d="M2 11l3-3 2 2 3-3 4 4"/></svg> PNG Frames (ZIP)</button>
                                <button class="dropdown-item" id="exportGifBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="4" y="1" width="8" height="14" rx="1"/><path d="M6 1v14M10 1v14M4 5h8M4 9h8M4 13h8"/></svg> GIF Animation</button>
                                <button class="dropdown-item" id="exportMp4Btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="3" width="14" height="10" rx="1"/><path d="M6 6.5v3.5l3.5-1.75z" fill="currentColor" stroke="none"/></svg> MP4 Video</button>
                              </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="tool-group">
                <div class="dropdown-container">
                    <button id="brushTool" class="active" title="Brush (B)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10.5 1.5l4 4-8 8H2.5v-4z"/><path d="M8.5 3.5l4 4"/></svg> <span class="btn-label">Brush â–¼</span></button>
                    <div class="brush-dropdown" id="brushDropdown">
                        <div class="brush-setting-row">
                            <label>Pressure:</label>
                            <div class="onion-mini-toggle on" id="pressureEnabled"></div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Shape:</label>
                            <div class="shape-picker" id="brushShapePicker">
                                <div class="shape-icon active" data-shape="round" title="Round">
                                    <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="square" title="Square">
                                    <svg viewBox="0 0 20 20"><rect x="2" y="2" width="16" height="16" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-h" title="Horizontal Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="9" ry="4" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-v" title="Vertical Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="4" ry="9" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                            </div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Diameter:</label>
                            <input type="range" id="brushDiameter" min="1" max="100" value="8">
                            <span class="brush-setting-value" id="brushDiameterValue">8</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Smoothing:</label>
                            <input type="range" id="brushSmoothing" min="0" max="100" value="80">
                            <span class="brush-setting-value" id="brushSmoothingValue">80%</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Mode:</label>
                            <div class="smoothing-mode-toggle" id="smoothingModeToggle">
                                <div class="smt-btn active" data-mode="standard">Standard</div>
                                <div class="smt-btn" data-mode="smooth">Smooth</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="eraserTool" title="Eraser (E)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 14h8"/><path d="M3.5 10l6.5-6.5 3.5 3.5-5 5H5l-1.5-1.5z"/><path d="M10 3.5l3.5 3.5"/></svg> <span class="btn-label">Eraser â–¼</span></button>
                    <div class="brush-dropdown" id="eraserDropdown">
                        <div class="brush-setting-row">
                            <label>Pressure:</label>
                            <div class="onion-mini-toggle on" id="eraserPressureEnabled"></div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Shape:</label>
                            <div class="shape-picker" id="eraserShapePicker">
                                <div class="shape-icon active" data-shape="round" title="Round">
                                    <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="square" title="Square">
                                    <svg viewBox="0 0 20 20"><rect x="2" y="2" width="16" height="16" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-h" title="Horizontal Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="9" ry="4" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-v" title="Vertical Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="4" ry="9" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                            </div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Diameter:</label>
                            <input type="range" id="eraserDiameter" min="1" max="100" value="8">
                            <span class="brush-setting-value" id="eraserDiameterValue">8</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Smoothing:</label>
                            <input type="range" id="eraserSmoothing" min="0" max="100" value="0">
                            <span class="brush-setting-value" id="eraserSmoothingValue">0%</span>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="shapeTool" title="Shapes"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="1.5" y="1.5" width="6" height="6" rx="0.5"/><circle cx="11" cy="11" r="3.5"/></svg> <span class="btn-label">Shapes â–¼</span></button>
                    <div class="dropdown-menu" id="shapeDropdown">
                        <button class="dropdown-item" data-shape="pen"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M2 13C5 9 7 5 14 3"/><circle cx="2" cy="13" r="1.5" fill="currentColor" stroke="none"/><circle cx="14" cy="3" r="1.5" fill="currentColor" stroke="none"/></svg> Pen<span class="shortcut">P</span></button>
                        <button class="dropdown-item" data-shape="rect"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="10" height="8" rx="0.5"/></svg> Rectangle</button>
                        <button class="dropdown-item" data-shape="roundrect"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="10" height="8" rx="2.5"/></svg> Rounded Rect</button>
                        <button class="dropdown-item" data-shape="circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7.5" r="5"/></svg> Circle</button>
                        <button class="dropdown-item" data-shape="triangle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M7 2l6 11H1z"/></svg> Triangle</button>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="fillTool" title="Paint Bucket (K / F)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2C8 2 3 7.5 3 10.5a5 5 0 0010 0C13 7.5 8 2 8 2z" fill="currentColor"/></svg> <span class="btn-label">Fill â–¼</span><span class="gradient-badge"></span></button>
                    <div class="dropdown-menu" id="fillToolDropdown">
                        <button class="dropdown-item" data-filltool="fill"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M8 2C8 2 3 7.5 3 10.5a5 5 0 0010 0C13 7.5 8 2 8 2z" fill="currentColor"/></svg> Paint Bucket<span class="shortcut">F</span></button>
                        <button class="dropdown-item" data-filltool="gradient"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="2" width="12" height="12" rx="1.5"/><line x1="5" y1="14" x2="14" y2="5" stroke-opacity="0.4"/><line x1="2" y1="14" x2="14" y2="2" stroke-opacity="0.6"/><line x1="2" y1="11" x2="11" y2="2" stroke-opacity="0.4"/></svg> Gradient Fill<span class="shortcut">G</span></button>
                        <button class="dropdown-item" data-filltool="eyedropper"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M13.5 2.5a1.4 1.4 0 00-2 0L10 4l-1-.5-5 5-.5 3.5 3.5-.5 5-5L11.5 6l1.5-1.5a1.4 1.4 0 000-2z"/><path d="M3.5 12l.5.5"/></svg> Eyedropper<span class="shortcut">I</span></button>
                    </div>
                </div>
                <button id="lassoTool" title="Lasso Selection (L)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="8" cy="7" rx="6" ry="4.5"/><path d="M12.5 10c0 1.5-1 3-2 3.5s-1.5.5-1.5 1.5"/></svg> <span class="btn-label">Lasso</span></button>
                <div class="dropdown-container">
                    <button id="transformTool" title="Free Transform (V/T)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2.5" y="2.5" width="11" height="11" rx="0.5" stroke-dasharray="2 2"/><circle cx="2.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg> <span class="btn-label">Transform â–¼</span></button>
                    <div class="dropdown-menu" id="transformToolDropdown">
                        <button class="dropdown-item" data-xformtool="transform"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2.5" y="2.5" width="11" height="11" rx="0.5" stroke-dasharray="2 2"/><circle cx="2.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg> Free Transform <span class="shortcut">V</span></button>
                        <button class="dropdown-item" data-xformtool="scale"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M10 2h4v4"/><path d="M14 2l-4.5 4.5"/><path d="M6 14H2v-4"/><path d="M2 14l4.5-4.5"/></svg> Scale <span class="shortcut">S</span></button>
                        <button class="dropdown-item" data-xformtool="rotate"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M13.5 8A5.5 5.5 0 112.5 5.5"/><path d="M2.5 1.5v4h4"/></svg> Rotate <span class="shortcut">R</span></button>
                        <button class="dropdown-item" data-xformtool="skew"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M4 2.5h9.5v11H2.5V6"/><circle cx="4" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg> Skew</button>
                        <button class="dropdown-item" data-xformtool="distort"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M4 1.5L13 3l1 11.5L2 13z"/><circle cx="4" cy="1.5" r="1" fill="currentColor" stroke="none"/><circle cx="13" cy="3" r="1" fill="currentColor" stroke="none"/><circle cx="3" cy="13" r="1" fill="currentColor" stroke="none"/><circle cx="14" cy="14.5" r="1" fill="currentColor" stroke="none"/></svg> Distort</button>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="navTool" title="Magnifier (Z)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg> <span class="btn-label">Magnifier â–¼</span></button>
                    <div class="dropdown-menu" id="navToolDropdown">
                        <button class="dropdown-item" data-navtool="magnifier"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg> Zoom In <span class="shortcut">Z</span></button>
                        <button class="dropdown-item" data-navtool="magnifier-out"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7" r="5"/><path d="M5 7h4"/><path d="M11 11l3.5 3.5"/></svg> Zoom Out</button>
                        <div class="dropdown-divider"></div>
                        <button class="dropdown-item" data-navtool="pan"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M5.5 8V3.5a1 1 0 012 0V7"/><path d="M7.5 7V2.5a1 1 0 012 0V7"/><path d="M9.5 7V3.5a1 1 0 012 0V7"/><path d="M11.5 5.5a1 1 0 012 0V10c0 2.5-2 4.5-4.5 4.5h-1C6 14.5 4 12.5 4 10V8.5"/><path d="M5.5 8c0 0-2-1-2.5-2s0-2 1-1.5l1.5 1"/></svg> Pan / Hand <span class="shortcut">H</span></button>
                    </div>
                </div>
            </div>
            <div class="tool-group">
                <div class="color-pickers-wrap" id="colorPickersWrap">
                    <input type="color" id="colorPicker" value="#000000" title="Color A">
                    <input type="color" id="colorPickerB" value="#ffffff" title="Color B" class="color-b-picker">
                    <button class="swap-colors-btn" id="swapColorsBtn" title="Swap Colors (X)">â‡„</button>
                    <div class="gradient-swatch" id="gradientSwatch" title="Gradient stored â€” click to apply, Ã— to clear"><span class="swatch-clear" id="swatchClear" title="Clear stored gradient">Ã—</span></div>
                    <div class="gradient-type-toggle" id="gradientTypeToggle">
                        <button class="grad-type-btn active" data-gradtype="linear" title="Linear gradient"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5"><line x1="3" y1="13" x2="13" y2="3"/><circle cx="3" cy="13" r="1.5" fill="currentColor"/><circle cx="13" cy="3" r="1.5" fill="currentColor"/></svg></button>
                        <button class="grad-type-btn" data-gradtype="radial" title="Radial gradient"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="2"/><circle cx="8" cy="8" r="5"/></svg></button>
                    </div>
                </div>
                <button class="size-step-btn" id="brushSizeMinus" title="Decrease brush size ([)">âˆ’</button>
                <input type="range" id="brushSize" min="1" max="100" value="8">
                <button class="size-step-btn" id="brushSizePlus" title="Increase brush size (])">+</button>
                <span id="sizeValue">8</span>
                <button class="pressure-toggle active" id="pressureToggle" title="Brush Pressure">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14">
                        <path d="M2 2.5 C4 4, 8.5 8, 11 11 C12 12.5, 12.5 14, 11 14 C9.5 14, 8 12, 6.5 10 C4 7, 2 4, 2 2.5Z" fill="currentColor"/>
                    </svg>
                </button>
            </div>
            <div class="tool-group">
                <button id="copyBtn" title="Copy (Ctrl+C)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="1.5" width="9" height="11" rx="1"/><path d="M2 4.5v9a1 1 0 001 1h7"/></svg> <span class="btn-label">Copy</span></button>
                <button id="pasteBtn" title="Paste (Ctrl+V)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3.5" width="10" height="11" rx="1"/><path d="M6 3.5V2.5a1 1 0 011-1h2a1 1 0 011 1v1"/></svg> <span class="btn-label">Paste</span></button>
                <button id="pasteInPlaceBtn" title="Paste in Place (Ctrl+Shift+V)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3.5" width="10" height="11" rx="1"/><path d="M6 3.5V2.5a1 1 0 011-1h2a1 1 0 011 1v1"/><path d="M8 7v4m-2-2h4"/></svg> <span class="btn-label">Paste in Place</span></button>
            </div>
            <div class="tool-group">
                <button id="undoBtn" title="Undo (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 6l-3 3 3 3"/><path d="M1 9h9a4 4 0 010 8H6"/></svg> <span class="btn-label">Undo</span></button>
                <button id="redoBtn" title="Redo (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 6l3 3-3 3"/><path d="M15 9H6a4 4 0 000 8h4"/></svg> <span class="btn-label">Redo</span></button>
            </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
            <!-- Canvas area -->
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="onionCanvas" width="1920" height="1080"></canvas>
                    <canvas id="mainCanvas" width="1920" height="1080"></canvas>
                    <canvas id="gridCanvas" width="1920" height="1080"></canvas>
                    <canvas id="selectionCanvas" width="1920" height="1080"></canvas>
                    <div class="brush-cursor" id="brushCursor"></div>
                </div>
                <div class="magnifier-marquee" id="magnifierMarquee"></div>
            </div>
            <div class="zoom-controls" id="zoomControls">
                <button id="pillPanBtn" title="Pan / Hand (H)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5.5 8V3.5a1 1 0 012 0V7"/><path d="M7.5 7V2.5a1 1 0 012 0V7"/><path d="M9.5 7V3.5a1 1 0 012 0V7"/><path d="M11.5 5.5a1 1 0 012 0V10c0 2.5-2 4.5-4.5 4.5h-1C6 14.5 4 12.5 4 10V8.5"/><path d="M5.5 8c0 0-2-1-2.5-2s0-2 1-1.5l1.5 1"/></svg></button>
                <div class="pill-divider"></div>
                <button id="zoomOutBtn" title="Zoom Out (âˆ’)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M5 7h4"/><path d="M11 11l3.5 3.5"/></svg></button>
                <span id="zoomLevel" class="zoom-label">100%</span>
                <button id="zoomInBtn" title="Zoom In (+)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg></button>
                <button id="zoomFitBtn" title="Fit to Screen (0)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M2 6V2h4M10 2h4v4M14 10v4h-4M6 14H2v-4"/></svg></button>
                <div class="pill-divider"></div>
                <button id="pasteboardToggle" title="Show Pasteboard (\)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"><rect x="3.5" y="3.5" width="9" height="9" stroke-dasharray="2 1.5"/><rect x="1" y="1" width="14" height="14" rx="1" opacity="0.4"/></svg></button>
            </div>
        </div>

        <!-- Combined Timeline & Layers Panel -->
        <div class="timeline" id="timelinePanel">
            <div class="timeline-resize-handle" id="timelineResizeHandle"></div>
            <div class="timeline-header">
                <div class="timeline-controls">
                    <div class="playback-controls">
                        <div class="play-btn-group">
                            <button id="playBtn" title="Play (Space)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 2.5v11l9-5.5z" fill="currentColor" stroke="none"/></svg> <span class="btn-label">Play</span></button>
                            <button id="playModeBtn" class="play-mode-arrow" title="Play mode"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 6" width="8" height="6"><path d="M0 0l4 5 4-5z" fill="currentColor"/></svg></button>
                            <div class="play-mode-menu" id="playModeMenu">
                                <button class="play-mode-item active" data-mode="layer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="12" height="12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="5" width="12" height="4" rx="1"/></svg> Active Layer<span class="shortcut">Space</span></button>
                                <button class="play-mode-item" data-mode="timeline"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="12" height="12" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="2" width="12" height="3" rx="1"/><rect x="3" y="6" width="10" height="3" rx="1"/><rect x="1" y="10" width="8" height="3" rx="1"/></svg> Full Timeline<span class="shortcut">â‡§Space</span></button>
                            </div>
                        </div>
                        <button id="stopBtn" title="Stop (Space)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="10" height="10" rx="1" fill="currentColor" stroke="none"/></svg> <span class="btn-label">Stop</span></button>
                        <button id="firstFrame" title="First Frame (Shift+,)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><line x1="4" y1="3" x2="4" y2="13"/><path d="M12 3L7 8l5 5"/></svg></button>
                        <button id="prevFrame" title="Previous Frame (,)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M10 3L5 8l5 5"/></svg></button>
                        <button id="nextFrame" title="Next Frame (.)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M6 3l5 5-5 5"/></svg></button>
                        <button id="lastFrame" title="Last Frame (Shift+.)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M4 3l5 5-5 5"/><line x1="12" y1="3" x2="12" y2="13"/></svg></button>
                        <button id="insertFrame" title="Insert Frame (F7)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v10M3 8h10"/></svg> <span class="btn-label">Insert</span></button>
                        <button id="holdFrame" title="Hold Frame (F5)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="4" width="5" height="5" rx="0.5"/><rect x="10" y="4" width="5" height="5" rx="0.5"/><path d="M6 6.5h4"/></svg> <span class="btn-label">Hold</span></button>
                        <button id="duplicateFrame" title="Duplicate Frame (âŒ˜D / F6)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="1.5" y="4" width="8" height="8" rx="1"/><rect x="5.5" y="1" width="8" height="8" rx="1"/></svg> <span class="btn-label">Duplicate</span></button>
                        <button id="clearFrame" title="Clear Frame (Backspace)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="8" r="6"/><path d="M5.5 5.5l5 5M10.5 5.5l-5 5"/></svg> <span class="btn-label">Clear</span></button>
                        <button id="deleteFrame" title="Delete Frame (â‡§F5)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M2 4h12M6 4V2.5h4V4M5 4v9h6V4"/><path d="M7 7v3M9 7v3"/></svg> <span class="btn-label">Delete</span></button>
                    </div>
                    <div class="dropdown-container" style="position:relative; margin-left:auto;">
                        <button id="onionSkinToggle" title="Onion Skin (O)" style="background:none; border:none; color:#aab; cursor:pointer; padding:4px 6px; border-radius:4px; display:flex; align-items:center;" onmouseover="this.style.background='rgba(255,255,255,0.08)'" onmouseout="this.style.background='none'"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 16" width="22" height="15" fill="none" stroke="currentColor" stroke-width="1.2"><rect x="1" y="3" width="10" height="10" rx="1.5" opacity="0.35"/><rect x="7" y="1" width="10" height="10" rx="1.5" fill="currentColor" fill-opacity="0.15"/><rect x="13" y="3" width="10" height="10" rx="1.5" opacity="0.35"/></svg></button>
                        <div class="onion-skin-dropdown" id="onionSkinDropdown">
                            <div class="onion-row">
                                <span class="onion-row-label">Onion Skin</span>
                                <div class="onion-mini-toggle on" id="onionToggleSwitch"></div>
                            </div>
                            <div class="onion-row">
                                <div class="onion-row-label">
                                    <input type="color" class="onion-color-dot" id="onionPrevColor" value="#ff0000">
                                    <span>Before</span>
                                </div>
                                <div class="onion-inline-stepper">
                                    <button id="onionBeforeMinus">âˆ’</button>
                                    <span class="onion-stepper-val" id="onionBeforeVal">1</span>
                                    <button id="onionBeforePlus">+</button>
                                </div>
                            </div>
                            <div class="onion-row">
                                <div class="onion-row-label">
                                    <input type="color" class="onion-color-dot" id="onionNextColor" value="#00cc00">
                                    <span>After</span>
                                </div>
                                <div class="onion-inline-stepper">
                                    <button id="onionAfterMinus">âˆ’</button>
                                    <span class="onion-stepper-val" id="onionAfterVal">1</span>
                                    <button id="onionAfterPlus">+</button>
                                </div>
                            </div>
                            <div class="onion-opacity-row">
                                <span class="onion-opacity-label">Opacity</span>
                                <div class="onion-inline-stepper">
                                    <button id="onionOpacityMinus">âˆ’</button>
                                    <span class="onion-stepper-val-wide" id="onionOpacityValue">30%</span>
                                    <button id="onionOpacityPlus">+</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="fps-control" id="fpsControl">
                        <button class="fps-step-btn" id="fpsDown" title="Decrease FPS">âˆ’</button>
                        <div class="fps-badge" id="fpsBadge" title="Click to set FPS">
                            <span class="fps-badge-value" id="fpsBadgeValue">24</span>
                            <span class="fps-badge-label">fps</span>
                        </div>
                        <button class="fps-step-btn" id="fpsUp" title="Increase FPS">+</button>
                        <div class="fps-popover" id="fpsPopover">
                            <div class="fps-popover-title">Frame Rate</div>
                            <div class="fps-presets" id="fpsPresets">
                                <button class="fps-preset" data-fps="6">6</button>
                                <button class="fps-preset" data-fps="8">8</button>
                                <button class="fps-preset active" data-fps="12">12</button>
                                <button class="fps-preset" data-fps="15">15</button>
                                <button class="fps-preset" data-fps="24">24</button>
                                <button class="fps-preset" data-fps="25">25</button>
                                <button class="fps-preset" data-fps="30">30</button>
                                <button class="fps-preset" data-fps="60">60</button>
                            </div>
                            <div class="fps-custom-row">
                                <span class="fps-custom-label">Custom</span>
                                <input type="number" class="fps-custom-input" id="fpsCustomInput" min="1" max="120" value="24">
                            </div>
                        </div>
                    </div>
                    <div class="timeline-zoom-controls">
                        <button id="tlZoomOut" title="Timeline Zoom Out"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="9" height="9"><path d="M7 1L12 5.5V12H2V5.5Z" fill="currentColor"/></svg></button>
                        <button id="tlZoomFit" title="Fit All Frames"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="12" height="12" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M1.5 5V1.5H5M9 1.5h3.5V5M12.5 9v3.5H9M5 12.5H1.5V9"/></svg></button>
                        <button id="tlZoomIn" title="Timeline Zoom In"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="14" height="14"><path d="M7 1L12 5.5V12H2V5.5Z" fill="currentColor"/></svg></button>
                    </div>
                </div>
            </div>
            <div class="timeline-body">
                <div class="timeline-layers-section" id="layersSection">
                    <div class="layers-header">
                        <span>Layers</span>
                        <div class="layer-buttons">
                            <button class="add-layer-btn-inline" id="addLayerBtn" title="Add Layer (âŒ˜â‡§N)">+</button>
                            <button class="add-layer-btn-inline" id="duplicateLayerBtn" title="Duplicate Layer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="4" width="7" height="7" rx="1"/><rect x="5" y="1" width="7" height="7" rx="1"/></svg></button>
                            <button class="delete-layer-btn-inline" id="deleteLayerBtn" title="Delete Layer">-</button>
                        </div>
                    </div>
                    <div class="layers-list" id="layersList"></div>
                    <div class="layer-panel-resize-handle" id="layerPanelResizeHandle"></div>
                </div>
                <div class="timeline-right-column">
                    <div class="scrub-ruler" id="scrubRuler">
                        <div class="scrub-ruler-inner" id="scrubRulerInner"></div>
                    </div>
                    <div class="timeline-frames-section" id="timelineFramesSection">
                        <div class="frame-select-banner" id="frameSelectBanner">
                            <span id="frameSelectCount">Select frames</span>
                            <button class="done-btn" id="frameSelectDone">Done</button>
                        </div>
                        <div class="frames-container" id="framesContainer"></div>
                    </div>
                    <div class="curve-editor" id="curveEditor">
                        <div class="ce-toolbar">
                            <div class="ce-prop-tabs" id="cePropTabs"></div>
                            <div class="ce-presets" id="cePresets"></div>
                            <button class="ce-close-btn" id="ceCloseBtn">âœ• Close</button>
                        </div>
                        <div class="ce-canvas-wrap">
                            <canvas id="curveCanvas"></canvas>
                            <div class="ce-hint">Drag handles to shape easing â€¢ Double-click curve to reset segment</div>
                        </div>
                    </div>
                    <div class="timeline-playhead" id="timelinePlayhead">
                        <div class="playhead-handle"></div>
                    </div>
                </div>
            </div>
            <div class="audio-tracks-container" id="audioTracksContainer">
            </div>
        </div>
    </div>

    <!-- Frame context menu -->
    <input type="file" id="loadProjectInput" accept=".fby" style="display: none;">
    <input type="file" id="importSequenceInput" accept="image/png,image/jpeg,image/gif,image/webp,image/bmp,image/tiff" multiple style="display: none;">
    <input type="file" id="importAudioInput" accept="audio/*" style="display: none;">
    <div class="frame-context-menu" id="frameContextMenu">
        <button class="frame-context-menu-item" id="ctxCopyFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="5" y="1.5" width="8" height="10" rx="1"/><path d="M2 4v8a1 1 0 001 1h6"/></svg> Copy Frame<span class="shortcut">Ctrl+C</span></button>
        <button class="frame-context-menu-item" id="ctxPasteFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="3" y="3" width="9" height="10" rx="1"/><path d="M5.5 3V2a1 1 0 011-1h2a1 1 0 011 1v1"/></svg> Paste Frame<span class="shortcut">Ctrl+V</span></button>
        <div class="frame-context-menu-divider"></div>
        <button class="frame-context-menu-item" id="ctxDuplicateFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="4" width="7" height="7" rx="1"/><rect x="5" y="1" width="7" height="7" rx="1"/></svg> Duplicate Frame<span class="shortcut">Ctrl+D</span></button>
        <button class="frame-context-menu-item" id="ctxHoldFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="4" width="5" height="5" rx="0.5"/><rect x="10" y="4" width="5" height="5" rx="0.5"/><path d="M6 6.5h4"/></svg> Hold Frame</button>
        <div class="frame-context-menu-divider"></div>
        <button class="frame-context-menu-item" id="ctxReleaseHold"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="4" width="5" height="5" rx="0.5"/><rect x="10" y="4" width="5" height="5" rx="0.5"/><path d="M6 6.5h4" stroke-dasharray="2 2"/></svg> Release Hold</button>
    </div>

    <!-- Canvas Size Modal -->
    <div class="modal-overlay" id="canvasSizeModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>Canvas Size</h3>
                <button class="modal-close" id="canvasSizeClose">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label>Preset:</label>
                    <select id="canvasPreset">
                        <option value="custom">Custom</option>
                        <optgroup label="Landscape">
                            <option value="1920x1080">1920 Ã— 1080 (Full HD)</option>
                            <option value="1280x720">1280 Ã— 720 (HD)</option>
                            <option value="960x540">960 Ã— 540 (Default)</option>
                            <option value="3840x2160">3840 Ã— 2160 (4K)</option>
                            <option value="2048x1080">2048 Ã— 1080 (DCI 2K)</option>
                            <option value="4096x2160">4096 Ã— 2160 (DCI 4K)</option>
                        </optgroup>
                        <optgroup label="Square">
                            <option value="1080x1080">1080 Ã— 1080 (Instagram)</option>
                            <option value="512x512">512 Ã— 512</option>
                            <option value="1024x1024">1024 Ã— 1024</option>
                        </optgroup>
                        <optgroup label="Portrait">
                            <option value="1080x1920">1080 Ã— 1920 (Vertical HD)</option>
                            <option value="1080x1350">1080 Ã— 1350 (4:5)</option>
                        </optgroup>
                    </select>
                </div>
                <div class="modal-row modal-size-row">
                    <div class="modal-field">
                        <label for="canvasWidthInput">Width</label>
                        <div class="modal-input-wrap">
                            <input type="number" id="canvasWidthInput" min="1" max="7680" value="1920">
                            <span class="modal-unit">px</span>
                        </div>
                    </div>
                    <button class="modal-link-btn" id="canvasLinkBtn" title="Lock aspect ratio">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5 6V5a3 3 0 016 0v1"/><rect x="3" y="6" width="10" height="8" rx="1.5"/></svg>
                    </button>
                    <div class="modal-field">
                        <label for="canvasHeightInput">Height</label>
                        <div class="modal-input-wrap">
                            <input type="number" id="canvasHeightInput" min="1" max="7680" value="1080">
                            <span class="modal-unit">px</span>
                        </div>
                    </div>
                </div>
                <div class="modal-row">
                    <label>Resize mode:</label>
                    <select id="canvasResizeMode">
                        <option value="scale">Scale content to fit</option>
                        <option value="crop-center">Crop / Expand (Center)</option>
                        <option value="crop-tl">Crop / Expand (Top-Left)</option>
                    </select>
                </div>
                <div class="modal-row">
                    <label>Background:</label>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <input type="color" id="canvasBgColor" value="#ffffff" style="width:32px; height:32px; border-radius:50%; padding:0; border:none; cursor:pointer;">
                        <span id="canvasBgColorLabel" style="color:#aaa; font-size:12px;">#ffffff</span>
                    </div>
                </div>
                <div class="modal-info" id="canvasSizeInfo"></div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-cancel" id="canvasSizeCancel">Cancel</button>
                <button class="modal-btn modal-btn-apply" id="canvasSizeApply">Apply</button>
            </div>
        </div>
    </div>

    <script>
        // FrameBoy App
        class FrameBoy {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.onionCanvas = document.getElementById('onionCanvas');
                this.onionCtx = this.onionCanvas.getContext('2d');
                this.selectionCanvas = document.getElementById('selectionCanvas');
                this.selectionCtx = this.selectionCanvas.getContext('2d');
                this.gridCanvas = document.getElementById('gridCanvas');
                this.gridCtx = this.gridCanvas.getContext('2d');
                this.gridVisible = false;
                this.brushCursor = document.getElementById('brushCursor');
                
                this.layers = [{ id: 1, name: 'Layer 1', visible: true, opacity: 1.0, frames: [], transformKeyframes: [], startFrame: 0, parentId: null }];
                this.currentLayerId = 1;
                this.currentFrameIndex = 0;
                this.nextLayerId = 2;
                
                this.tool = 'brush';
                this.color = '#000000';
                this.colorB = '#ffffff';
                this.gradientType = 'linear'; // 'linear' or 'radial'
                this.gradientDef = null; // { type, colorA, colorB, x0, y0, x1, y1 } in frame-local coords
                this._gradientDrag = null; // Active drag state during gradient drawing
                this._gradientEdit = null; // Edit mode state: {startLocal, endLocal, originX, originY, dragging}
                this._gradientMaskCache = null; // Cached fill region mask for live preview
                this.brushSize = 8;
                this.brushShape = 'round';    // 'round', 'square', 'oval-h', 'oval-v'
                this.eraserShape = 'round';
                this.brushSmoothing = 80;      // 0-100
                this.smoothingMode = 'standard'; // 'standard' (EMA) or 'smooth' (post-stroke Chaikin)
                this.eraserSmoothing = 0;
                this.smoothPoints = [];       // Buffer for smoothing
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this._lastStrokeEnd = null; // For shift+click straight line
                this._shiftAnchor = null;      // Anchor point for shift-constrain mid-stroke
                this._shiftLockedAngle = null;  // Locked axis angle (null = not yet locked)
                this.onionSkinEnabled = true;
                this.onionSkinOpacity = 0.30;
                this.onionFramesBefore = 1;
                this.onionFramesAfter = 1;
                this.onionPrevColor = '#ff0000';
                this.onionNextColor = '#00cc00';
                this.isPlaying = false;
                this.playbackMode = 'layer'; // 'layer' or 'timeline'
                this.fps = 24;
                this.playbackInterval = null;
                
                // Zoom state
                this.zoomLevel = null; // null = fit-to-screen mode
                this.zoomSteps = [0.125, 0.167, 0.25, 0.333, 0.5, 0.667, 1, 1.5, 2, 3, 4, 6, 8, 12, 16];
                this.canvasWrapper = document.getElementById('canvasWrapper');
                this.canvasContainer = document.getElementById('canvasContainer');
                
                this.shapeStart = null;
                this._roundRectEdit = null; // {x1,y1,x2,y2,radius,maxRadius}
                
                // Pen tool state
                this._penPoints = [];
                this._penActive = false;
                this._penDragIdx = -1;
                this._penDragType = null;
                this._penMousePos = null;
                this._penShiftHeld = false;
                this._penLastPointTime = 0;
                this._penFinalizeTime = 0;
                
                // Create floating pen confirm/cancel buttons
                this._penConfirmBtns = document.createElement('div');
                this._penConfirmBtns.className = 'pen-confirm-btns';
                this._penConfirmBtns.innerHTML = `
                    <button class="pen-confirm-btn cancel" title="Cancel (Esc)">
                        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M3 3l8 8M11 3l-8 8"/></svg>
                    </button>
                    <button class="pen-confirm-btn confirm" title="Done (Enter)">
                        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M2 7l4 4 6-7"/></svg>
                    </button>
                `;
                this.canvasContainer.appendChild(this._penConfirmBtns);
                // Block touch events from reaching canvas underneath
                this._penConfirmBtns.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                this._penConfirmBtns.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                this._penConfirmBtns.querySelector('.cancel').addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this._penFinalizeTime = performance.now();
                    this._penCancel();
                });
                this._penConfirmBtns.querySelector('.confirm').addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this._penFinalizeTime = performance.now();
                    this._penFinalize(false);
                });
                
                // Gradient confirm/cancel floating buttons (same design as pen tool)
                this._gradConfirmBtns = document.createElement('div');
                this._gradConfirmBtns.className = 'pen-confirm-btns';
                this._gradConfirmBtns.innerHTML = `
                    <button class="pen-confirm-btn cancel" title="Cancel (Esc)">
                        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M3 3l8 8M11 3l-8 8"/></svg>
                    </button>
                    <button class="pen-confirm-btn confirm" title="Done (Enter)">
                        <svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M2 7l4 4 6-7"/></svg>
                    </button>
                `;
                this.canvasContainer.appendChild(this._gradConfirmBtns);
                this._gradConfirmBtns.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                this._gradConfirmBtns.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });
                this._gradConfirmBtns.querySelector('.cancel').addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this._cancelGradient();
                });
                this._gradConfirmBtns.querySelector('.confirm').addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this._finalizeGradient();
                });
                
                // Panning state
                this.isPanning = false;
                this._spaceHeld = false;
                this._panStart = null;
                this._scrollStart = null;
                this._toolBeforeSpace = null;
                this._spaceDidPan = false;
                this._layerNameClickId = null;
                this._layerNameClickTime = 0;
                
                // Viewport (infinite canvas) â€” position of the camera in world space
                this.viewportX = 0;
                this.viewportY = 0;
                this._savedViewport = null;
                
                // Project dimensions (the "camera frame" / export size)
                this.projectWidth = this.canvas.width;
                this.projectHeight = this.canvas.height;
                this.bgColor = '#ffffff'; // Canvas background color
                
                // Pasteboard: show content outside the camera frame
                this.pasteboardVisible = false;
                
                // Magnifier state
                this._magnifying = false;
                this._magStart = null;
                this._magAlt = false;
                this._magDidDrag = false;
                
                // Undo/Redo stacks
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistorySize = 30;
                
                // Drag and drop properties
                this.draggedFrameIndex = null;
                this.dropTargetIndex = null;
                this._layerDragId = null;
                this._layerDropTarget = null;
                this._layerDropPos = null;
                this._layerDragDidMove = false;
                this._layerDragStartY = 0;
                
                // Lasso and selection properties
                this.lassoPath = [];
                this.selection = null; // {imageData, bounds: {x, y, width, height}}
                this.isTransforming = false;
                this.isRotating = false;
                this.rotationMode = false; // Track if we're in rotation mode
                this.hoverHandle = null; // Track which handle is being hovered
                this.hoverTimer = null; // Timer for hover detection
                this.transformHandles = [];
                this.activeHandle = null;
                this.transformStart = null;
                this._activeTransformTool = 'transform'; // 'transform', 'scale', 'rotate'
                
                // Clipboard properties
                this.copiedSelection = null; // For selection copy/paste
                this.copiedFrame = null; // For frame copy/paste
                this.copiedFrames = []; // For multi-frame copy/paste
                this.selectedFrames = new Set(); // Multi-frame selection (indices)
                this.frameSelectMode = false; // Long-press selection mode (iPad)
                this._longPressTimer = null;
                this.contextMenuFrameIndex = null; // Track which frame was right-clicked
                this.selectionUndoStack = []; // Transform-level undo within floating selection
                this.selectionRedoStack = []; // Transform-level redo within floating selection
                
                // Apple Pencil / Pointer properties
                this.currentPressure = 0.5;
                this.pointerType = 'mouse'; // 'pen', 'touch', 'mouse'
                this.pressureEnabled = true;
                this.hasStylusInput = false; // True once we detect real pen/stylus pressure (for pressure detection)
                this.strokeStateSaved = false; // Track if we've saved undo state for current stroke
                this._pendingSaveTimer = null; // Track async saveState timer
                this._pendingSnapshot = null; // Pre-stroke snapshot for undo
                this.activePointerId = null; // Track which pointer is currently drawing
                
                // Audio system
                this.audioContext = null;
                this.audioTracks = [];  // [{ id, name, audioBuffer, base64, mimeType, volume, muted, waveformPeaks }]
                this._audioTrackIdCounter = 0;
                this._audioSourceNodes = []; // [{ trackId, source, gain }]
                this._scrubSource = null;
                this._scrubGain = null;
                this.audioLayerSelected = false;
                this.timelineScale = 0.5;
                document.documentElement.style.setProperty('--frame-w', Math.round(80 * 0.5) + 'px');
                this._openTransformLayers = new Set();
                this._copiedKeyframe = null; // clipboard for copy/paste keyframes
                this._timelineDirty = true; // flag to avoid unnecessary timeline DOM rebuilds
                this._prevSelectedFrames = new Set(); // track previous selection for diffing
                this._prevPlayhead = -1; // track previous playhead position
                this._prevLayerId = -1; // track previous active layer
                this._showAnchorIndicator = false;
                this._curveEditorActive = false;
                
                // Layer composite caches â€” avoid re-compositing unchanged layers during drawing
                this._belowCache = document.createElement('canvas');
                this._belowCtx = this._belowCache.getContext('2d');
                this._aboveCache = document.createElement('canvas');
                this._aboveCtx = this._aboveCache.getContext('2d');
                this._compositeCacheDirty = true;
                this._compositeCacheKey = null; // tracks what state the cache was built for
                this._compositeCacheVer = 0; // bumped on any non-active-layer change
                this._curveEditorProp = 'x';
                this._curveEditorLayerId = null;
                this._ceDragHandle = null; // null | 'cp1' | 'cp2'
                this._ceSegmentIndex = 0; // which keyframe segment to edit
                
                this.initializeFrame();
                this.setupEventListeners();
                this.updateUndoRedoButtons();
                this.applyZoom(); // Set initial fit-to-screen zoom
                this.render();
                
                // Set initial cursor for brush tool
                this.canvas.style.cursor = 'none';
                this.selectionCanvas.style.cursor = 'none';
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.applyZoom();
                    if (this.pasteboardVisible) this._centerScrollOnProject();
                    this.render();
                });
                
                // Mobile Safari viewport fix: track actual visible height
                // Safari's 100vh includes the area behind the URL bar
                const updateVH = () => {
                    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                    document.documentElement.style.setProperty('--app-height', vh + 'px');
                };
                updateVH();
                window.addEventListener('resize', updateVH);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', updateVH);
                }
                
                // Layer panel resize handle
                this.setupLayerPanelResize();
                this.setupTimelineResize();
            }
            
            setupLayerPanelResize() {
                const resizeHandle = document.getElementById('layerPanelResizeHandle');
                const layersSection = document.getElementById('layersSection');
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;
                
                const onPointerDown = (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = layersSection.offsetWidth;
                    e.preventDefault();
                    resizeHandle.setPointerCapture(e.pointerId);
                };
                
                const onPointerMove = (e) => {
                    if (!isResizing) return;
                    
                    const deltaX = e.clientX - startX;
                    const newWidth = Math.max(160, Math.min(400, startWidth + deltaX));
                    layersSection.style.width = newWidth + 'px';
                    if (this.audioTracks.length) this.syncAudioLabelWidth();
                };
                
                const onPointerUp = (e) => {
                    if (!isResizing) return;
                    isResizing = false;
                    resizeHandle.releasePointerCapture(e.pointerId);
                };
                
                resizeHandle.addEventListener('pointerdown', onPointerDown);
                resizeHandle.addEventListener('pointermove', onPointerMove);
                resizeHandle.addEventListener('pointerup', onPointerUp);
                resizeHandle.addEventListener('pointercancel', onPointerUp);
            }
            
            setupTimelineResize() {
                const handle = document.getElementById('timelineResizeHandle');
                const timeline = document.getElementById('timelinePanel');
                let startY = 0;
                let startH = 0;
                
                handle.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    handle.setPointerCapture(e.pointerId);
                    startY = e.clientY;
                    startH = timeline.offsetHeight;
                });
                
                handle.addEventListener('pointermove', (e) => {
                    if (!handle.hasPointerCapture(e.pointerId)) return;
                    const delta = startY - e.clientY; // drag up = bigger
                    const newH = Math.max(100, Math.min(window.innerHeight * 0.7, startH + delta));
                    timeline.style.height = newH + 'px';
                    timeline.style.minHeight = newH + 'px';
                    timeline.style.maxHeight = newH + 'px';
                });
                
                const onUp = (e) => {
                    if (handle.hasPointerCapture(e.pointerId)) {
                        handle.releasePointerCapture(e.pointerId);
                        // Refresh canvas zoom after resize
                        this.applyZoom();
                        this.render();
                    }
                };
                handle.addEventListener('pointerup', onUp);
                handle.addEventListener('pointercancel', onUp);
            }
            
            positionOnionCanvas() {
                // No-op â€” onion canvas positioning is handled by CSS (absolute, left:0, top:0)
                // and sizing is done by applyZoom() which is called explicitly on zoom changes.
            }
            
            // Mark a frame's thumbnail as stale so it gets re-rendered next timeline draw
            _dirtyThumb(frame) {
                if (frame) frame._thumbVer = (frame._thumbVer || 0) + 1;
            }
            
            getEffectiveZoom() {
                if (this.zoomLevel !== null) return this.zoomLevel;
                // Fit-to-screen: compute zoom that fits canvas in container with padding
                const container = this.canvasContainer;
                const padX = 20, padY = 20;
                const availW = container.clientWidth - padX;
                const availH = container.clientHeight - padY;
                if (availW <= 0 || availH <= 0) return 1;
                // When pasteboard is visible, zoom to fit the PROJECT area (not the entire pasteboard)
                const fitW = this.pasteboardVisible ? this.projectWidth : this.canvas.width;
                const fitH = this.pasteboardVisible ? this.projectHeight : this.canvas.height;
                const scaleW = availW / fitW;
                const scaleH = availH / fitH;
                return Math.min(scaleW, scaleH, 1); // Don't upscale past 100% in fit mode
            }
            
            applyZoom(centerOnPoint) {
                const zoom = this.getEffectiveZoom();
                const w = Math.round(this.canvas.width * zoom);
                const h = Math.round(this.canvas.height * zoom);
                const container = this.canvasContainer;
                const cw = container.clientWidth;
                const ch = container.clientHeight;
                
                // Set wrapper size
                this.canvasWrapper.style.width = w + 'px';
                this.canvasWrapper.style.height = h + 'px';
                
                // Center each axis independently:
                // If canvas fits on an axis â†’ center with margin
                // If canvas overflows on an axis â†’ use small padding, scroll handles centering
                const fitsH = w < cw;
                const fitsV = h < ch;
                const mx = fitsH ? Math.max(0, (cw - w) / 2) : 10;
                const my = fitsV ? Math.max(0, (ch - h) / 2) : 10;
                this.canvasWrapper.style.margin = my + 'px ' + mx + 'px';
                
                // Size all canvases to wrapper
                const canvases = [this.canvas, this.onionCanvas, this.selectionCanvas, this.gridCanvas];
                for (const c of canvases) {
                    c.style.width = w + 'px';
                    c.style.height = h + 'px';
                }
                
                // Position overlay canvases at 0,0 within wrapper
                this.onionCanvas.style.left = '0px';
                this.onionCanvas.style.top = '0px';
                this.selectionCanvas.style.left = '0px';
                this.selectionCanvas.style.top = '0px';
                this.gridCanvas.style.left = '0px';
                this.gridCanvas.style.top = '0px';
                
                // Update zoom label â€” show zoom relative to project, not pasteboard
                const pct = Math.round(zoom * 100);
                document.getElementById('zoomLevel').textContent = pct + '%';
            }
            
            setZoom(level, centerOnMouse) {
                // Clamp to step range
                const min = this.zoomSteps[0];
                const max = this.zoomSteps[this.zoomSteps.length - 1];
                this.zoomLevel = Math.max(min, Math.min(max, level));
                
                const container = this.canvasContainer;
                const cw = container.clientWidth;
                const ch = container.clientHeight;
                
                // Always center on the project/canvas center
                let targetX, targetY;
                if (this.pasteboardVisible) {
                    const pad = this.getPasteboardPadding();
                    targetX = pad + this.projectWidth / 2;
                    targetY = pad + this.projectHeight / 2;
                } else {
                    targetX = this.canvas.width / 2;
                    targetY = this.canvas.height / 2;
                }
                
                // Apply zoom â€” this updates wrapper size and margins
                this.applyZoom();
                
                const newZoom = this.getEffectiveZoom();
                const w = Math.round(this.canvas.width * newZoom);
                const h = Math.round(this.canvas.height * newZoom);
                
                // Read new margins from DOM
                const newStyle = window.getComputedStyle(this.canvasWrapper);
                const newML = parseFloat(newStyle.marginLeft) || 0;
                const newMT = parseFloat(newStyle.marginTop) || 0;
                
                // Only scroll axes that overflow â€” margins already center fitting axes
                if (w >= cw) {
                    container.scrollLeft = newML + targetX * newZoom - cw / 2;
                }
                if (h >= ch) {
                    container.scrollTop = newMT + targetY * newZoom - ch / 2;
                }
                
                this._prevZoom = newZoom;
                this.updateBrushCursor();
            }
            
            zoomIn() {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                // Find next step above current
                for (const step of this.zoomSteps) {
                    if (step > current + 0.001) {
                        this.setZoom(step);
                        return;
                    }
                }
            }
            
            zoomOut() {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                // Find next step below current
                for (let i = this.zoomSteps.length - 1; i >= 0; i--) {
                    if (this.zoomSteps[i] < current - 0.001) {
                        this.setZoom(this.zoomSteps[i]);
                        return;
                    }
                }
            }
            
            zoomFit() {
                this.zoomLevel = null; // Back to fit-to-screen
                this._prevZoom = null;
                this.applyZoom();
                // Reset scroll â€” margins handle centering for fitting content,
                // applyZoom handles pasteboard scroll centering
                if (!this.pasteboardVisible) {
                    this.canvasContainer.scrollLeft = 0;
                    this.canvasContainer.scrollTop = 0;
                }
                this.updateBrushCursor();
            }
            
            // === MAGNIFIER TOOL ===
            
            startMagnifier(clientX, clientY, altKey) {
                this._magnifying = true;
                this._magStart = { x: clientX, y: clientY };
                this._magAlt = altKey;
                this._magDidDrag = false;
                
                const marquee = document.getElementById('magnifierMarquee');
                marquee.style.display = 'none';
            }
            
            doMagnifier(clientX, clientY) {
                if (!this._magnifying || !this._magStart) return;
                
                const dx = clientX - this._magStart.x;
                const dy = clientY - this._magStart.y;
                
                // Only start marquee if dragged more than 4px (and zoom-in mode)
                if (Math.abs(dx) < 4 && Math.abs(dy) < 4) return;
                const isZoomOut = (this.tool === 'magnifier-out') !== (this._magAlt || false);
                if (isZoomOut) return; // No marquee for zoom-out
                
                this._magDidDrag = true;
                
                const container = this.canvasContainer;
                const containerRect = container.getBoundingClientRect();
                const marquee = document.getElementById('magnifierMarquee');
                
                // Compute marquee rect in container viewport coordinates
                const sx = this._magStart.x - containerRect.left + container.scrollLeft;
                const sy = this._magStart.y - containerRect.top + container.scrollTop;
                const ex = clientX - containerRect.left + container.scrollLeft;
                const ey = clientY - containerRect.top + container.scrollTop;
                
                const left = Math.min(sx, ex);
                const top = Math.min(sy, ey);
                const width = Math.abs(ex - sx);
                const height = Math.abs(ey - sy);
                
                marquee.style.display = 'block';
                marquee.style.left = left + 'px';
                marquee.style.top = top + 'px';
                marquee.style.width = width + 'px';
                marquee.style.height = height + 'px';
            }
            
            endMagnifier(clientX, clientY) {
                if (!this._magnifying) return;
                this._magnifying = false;
                
                const marquee = document.getElementById('magnifierMarquee');
                marquee.style.display = 'none';
                
                // Determine if this is a zoom-out action
                // Alt inverts: magnifier+alt=out, magnifier-out+alt=in
                const isZoomOut = (this.tool === 'magnifier-out') !== (this._magAlt || false);
                
                if (this._magDidDrag && !isZoomOut) {
                    // Marquee zoom: fit the selected area to the viewport
                    this._zoomToMarquee(this._magStart.x, this._magStart.y, clientX, clientY);
                } else {
                    // Single click zoom in or out
                    const container = this.canvasContainer;
                    const rect = this.canvas.getBoundingClientRect();
                    const oldZoom = this.getEffectiveZoom();
                    
                    const cx = clientX || this._magStart.x;
                    const cy = clientY || this._magStart.y;
                    
                    const canvasX = (cx - rect.left) / (rect.width / this.canvas.width);
                    const canvasY = (cy - rect.top) / (rect.height / this.canvas.height);
                    
                    const containerRect = container.getBoundingClientRect();
                    const viewX = cx - containerRect.left;
                    const viewY = cy - containerRect.top;
                    
                    if (isZoomOut) {
                        this.zoomOutAt(canvasX, canvasY, viewX, viewY, oldZoom);
                    } else {
                        this.zoomInAt(canvasX, canvasY, viewX, viewY, oldZoom);
                    }
                }
                
                this._magStart = null;
                this._magDidDrag = false;
            }
            
            _zoomToMarquee(startX, startY, endX, endY) {
                const rect = this.canvas.getBoundingClientRect();
                const container = this.canvasContainer;
                const containerRect = container.getBoundingClientRect();
                const currentZoom = this.getEffectiveZoom();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                // Convert screen coords to canvas coords
                const cx1 = (startX - rect.left) * scaleX;
                const cy1 = (startY - rect.top) * scaleY;
                const cx2 = (endX - rect.left) * scaleX;
                const cy2 = (endY - rect.top) * scaleY;
                
                const selLeft = Math.max(0, Math.min(cx1, cx2));
                const selTop = Math.max(0, Math.min(cy1, cy2));
                const selRight = Math.min(this.canvas.width, Math.max(cx1, cx2));
                const selBottom = Math.min(this.canvas.height, Math.max(cy1, cy2));
                const selW = selRight - selLeft;
                const selH = selBottom - selTop;
                
                if (selW < 2 || selH < 2) return; // Too small
                
                // Compute zoom to fit marquee area in viewport
                const viewW = container.clientWidth - 20;
                const viewH = container.clientHeight - 20;
                const fitZoom = Math.min(viewW / selW, viewH / selH);
                
                // Snap to nearest zoom step (round up to ensure area fits)
                const max = this.zoomSteps[this.zoomSteps.length - 1];
                const clampedZoom = Math.min(fitZoom, max);
                
                // Find best zoom step
                let bestStep = this.zoomSteps[0];
                for (const step of this.zoomSteps) {
                    if (step <= clampedZoom + 0.001) {
                        bestStep = step;
                    }
                }
                
                this._prevZoom = currentZoom;
                
                // Center of marquee in canvas coords
                const centerX = (selLeft + selRight) / 2;
                const centerY = (selTop + selBottom) / 2;
                
                // Apply zoom centered on the marquee center
                const viewCX = container.clientWidth / 2;
                const viewCY = container.clientHeight / 2;
                
                this._applyZoomAt(bestStep, centerX, centerY, viewCX, viewCY, currentZoom);
            }
            
            magnifierZoom(e) {
                // Legacy single-click path (kept for compatibility)
                const container = this.canvasContainer;
                const rect = this.canvas.getBoundingClientRect();
                const oldZoom = this.getEffectiveZoom();
                
                const canvasX = (e.clientX - rect.left) / (rect.width / this.canvas.width);
                const canvasY = (e.clientY - rect.top) / (rect.height / this.canvas.height);
                
                const containerRect = container.getBoundingClientRect();
                const viewX = e.clientX - containerRect.left;
                const viewY = e.clientY - containerRect.top;
                
                if (e.altKey) {
                    this.zoomOutAt(canvasX, canvasY, viewX, viewY, oldZoom);
                } else {
                    this.zoomInAt(canvasX, canvasY, viewX, viewY, oldZoom);
                }
            }
            
            zoomInAt(canvasX, canvasY, viewX, viewY, oldZoom) {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                let nextStep = null;
                for (const step of this.zoomSteps) {
                    if (step > current + 0.001) {
                        nextStep = step;
                        break;
                    }
                }
                if (nextStep === null) return; // Already at max
                this._applyZoomAt(nextStep, canvasX, canvasY, viewX, viewY, oldZoom);
            }
            
            zoomOutAt(canvasX, canvasY, viewX, viewY, oldZoom) {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                let nextStep = null;
                for (let i = this.zoomSteps.length - 1; i >= 0; i--) {
                    if (this.zoomSteps[i] < current - 0.001) {
                        nextStep = this.zoomSteps[i];
                        break;
                    }
                }
                if (nextStep === null) return; // Already at min
                this._applyZoomAt(nextStep, canvasX, canvasY, viewX, viewY, oldZoom);
            }
            
            _applyZoomAt(newZoomLevel, canvasX, canvasY, viewX, viewY, oldZoom) {
                const container = this.canvasContainer;
                const min = this.zoomSteps[0];
                const max = this.zoomSteps[this.zoomSteps.length - 1];
                this.zoomLevel = Math.max(min, Math.min(max, newZoomLevel));
                
                this.applyZoom();
                
                const newZoom = this.getEffectiveZoom();
                
                // Compute where the same canvas point now sits in scrollable space
                // Account for wrapper margin (centering)
                const wrapper = this.canvasWrapper;
                const style = window.getComputedStyle(wrapper);
                const marginLeft = parseFloat(style.marginLeft) || 0;
                const marginTop = parseFloat(style.marginTop) || 0;
                
                const pointInScrollX = marginLeft + canvasX * newZoom;
                const pointInScrollY = marginTop + canvasY * newZoom;
                
                // Scroll so that point is back under the cursor
                container.scrollLeft = pointInScrollX - viewX;
                container.scrollTop = pointInScrollY - viewY;
                
                this._prevZoom = newZoom;
                this.updateBrushCursor();
            }
            
            // === PANNING ===
            
            startPan(clientX, clientY) {
                this.isPanning = true;
                this._panStart = { x: clientX, y: clientY };
                this._scrollStart = {
                    x: this.canvasContainer.scrollLeft,
                    y: this.canvasContainer.scrollTop
                };
                this._panDidStart = false;
                this.canvas.style.cursor = 'grabbing';
                this.selectionCanvas.style.cursor = 'grabbing';
                this.canvasContainer.style.cursor = 'grabbing';
            }
            
            doPan(clientX, clientY) {
                if (!this.isPanning || !this._panStart) return;
                const dx = clientX - this._panStart.x;
                const dy = clientY - this._panStart.y;
                // Require minimum drag distance to prevent accidental pans (esp. iPad 2-finger)
                if (!this._panDidStart) {
                    if (Math.abs(dx) < 5 && Math.abs(dy) < 5) return;
                    this._panDidStart = true;
                }
                // Scroll the container (opposite direction of drag)
                this.canvasContainer.scrollLeft = this._scrollStart.x - dx;
                this.canvasContainer.scrollTop = this._scrollStart.y - dy;
            }
            
            stopPan() {
                this.isPanning = false;
                this._panStart = null;
                this._scrollStart = null;
                // Restore cursor by re-applying current tool's cursor
                if (this.tool === 'pan' || this._spaceHeld) {
                    this.canvas.style.cursor = 'grab';
                    this.selectionCanvas.style.cursor = 'grab';
                    this.canvasContainer.style.cursor = 'grab';
                } else {
                    // Re-apply current tool cursor
                    this.selectTool(this.tool);
                }
            }
            
            _isPanActive() {
                return this.tool === 'pan' || this._spaceHeld;
            }
            
            initializeFrame() {
                // Clear any gradient preview/edit state when changing frames
                if (this._gradientEdit) {
                    this._gradientEdit = null;
                    this._hideGradConfirmBtns();
                }
                if (this._gradientDrag) {
                    this._gradientDrag = null;
                    this.isDrawing = false;
                }
                this._gradientMaskCache = null;
                
                const layer = this.getCurrentLayer();
                if (!layer.frames[this.currentFrameIndex]) {
                    layer.frames[this.currentFrameIndex] = this.createEmptyFrame();
                }
            }
            
            createEmptyFrame() {
                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = this.projectWidth;
                frameCanvas.height = this.projectHeight;
                frameCanvas._originX = 0;
                frameCanvas._originY = 0;
                return frameCanvas;
            }
            
            // === Infinite Canvas Helpers ===
            
            // Convert screen mouse event to world coordinates
            screenToWorld(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX + this.viewportX,
                    y: (e.clientY - rect.top) * scaleY + this.viewportY
                };
            }
            
            // Convert world coords to frame-local coords
            worldToLocal(worldX, worldY, frame) {
                return {
                    x: worldX - (frame._originX || 0),
                    y: worldY - (frame._originY || 0)
                };
            }
            
            // Get the offset to translate frame-local coords to display canvas coords
            frameToDisplayOffset(frame) {
                return {
                    x: (frame._originX || 0) - this.viewportX,
                    y: (frame._originY || 0) - this.viewportY
                };
            }
            
            // Get the display offset for the current frame (used by selection/transform system)
            getSelectionDisplayOffset() {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (!frame) return { x: -this.viewportX, y: -this.viewportY };
                return {
                    x: (frame._originX || 0) - this.viewportX,
                    y: (frame._originY || 0) - this.viewportY
                };
            }
            
            // Auto-expand a frame canvas to cover a world-space point
            // Returns {dx, dy} â€” the shift applied to frame-local coords (growLeft, growTop)
            ensureFrameCovers(frame, worldX, worldY) {
                const margin = 256; // Expand in chunks to avoid per-pixel growth
                const ox = frame._originX || 0;
                const oy = frame._originY || 0;
                const localX = worldX - ox;
                const localY = worldY - oy;
                
                let growLeft = 0, growTop = 0, growRight = 0, growBottom = 0;
                
                if (localX < 0) growLeft = Math.ceil((-localX + margin) / margin) * margin;
                if (localY < 0) growTop = Math.ceil((-localY + margin) / margin) * margin;
                if (localX >= frame.width) growRight = Math.ceil((localX - frame.width + 1 + margin) / margin) * margin;
                if (localY >= frame.height) growBottom = Math.ceil((localY - frame.height + 1 + margin) / margin) * margin;
                
                if (growLeft === 0 && growTop === 0 && growRight === 0 && growBottom === 0) return { dx: 0, dy: 0 };
                
                const newWidth = growLeft + frame.width + growRight;
                const newHeight = growTop + frame.height + growBottom;
                
                // Copy content to expanded canvas
                const temp = document.createElement('canvas');
                temp.width = newWidth;
                temp.height = newHeight;
                temp.getContext('2d').drawImage(frame, growLeft, growTop);
                
                // Resize in-place
                frame.width = newWidth;
                frame.height = newHeight;
                frame.getContext('2d').drawImage(temp, 0, 0);
                
                // Shift origin
                frame._originX = ox - growLeft;
                frame._originY = oy - growTop;
                
                return { dx: growLeft, dy: growTop };
            }
            
            togglePasteboard() {
                this.pasteboardVisible = !this.pasteboardVisible;
                this.updatePasteboard();
                // Update toggle button state
                const btn = document.getElementById('pasteboardToggle');
                if (btn) {
                    btn.classList.toggle('pill-active', this.pasteboardVisible);
                    btn.title = this.pasteboardVisible ? 'Hide Pasteboard (\\)' : 'Show Pasteboard (\\)';
                }
            }
            
            getPasteboardPadding() {
                // Padding on each side â€” 50% of the project's largest dimension
                return Math.round(Math.max(this.projectWidth, this.projectHeight) * 0.75);
            }
            
            updatePasteboard() {
                if (this.pasteboardVisible) {
                    const pad = this.getPasteboardPadding();
                    const newW = this.projectWidth + pad * 2;
                    const newH = this.projectHeight + pad * 2;
                    
                    // Expand canvas
                    this.canvas.width = newW;
                    this.canvas.height = newH;
                    this.selectionCanvas.width = newW;
                    this.selectionCanvas.height = newH;
                    this.onionCanvas.width = newW;
                    this.onionCanvas.height = newH;
                    this.gridCanvas.width = newW;
                    this.gridCanvas.height = newH;
                    
                    // Set viewport so project area is centered in the canvas
                    this.viewportX = -pad;
                    this.viewportY = -pad;
                } else {
                    // Restore canvas to project dimensions
                    this.canvas.width = this.projectWidth;
                    this.canvas.height = this.projectHeight;
                    this.selectionCanvas.width = this.projectWidth;
                    this.selectionCanvas.height = this.projectHeight;
                    this.onionCanvas.width = this.projectWidth;
                    this.onionCanvas.height = this.projectHeight;
                    this.gridCanvas.width = this.projectWidth;
                    this.gridCanvas.height = this.projectHeight;
                    
                    this.viewportX = 0;
                    this.viewportY = 0;
                }
                
                // Reset zoom to fit
                this.zoomLevel = null;
                this.applyZoom();
                
                // Center scroll on project area when pasteboard is active
                if (this.pasteboardVisible) {
                    this._centerScrollOnProject();
                } else {
                    this.canvasContainer.scrollLeft = 0;
                    this.canvasContainer.scrollTop = 0;
                }
                
                this.render();
                this.drawGrid();
            }
            
            _centerScrollOnProject() {
                const container = this.canvasContainer;
                const zoom = this.getEffectiveZoom();
                const pad = this.getPasteboardPadding();
                const w = Math.round(this.canvas.width * zoom);
                const h = Math.round(this.canvas.height * zoom);
                const cw = container.clientWidth;
                const ch = container.clientHeight;
                
                // Read actual margins from DOM
                const style = window.getComputedStyle(this.canvasWrapper);
                const mx = parseFloat(style.marginLeft) || 0;
                const my = parseFloat(style.marginTop) || 0;
                
                const projCenterX = (pad + this.projectWidth / 2) * zoom;
                const projCenterY = (pad + this.projectHeight / 2) * zoom;
                
                if (w >= cw) container.scrollLeft = Math.max(0, projCenterX + mx - cw / 2);
                if (h >= ch) container.scrollTop = Math.max(0, projCenterY + my - ch / 2);
            }
            
            // Draw darkened pasteboard overlay outside the project area
            drawPasteboardOverlay(ctx) {
                if (!this.pasteboardVisible) return;
                
                // Project rect in canvas coords
                const px = -this.viewportX;
                const py = -this.viewportY;
                const pw = this.projectWidth;
                const ph = this.projectHeight;
                const cw = this.canvas.width;
                const ch = this.canvas.height;
                
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
                
                // Top strip
                if (py > 0) ctx.fillRect(0, 0, cw, py);
                // Bottom strip
                if (py + ph < ch) ctx.fillRect(0, py + ph, cw, ch - py - ph);
                // Left strip (between top and bottom)
                if (px > 0) ctx.fillRect(0, py, px, ph);
                // Right strip (between top and bottom)
                if (px + pw < cw) ctx.fillRect(px + pw, py, cw - px - pw, ph);
                
                // Project boundary
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                ctx.lineWidth = 1;
                ctx.strokeRect(px + 0.5, py + 0.5, pw - 1, ph - 1);
                
                ctx.restore();
            }
            
            resizeCanvas(newW, newH, mode) {
                const oldW = this.projectWidth;
                const oldH = this.projectHeight;
                if (newW === oldW && newH === oldH) return;
                
                this.commitSelection();
                this.hideTransformHandles();
                
                // Resize every frame in every layer (preserving hold frame relationships)
                for (const layer of this.layers) {
                    const resizedMap = new Map(); // old canvas -> new canvas for hold frames
                    for (let i = 0; i < layer.frames.length; i++) {
                        const oldFrame = layer.frames[i];
                        if (!oldFrame) continue;
                        
                        // If this canvas was already resized (hold frame), reuse the new one
                        if (resizedMap.has(oldFrame)) {
                            layer.frames[i] = resizedMap.get(oldFrame);
                            continue;
                        }
                        
                        const newFrame = document.createElement('canvas');
                        newFrame.width = newW;
                        newFrame.height = newH;
                        newFrame._originX = 0;
                        newFrame._originY = 0;
                        const ctx = newFrame.getContext('2d');
                        
                        if (mode === 'scale') {
                            ctx.drawImage(oldFrame, 0, 0, newW, newH);
                        } else if (mode === 'crop-center') {
                            const ox = Math.round((newW - oldW) / 2);
                            const oy = Math.round((newH - oldH) / 2);
                            ctx.drawImage(oldFrame, ox, oy);
                        } else {
                            ctx.drawImage(oldFrame, 0, 0);
                        }
                        
                        resizedMap.set(oldFrame, newFrame);
                        layer.frames[i] = newFrame;
                    }
                }
                
                // Update project dimensions
                this.projectWidth = newW;
                this.projectHeight = newH;
                
                // Reset viewport and apply pasteboard if active
                this.viewportX = 0;
                this.viewportY = 0;
                
                if (this.pasteboardVisible) {
                    this.updatePasteboard();
                } else {
                    this.canvas.width = newW;
                    this.canvas.height = newH;
                    this.onionCanvas.width = newW;
                    this.onionCanvas.height = newH;
                    this.selectionCanvas.width = newW;
                    this.selectionCanvas.height = newH;
                    this.gridCanvas.width = newW;
                    this.gridCanvas.height = newH;
                    
                    this.zoomLevel = null;
                    this.applyZoom();
                    this.render();
                    this.drawGrid();
                    this.canvasContainer.scrollLeft = 0;
                    this.canvasContainer.scrollTop = 0;
                }
                
                // Reset undo (frames have changed structure)
                this.undoStack = [];
                this.redoStack = [];
                this.selectionUndoStack = [];
                this.selectionRedoStack = [];
                this.updateUndoRedoButtons();
                
                this.positionOnionCanvas();
                this.render();
            }
            
            getCurrentLayer() {
                return this.layers.find(l => l.id === this.currentLayerId);
            }
            
            // NLE helpers: timeline position â†” local frame index
            getPlayheadPosition() {
                // During timeline playback, use the raw timeline position
                if (this.isPlaying && this._activePlayMode === 'timeline' && this._playbackTimelinePos !== undefined) {
                    return this._playbackTimelinePos;
                }
                const layer = this.getCurrentLayer();
                return this.currentFrameIndex + (layer ? (layer.startFrame || 0) : 0);
            }
            
            getTimelineLength() {
                let maxEnd = 1;
                for (const layer of this.layers) {
                    maxEnd = Math.max(maxEnd, (layer.startFrame || 0) + layer.frames.length);
                }
                // Include audio track ends (for ruler/UI width only)
                for (const track of this.audioTracks) {
                    const audioFrames = Math.ceil(track.audioBuffer.duration * this.fps);
                    maxEnd = Math.max(maxEnd, (track.startFrame || 0) + audioFrames);
                }
                return maxEnd;
            }
            
            // Length based on drawing layers only â€” used for playback duration
            getDrawingTimelineLength() {
                let maxEnd = 1;
                for (const layer of this.layers) {
                    maxEnd = Math.max(maxEnd, (layer.startFrame || 0) + layer.frames.length);
                }
                return maxEnd;
            }
            
            // Get the frame canvas for a layer at a given timeline position
            getFrameAtPosition(layer, timelinePos) {
                const localIdx = timelinePos - (layer.startFrame || 0);
                if (localIdx < 0 || localIdx >= layer.frames.length) return null;
                return layer.frames[localIdx];
            }
            
            setupEventListeners() {
                // === DUAL EVENT SYSTEM ===
                // Desktop: Pointer events â†’ e.pressure (Wacom, Surface Pen)
                // iPad:    Touch events â†’ touch.force (Apple Pencil, fast!)
                // Touch preventDefault() on iPad blocks pointer events, preventing duplicates.
                
                const setupCanvasEvents = (canvasEl) => {
                    
                    // --- POINTER EVENTS (Desktop: Wacom, Surface Pen, Mouse) ---
                    // On iPad these get blocked by touch preventDefault()
                    
                    canvasEl.addEventListener('pointerdown', (e) => {
                        // If in rounded rect radius edit mode, click finalizes
                        if (this._roundRectEdit) {
                            e.preventDefault();
                            this._finalizeRoundRect();
                            return;
                        }
                        // Clear frame multi-selection when interacting with canvas
                        if (this.selectedFrames.size > 0) {
                            this.selectedFrames.clear();
                            this._timelineDirty = true;
                            this._scheduleRenderTimeline();
                        }
                        // Middle mouse button always pans
                        if (e.button === 1) {
                            e.preventDefault();
                            this.startPan(e.clientX, e.clientY);
                            return;
                        }
                        // Pan tool or space held â€” pan instead of draw
                        if (this._isPanActive()) {
                            e.preventDefault();
                            this.startPan(e.clientX, e.clientY);
                            this._spaceDidPan = true;
                            return;
                        }
                        // Magnifier tool â€” start marquee or click zoom
                        if (this.tool === 'magnifier' || this.tool === 'magnifier-out') {
                            e.preventDefault();
                            this.startMagnifier(e.clientX, e.clientY, e.altKey);
                            return;
                        }
                        this.pointerType = e.pointerType;
                        if (e.pointerType === 'pen') {
                            this.hasStylusInput = true;
                            this.currentPressure = e.pressure > 0 ? e.pressure : 0.5;
                        } else if (e.pointerType === 'mouse') {
                            this.currentPressure = 0.5;
                        }
                        // Capture pointer so events continue when pen/mouse leaves canvas edge
                        try { canvasEl.setPointerCapture(e.pointerId); } catch(_) {}
                        this._capturedPointerId = e.pointerId;
                        this._capturedCanvas = canvasEl;
                        this.startDrawing(e);
                    });
                    
                    canvasEl.addEventListener('pointermove', (e) => {
                        // Rounded rect radius edit mode
                        if (this._roundRectEdit) {
                            e.preventDefault();
                            this._roundRectHandleMouseMove(e);
                            return;
                        }
                        if (this.isPanning) {
                            e.preventDefault();
                            this.doPan(e.clientX, e.clientY);
                            return;
                        }
                        if (this._magnifying) {
                            e.preventDefault();
                            this.doMagnifier(e.clientX, e.clientY);
                            return;
                        }
                        
                        // Use coalesced events for brush/eraser â€” captures all
                        // intermediate pen positions between frames (120-240Hz on stylus)
                        if (this.isDrawing && (this.tool === 'brush' || this.tool === 'eraser') && e.getCoalescedEvents) {
                            const coalesced = e.getCoalescedEvents();
                            if (coalesced.length > 1) {
                                for (const ce of coalesced) {
                                    if (ce.pointerType === 'pen' && ce.pressure > 0) {
                                        this.currentPressure = ce.pressure;
                                    }
                                    this.draw(ce);
                                }
                                return;
                            }
                        }
                        
                        if (e.pointerType === 'pen' && e.pressure > 0) {
                            this.currentPressure = e.pressure;
                        }
                        this.draw(e);
                    });
                    
                    canvasEl.addEventListener('pointerup', (e) => {
                        // Release pointer capture
                        if (this._capturedCanvas && this._capturedPointerId !== undefined) {
                            try { this._capturedCanvas.releasePointerCapture(this._capturedPointerId); } catch(_) {}
                            this._capturedPointerId = undefined;
                            this._capturedCanvas = null;
                        }
                        if (this.isPanning) {
                            this.stopPan();
                            return;
                        }
                        if (this._magnifying) {
                            this.endMagnifier(e.clientX, e.clientY);
                            return;
                        }
                        this.stopDrawing();
                    });
                    
                    canvasEl.addEventListener('pointercancel', (e) => {
                        // Release pointer capture
                        if (this._capturedCanvas && this._capturedPointerId !== undefined) {
                            try { this._capturedCanvas.releasePointerCapture(this._capturedPointerId); } catch(_) {}
                            this._capturedPointerId = undefined;
                            this._capturedCanvas = null;
                        }
                        if (this.isPanning) {
                            this.stopPan();
                            return;
                        }
                        if (this._magnifying) {
                            this._magnifying = false;
                            this._magStart = null;
                            document.getElementById('magnifierMarquee').style.display = 'none';
                            return;
                        }
                        this.stopDrawing();
                    });
                    
                    // --- TOUCH EVENTS (iPad: Apple Pencil + Finger) ---
                    // These fire FIRST on iPad. preventDefault() blocks pointer events.
                    // Result: iPad uses fast touch path, desktop uses pointer path.
                    
                    canvasEl.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Block pointer events on iPad!
                        
                        // If in rounded rect radius edit mode, touch finalizes
                        if (this._roundRectEdit && e.touches.length === 1) {
                            this._finalizeRoundRect();
                            return;
                        }
                        
                        // Two-finger touch = always pan
                        if (e.touches.length === 2) {
                            const mid = {
                                x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                                y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                            };
                            this.startPan(mid.x, mid.y);
                            this._touchPanFingers = 2;
                            return;
                        }
                        
                        const touch = e.touches[0];
                        if (!touch) return;
                        
                        // Pan tool active â€” pan with single finger
                        if (this._isPanActive()) {
                            this.startPan(touch.clientX, touch.clientY);
                            this._spaceDidPan = true;
                            return;
                        }
                        
                        // Magnifier tool â€” start marquee or click zoom at touch point
                        if (this.tool === 'magnifier' || this.tool === 'magnifier-out') {
                            this.startMagnifier(touch.clientX, touch.clientY, false);
                            return;
                        }
                        
                        if (touch.touchType === 'stylus') {
                            this.hasStylusInput = true;
                            this.pointerType = 'pen';
                            this.currentPressure = touch.force > 0 ? touch.force : 0.5;
                        } else {
                            // Palm rejection: once Apple Pencil is detected, ignore
                            // finger/knuckle touches for drawing (still works for pan/zoom above)
                            if (this.hasStylusInput) return;
                            this.pointerType = 'touch';
                            this.currentPressure = 0.5;
                        }
                        
                        this.startDrawing({
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: canvasEl
                        });
                    }, { passive: false });
                    
                    canvasEl.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        
                        // Two-finger pan
                        if (this.isPanning && e.touches.length >= 2) {
                            const mid = {
                                x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                                y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                            };
                            this.doPan(mid.x, mid.y);
                            return;
                        }
                        
                        // Single-finger pan (pan tool)
                        if (this.isPanning) {
                            const touch = e.touches[0];
                            if (touch) this.doPan(touch.clientX, touch.clientY);
                            return;
                        }
                        
                        // Magnifier marquee drag
                        if (this._magnifying) {
                            const touch = e.touches[0];
                            if (touch) this.doMagnifier(touch.clientX, touch.clientY);
                            return;
                        }
                        
                        // Rounded rect radius edit mode
                        if (this._roundRectEdit) {
                            const touch = e.touches[0];
                            if (touch) this._roundRectHandleMouseMove(touch);
                            return;
                        }
                        
                        if (!this.isDrawing && !this.isTransforming) return;
                        const touch = e.touches[0];
                        if (!touch) return;
                        
                        if (touch.touchType === 'stylus' && touch.force > 0) {
                            this.currentPressure = touch.force;
                        }
                        
                        this.draw({
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: canvasEl
                        });
                    }, { passive: false });
                    
                    canvasEl.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        if (this.isPanning) {
                            // If went from 2 fingers to 1, stay panning only if pan tool
                            if (e.touches.length === 0 || !this._isPanActive()) {
                                this.stopPan();
                                this._touchPanFingers = 0;
                            }
                            return;
                        }
                        if (this._magnifying) {
                            const ct = e.changedTouches[0];
                            this.endMagnifier(ct ? ct.clientX : null, ct ? ct.clientY : null);
                            return;
                        }
                        this.stopDrawing();
                    }, { passive: false });
                    
                    canvasEl.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        if (this.isPanning) {
                            this.stopPan();
                            this._touchPanFingers = 0;
                            return;
                        }
                        this.stopDrawing();
                    }, { passive: false });
                };
                
                setupCanvasEvents(this.canvas);
                setupCanvasEvents(this.selectionCanvas);
                
                // Dismiss active free transform when clicking outside the canvas
                // (e.g. timeline, layers panel, etc. â€” but not toolbar buttons/dropdowns)
                document.addEventListener('pointerdown', (e) => {
                    if (!this.selection) return;
                    const isTransformTool = this.tool === 'transform' || this.tool === 'scale' || 
                                           this.tool === 'rotate' || this.tool === 'skew' || this.tool === 'distort';
                    if (!isTransformTool) return;
                    // If click is on canvas or selection canvas, startDrawing handles it
                    if (e.target === this.canvas || e.target === this.selectionCanvas) return;
                    // Don't dismiss when interacting with toolbar or dropdowns
                    if (e.target && e.target.closest && e.target.closest('.toolbar, .dropdown-menu, .dropdown-container')) return;
                    this._dismissTransform();
                });
                
                // Document-level fallbacks â€” catch stylus lift outside canvas
                // Continue drawing off-canvas so strokes extend to edge seamlessly
                document.addEventListener('pointermove', (e) => {
                    if (this.isDrawing && (this.tool === 'brush' || this.tool === 'eraser')) {
                        const target = e.target;
                        if (target !== this.canvas && target !== this.selectionCanvas) {
                            this.draw({ clientX: e.clientX, clientY: e.clientY, target: this.canvas });
                        }
                    }
                }, true);
                // Pointer path (desktop off-canvas lift)
                document.addEventListener('pointerup', (e) => {
                    if (this.isPanning) { this.stopPan(); return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                });
                document.addEventListener('pointercancel', (e) => {
                    if (this.isPanning) { this.stopPan(); return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                });
                // Touch path (iPad off-canvas lift)
                document.addEventListener('touchend', (e) => {
                    if (this.isPanning) { this.stopPan(); this._touchPanFingers = 0; return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                }, { passive: true });
                document.addEventListener('touchcancel', (e) => {
                    if (this.isPanning) { this.stopPan(); this._touchPanFingers = 0; return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                }, { passive: true });

                // Prevent iOS double-tap text selection menu and context menu
                const preventIOSMenus = (canvasEl) => {
                    canvasEl.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // Pen tool: double-click finalizes open path
                        // But suppress if a point was just placed (e.g. fast Apple Pencil taps)
                        if (this.tool === 'pen' && this._penActive) {
                            const timeSinceLastPoint = performance.now() - (this._penLastPointTime || 0);
                            if (timeSinceLastPoint > 400) {
                                this._penFinalize(false);
                            }
                        }
                    });
                    
                    canvasEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    // Prevent text selection that happens during fast drawing
                    canvasEl.addEventListener('selectstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    // Prevent long-press context menu on iOS
                    let longPressTimer = null;
                    canvasEl.addEventListener('touchstart', (e) => {
                        longPressTimer = setTimeout(() => {
                            // Cancel any context menu attempt
                            longPressTimer = null;
                        }, 500);
                    }, { passive: true });
                    
                    canvasEl.addEventListener('touchend', () => {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }, { passive: true });
                    
                    canvasEl.addEventListener('touchmove', () => {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }, { passive: true });
                };
                
                preventIOSMenus(this.canvas);
                preventIOSMenus(this.selectionCanvas);
                
                // Also prevent on canvas container
                const canvasArea = document.querySelector('.canvas-container');
                if (canvasArea) {
                    canvasArea.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    canvasArea.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                }
                
                // Tool selection
                const brushBtn = document.getElementById('brushTool');
                const brushDropdown = document.getElementById('brushDropdown');
                const eraserBtn = document.getElementById('eraserTool');
                const eraserDropdown = document.getElementById('eraserDropdown');
                
                // Central helper to close every dropdown/panel
                const _closeAllDropdowns = (except) => {
                    const ids = ['shapeDropdown', 'onionSkinDropdown', 'brushDropdown', 'eraserDropdown', 'fileMenuDropdown', 'navToolDropdown', 'transformToolDropdown', 'fillToolDropdown', 'playModeMenu', 'fpsPopover'];
                    for (const id of ids) {
                        if (id === except) continue;
                        const el = document.getElementById(id);
                        if (el) el.classList.remove('show');
                    }
                    // Also close any open submenus
                    document.querySelectorAll('.dropdown-submenu-container.touch-open').forEach(c => c.classList.remove('touch-open'));
                };
                
                brushBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectTool('brush');
                    _closeAllDropdowns('brushDropdown');
                    brushDropdown.classList.toggle('show');
                    // Sync smoothing mode toggle to current state
                    if (brushDropdown.classList.contains('show')) {
                        document.getElementById('smoothingModeToggle').querySelectorAll('.smt-btn').forEach(b => {
                            b.classList.toggle('active', b.dataset.mode === this.smoothingMode);
                        });
                    }
                });
                
                eraserBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectTool('eraser');
                    _closeAllDropdowns('eraserDropdown');
                    eraserDropdown.classList.toggle('show');
                });
                
                // Prevent dropdown clicks from propagating
                brushDropdown.addEventListener('click', (e) => e.stopPropagation());
                eraserDropdown.addEventListener('click', (e) => e.stopPropagation());
                
                // Brush dropdown controls
                document.getElementById('brushShapePicker').querySelectorAll('.shape-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.brushShape = icon.dataset.shape;
                        document.getElementById('brushShapePicker').querySelectorAll('.shape-icon').forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        this.updateBrushCursor();
                    });
                });
                document.getElementById('brushDiameter').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushDiameterValue').textContent = this.brushSize;
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.updateBrushCursor();
                });
                document.getElementById('brushSmoothing').addEventListener('input', (e) => {
                    this.brushSmoothing = parseInt(e.target.value);
                    document.getElementById('brushSmoothingValue').textContent = e.target.value + '%';
                });
                
                // Smoothing mode toggle
                document.getElementById('smoothingModeToggle').querySelectorAll('.smt-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.smoothingMode = btn.dataset.mode;
                        document.getElementById('smoothingModeToggle').querySelectorAll('.smt-btn').forEach(b => {
                            b.classList.toggle('active', b === btn);
                        });
                    });
                });
                
                // Pressure toggle â€” keep brush and eraser toggles + toolbar toggle synced
                const brushPressureToggle = document.getElementById('pressureEnabled');
                const eraserPressureToggle = document.getElementById('eraserPressureEnabled');
                const pressureToggleBtn = document.getElementById('pressureToggle');
                
                const syncPressure = (enabled) => {
                    this.pressureEnabled = enabled;
                    brushPressureToggle.className = 'onion-mini-toggle ' + (enabled ? 'on' : 'off');
                    eraserPressureToggle.className = 'onion-mini-toggle ' + (enabled ? 'on' : 'off');
                    pressureToggleBtn.classList.toggle('active', enabled);
                };
                
                brushPressureToggle.addEventListener('click', () => syncPressure(!this.pressureEnabled));
                eraserPressureToggle.addEventListener('click', () => syncPressure(!this.pressureEnabled));
                pressureToggleBtn.addEventListener('click', () => syncPressure(!this.pressureEnabled));
                
                // Eraser dropdown controls
                document.getElementById('eraserShapePicker').querySelectorAll('.shape-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.eraserShape = icon.dataset.shape;
                        document.getElementById('eraserShapePicker').querySelectorAll('.shape-icon').forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        this.updateBrushCursor();
                    });
                });
                document.getElementById('eraserDiameter').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('eraserDiameterValue').textContent = this.brushSize;
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.updateBrushCursor();
                });
                document.getElementById('eraserSmoothing').addEventListener('input', (e) => {
                    this.eraserSmoothing = parseInt(e.target.value);
                    document.getElementById('eraserSmoothingValue').textContent = e.target.value + '%';
                });

                this._activeFillTool = 'fill';
                document.getElementById('fillTool').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.tool === 'fill' || this.tool === 'gradient' || this.tool === 'eyedropper') {
                        // Already on a fill sub-tool â€” toggle dropdown to switch
                        _closeAllDropdowns('fillToolDropdown');
                        document.getElementById('fillToolDropdown').classList.toggle('show');
                    } else {
                        // Activate paint bucket directly
                        _closeAllDropdowns();
                        this.selectTool('fill');
                    }
                });
                
                // Fill/Eyedropper tool selection
                const fillDropdown = document.getElementById('fillToolDropdown');
                const fillButton = document.getElementById('fillTool');
                const fillIcons = {
                    'fill': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="16" height="16"><path d="M8 2C8 2 3 7.5 3 10.5a5 5 0 0010 0C13 7.5 8 2 8 2z" fill="currentColor"/></svg>',
                    'gradient': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="16" height="16"><rect x="2" y="2" width="12" height="12" rx="1.5"/><line x1="5" y1="14" x2="14" y2="5" stroke-opacity="0.4"/><line x1="2" y1="14" x2="14" y2="2" stroke-opacity="0.6"/><line x1="2" y1="11" x2="11" y2="2" stroke-opacity="0.4"/></svg>',
                    'eyedropper': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="16" height="16"><path d="M13.5 2.5a1.4 1.4 0 00-2 0L10 4l-1-.5-5 5-.5 3.5 3.5-.5 5-5L11.5 6l1.5-1.5a1.4 1.4 0 000-2z"/><path d="M3.5 12l.5.5"/></svg>'
                };
                const fillNames = { 'fill': 'Fill', 'gradient': 'Gradient', 'eyedropper': 'Eyedropper' };
                fillDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const ft = item.getAttribute('data-filltool');
                        this._activeFillTool = ft;
                        this.selectTool(ft);
                        fillDropdown.classList.remove('show');
                    });
                });
                document.getElementById('lassoTool').addEventListener('click', () => { _closeAllDropdowns(); this.selectTool('lasso'); });
                // Transform tool dropdown
                const xformButton = document.getElementById('transformTool');
                const xformDropdown = document.getElementById('transformToolDropdown');
                
                xformButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate' || this.tool === 'skew' || this.tool === 'distort') {
                        _closeAllDropdowns('transformToolDropdown');
                        xformDropdown.classList.toggle('show');
                    } else {
                        _closeAllDropdowns();
                        this.selectTool(this._activeTransformTool);
                    }
                });
                
                xformDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const xformtool = item.getAttribute('data-xformtool');
                        this._activeTransformTool = xformtool;
                        this.selectTool(xformtool);
                        xformDropdown.classList.remove('show');
                        this._updateTransformButton(xformtool);
                    });
                });
                
                // Navigation tool (Magnifier / Pan) dropdown
                const navButton = document.getElementById('navTool');
                const navDropdown = document.getElementById('navToolDropdown');
                this._activeNavTool = 'magnifier'; // Track which sub-tool is primary
                
                navButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.tool === 'magnifier' || this.tool === 'magnifier-out' || this.tool === 'pan') {
                        _closeAllDropdowns('navToolDropdown');
                        navDropdown.classList.toggle('show');
                    } else {
                        _closeAllDropdowns();
                        this.selectTool(this._activeNavTool);
                    }
                });
                
                navDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const navtool = item.getAttribute('data-navtool');
                        this._activeNavTool = navtool;
                        this.selectTool(navtool);
                        navDropdown.classList.remove('show');
                        this._updateNavButton(navtool);
                    });
                });
                
                // Brush cursor tracking
                const canvasContainer = document.getElementById('canvasContainer');
                canvasContainer.addEventListener('pointermove', (e) => {
                    if (this.tool === 'brush' || this.tool === 'eraser') {
                        this.brushCursor.style.display = 'block';
                        this.brushCursor.style.left = e.clientX + 'px';
                        this.brushCursor.style.top = e.clientY + 'px';
                        this.updateBrushCursor();
                    }
                });
                canvasContainer.addEventListener('pointerleave', () => {
                    this.brushCursor.style.display = 'none';
                });
                
                // Shapes dropdown
                const shapeButton = document.getElementById('shapeTool');
                const shapeDropdown = document.getElementById('shapeDropdown');
                
                shapeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    _closeAllDropdowns('shapeDropdown');
                    shapeDropdown.classList.toggle('show');
                });
                
                // Close all dropdowns when clicking/tapping outside toolbar dropdown areas
                document.addEventListener('pointerdown', (e) => {
                    if (!e.target || !e.target.closest) return;
                    // Don't close if interacting with dropdown content or toolbar/playback controls
                    if (e.target.closest('.dropdown-menu, .dropdown-submenu, .brush-dropdown, .onion-skin-dropdown, .play-mode-menu, .fps-popover, .fps-control, .toolbar, .playback-controls')) return;
                    _closeAllDropdowns();
                });
                
                // Shape selection
                shapeDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const shape = item.getAttribute('data-shape');
                        this.selectTool(shape);
                        shapeDropdown.classList.remove('show');
                        
                        // Update button text to show selected shape
                        const icons = {
                            'pen': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M2 13C5 9 7 5 14 3"/><circle cx="2" cy="13" r="1.5" fill="currentColor" stroke="none"/><circle cx="14" cy="3" r="1.5" fill="currentColor" stroke="none"/></svg>',
                            'rect': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="10" height="8" rx="0.5"/></svg>',
                            'roundrect': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="10" height="8" rx="2.5"/></svg>',
                            'circle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7.5" r="5"/></svg>',
                            'triangle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M7 2l6 11H1z"/></svg>'
                        };
                        const names = { 'pen': 'Pen', 'rect': 'Rect', 'roundrect': 'Round Rect', 'circle': 'Circle', 'triangle': 'Triangle' };
                        shapeButton.innerHTML = `${icons[shape]} <span class="btn-label">${names[shape]} â–¼</span>`;
                    });
                });
                
                // Color and size
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.color = e.target.value;
                    if (this.tool === 'gradient') this._updateGradientSwatch();
                    this._refreshGradientEdit();
                });
                
                document.getElementById('colorPickerB').addEventListener('change', (e) => {
                    this.colorB = e.target.value;
                    if (this.tool === 'gradient') this._updateGradientSwatch();
                    this._refreshGradientEdit();
                });
                
                document.getElementById('swapColorsBtn').addEventListener('click', () => {
                    const tmp = this.color;
                    this.color = this.colorB;
                    this.colorB = tmp;
                    document.getElementById('colorPicker').value = this.color;
                    document.getElementById('colorPickerB').value = this.colorB;
                    if (this.tool === 'gradient') this._updateGradientSwatch();
                    this._refreshGradientEdit();
                });
                
                document.getElementById('swatchClear').addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Clear stored gradient def
                    this.gradientDef = null;
                    this._syncGradientUI();
                });
                
                document.getElementById('gradientSwatch').addEventListener('click', (e) => {
                    if (e.target.id === 'swatchClear') return; // handled above
                    // Clicking swatch itself: if not on gradient tool, switch to it
                    if (this.tool !== 'gradient' && this.gradientDef) {
                        this.selectTool('gradient');
                    }
                });
                
                document.getElementById('gradientTypeToggle').addEventListener('click', (e) => {
                    const btn = e.target.closest('.grad-type-btn');
                    if (!btn) return;
                    this.gradientType = btn.dataset.gradtype;
                    document.querySelectorAll('.grad-type-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this._updateGradientSwatch();
                    this._refreshGradientEdit();
                });
                
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.syncBrushSizeUI();
                    this.updateBrushCursor();
                });
                
                const stepBrushSize = (delta) => {
                    this.brushSize = Math.max(1, Math.min(100, this.brushSize + delta));
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.syncBrushSizeUI();
                    this.updateBrushCursor();
                };
                document.getElementById('brushSizeMinus').addEventListener('click', () => stepBrushSize(-1));
                document.getElementById('brushSizePlus').addEventListener('click', () => stepBrushSize(1));
                
                // Frame controls
                document.getElementById('clearFrame').addEventListener('click', () => this.clearCurrentFrame());
                
                // Onion skin dropdown
                const onionBtn = document.getElementById('onionSkinToggle');
                const onionDropdown = document.getElementById('onionSkinDropdown');
                onionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    _closeAllDropdowns('onionSkinDropdown');
                    onionDropdown.classList.toggle('show');
                });
                onionDropdown.addEventListener('click', (e) => e.stopPropagation());
                
                // Onion skin toggle switch
                const onionToggle = document.getElementById('onionToggleSwitch');
                const updateOnionToggle = () => {
                    onionToggle.className = 'onion-mini-toggle ' + (this.onionSkinEnabled ? 'on' : 'off');
                    onionBtn.style.opacity = this.onionSkinEnabled ? '1' : '0.5';
                };
                onionToggle.addEventListener('click', () => {
                    this.onionSkinEnabled = !this.onionSkinEnabled;
                    updateOnionToggle();
                    this.render();
                });
                
                // Before frames stepper
                const beforeVal = document.getElementById('onionBeforeVal');
                document.getElementById('onionBeforeMinus').addEventListener('click', () => {
                    this.onionFramesBefore = Math.max(0, this.onionFramesBefore - 1);
                    beforeVal.textContent = this.onionFramesBefore;
                    this.render();
                });
                document.getElementById('onionBeforePlus').addEventListener('click', () => {
                    this.onionFramesBefore = Math.min(10, this.onionFramesBefore + 1);
                    beforeVal.textContent = this.onionFramesBefore;
                    this.render();
                });
                
                // After frames stepper
                const afterVal = document.getElementById('onionAfterVal');
                document.getElementById('onionAfterMinus').addEventListener('click', () => {
                    this.onionFramesAfter = Math.max(0, this.onionFramesAfter - 1);
                    afterVal.textContent = this.onionFramesAfter;
                    this.render();
                });
                document.getElementById('onionAfterPlus').addEventListener('click', () => {
                    this.onionFramesAfter = Math.min(10, this.onionFramesAfter + 1);
                    afterVal.textContent = this.onionFramesAfter;
                    this.render();
                });
                
                // Opacity stepper (+/- by 5%)
                const opacityVal = document.getElementById('onionOpacityValue');
                document.getElementById('onionOpacityMinus').addEventListener('click', () => {
                    const cur = Math.round(this.onionSkinOpacity * 100);
                    const next = Math.max(5, cur - 5);
                    this.onionSkinOpacity = next / 100;
                    opacityVal.textContent = next + '%';
                    this.render();
                });
                document.getElementById('onionOpacityPlus').addEventListener('click', () => {
                    const cur = Math.round(this.onionSkinOpacity * 100);
                    const next = Math.min(80, cur + 5);
                    this.onionSkinOpacity = next / 100;
                    opacityVal.textContent = next + '%';
                    this.render();
                });
                
                // Color pickers
                document.getElementById('onionPrevColor').addEventListener('input', (e) => {
                    this.onionPrevColor = e.target.value;
                    this.render();
                });
                document.getElementById('onionNextColor').addEventListener('input', (e) => {
                    this.onionNextColor = e.target.value;
                    this.render();
                });
                
                // Copy/Paste buttons
                document.getElementById('copyBtn').addEventListener('click', () => {
                    if (this.selection) {
                        this.copySelection();
                    } else {
                        this.copyFrame();
                        if (this.frameSelectMode) {
                            this.frameSelectMode = false;
                            document.getElementById('frameSelectBanner').classList.remove('show');
                            this._timelineDirty = true;
                            this.renderTimeline();
                        }
                    }
                });
                document.getElementById('pasteBtn').addEventListener('click', () => {
                    if (this.copiedSelection) {
                        this.pasteSelection();
                    } else if (this.copiedFrame || this.copiedFrames.length > 0) {
                        this.pasteFrame();
                    }
                });
                document.getElementById('pasteInPlaceBtn').addEventListener('click', () => {
                    if (this.copiedSelection) {
                        this.pasteSelectionInPlace();
                    }
                });
                
                // Undo/Redo controls
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                
                // Zoom controls
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomFitBtn').addEventListener('click', () => this.zoomFit());
                
                // Pasteboard toggle button
                document.getElementById('pasteboardToggle').addEventListener('click', () => this.togglePasteboard());
                document.getElementById('gridToggleBtn').addEventListener('click', () => {
                    this.toggleGrid();
                    document.getElementById('fileMenuDropdown').classList.remove('show');
                });
                
                // Pill pan button
                document.getElementById('pillPanBtn').addEventListener('click', () => {
                    if (this.tool === 'pan') {
                        this.selectTool('brush');
                    } else {
                        this.selectTool('pan');
                    }
                });
                
                // Ctrl/Cmd+Scroll wheel zoom (on canvas container only)
                this.canvasContainer.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.deltaY < 0) this.zoomIn();
                        else if (e.deltaY > 0) this.zoomOut();
                    }
                }, { passive: false });
                
                // Prevent middle-click auto-scroll on container
                this.canvasContainer.addEventListener('mousedown', (e) => {
                    if (e.button === 1) e.preventDefault();
                });
                
                // Keyboard shortcuts for undo/redo
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift') {
                        if (this.isDrawing && (this.tool === 'brush' || this.tool === 'eraser') && !this._shiftAnchor) {
                            this._shiftAnchor = { x: this.lastX, y: this.lastY };
                            this._shiftLockedAngle = null;
                        }
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        this.saveProject();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                        e.preventDefault();
                        document.getElementById('loadProjectInput').click();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        this.redo();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        if (this.selection) {
                            this.copySelection();
                        } else {
                            this.copyFrame();
                            if (this.frameSelectMode) {
                                this.frameSelectMode = false;
                                document.getElementById('frameSelectBanner').classList.remove('show');
                                this._timelineDirty = true;
                                this.renderTimeline();
                            }
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'v' || e.key === 'V')) {
                        e.preventDefault();
                        if (this.copiedSelection) {
                            this.pasteSelectionInPlace();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                        e.preventDefault();
                        if (this.copiedSelection) {
                            this.pasteSelection();
                        } else if (this.copiedFrame || this.copiedFrames.length > 0) {
                            this.pasteFrame();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'n' || e.key === 'N')) {
                        e.preventDefault();
                        this.addLayer();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        this.duplicateFrame();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                        e.preventDefault();
                        this.selectTool('transform');
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === '=' || e.key === '+')) {
                        e.preventDefault();
                        this.zoomIn();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                        e.preventDefault();
                        this.zoomOut();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                        e.preventDefault();
                        this.zoomFit();
                    } else if (e.key === 'Escape' && this.frameSelectMode) {
                        e.preventDefault();
                        this.exitFrameSelectMode();
                    } else if (e.key === 'Enter' && this._roundRectEdit) {
                        e.preventDefault();
                        this._finalizeRoundRect();
                    } else if (e.key === 'Escape' && this._roundRectEdit) {
                        e.preventDefault();
                        this._cancelRoundRect();
                    } else if (e.key === 'Enter' && this._gradientEdit) {
                        e.preventDefault();
                        this._finalizeGradient();
                    } else if (e.key === 'Escape' && this._gradientEdit) {
                        e.preventDefault();
                        this._cancelGradient();
                    } else if (e.key === 'Enter' && this._penActive) {
                        e.preventDefault();
                        this._penFinalize(false);
                    } else if (e.key === 'Escape' && this._penActive) {
                        e.preventDefault();
                        this._penCancel();
                    } else if (e.key === 'Enter' && this.selection) {
                        e.preventDefault();
                        this._dismissTransform();
                    } else if (e.key === 'Escape' && this.selection) {
                        e.preventDefault();
                        this.clearSelection();
                        this.selectTool('brush');
                        this.render();
                    } else if ((e.key === 'Delete' || e.key === 'Backspace') && this.selection) {
                        e.preventDefault();
                        this.clearSelection();
                        this.render();
                    } else if (this.selection && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                        e.preventDefault();
                        const step = e.shiftKey ? 10 : 1;
                        let dx = 0, dy = 0;
                        if (e.key === 'ArrowUp') dy = -step;
                        else if (e.key === 'ArrowDown') dy = step;
                        else if (e.key === 'ArrowLeft') dx = -step;
                        else if (e.key === 'ArrowRight') dx = step;
                        this.selection.bounds.x += dx;
                        this.selection.bounds.y += dy;
                        if (this.selection.anchorX != null) {
                            this.selection.anchorX += dx;
                            this.selection.anchorY += dy;
                        }
                        if (this.selection.corners) {
                            for (const c of this.selection.corners) {
                                c.x += dx;
                                c.y += dy;
                            }
                        }
                        this.showTransformHandles();
                        this.renderCanvasOnly();
                    }
                    
                    // Single-key shortcuts (only when no modifier keys held, no modal open, no input focused)
                    const activeEl = document.activeElement;
                    const inputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'SELECT' || activeEl.tagName === 'TEXTAREA');
                    const modalOpen = document.querySelector('.modal-overlay.show');
                    if (!e.ctrlKey && !e.metaKey && !e.altKey && !inputFocused && !modalOpen) {
                        switch (e.key) {
                            case 'b':
                                e.preventDefault();
                                this.selectTool('brush');
                                break;
                            case 'e':
                                e.preventDefault();
                                this.selectTool('eraser');
                                break;
                            case 'f':
                            case 'k':
                                e.preventDefault();
                                this.selectTool('fill');
                                break;
                            case 'g':
                                e.preventDefault();
                                this.selectTool('gradient');
                                break;
                            case 'G':
                                e.preventDefault();
                                this.toggleGrid();
                                break;
                            case 'x':
                                e.preventDefault();
                                document.getElementById('swapColorsBtn').click();
                                break;
                            case 'i':
                                e.preventDefault();
                                this.selectTool('eyedropper');
                                break;
                            case 'l':
                                e.preventDefault();
                                this.selectTool('lasso');
                                break;
                            case 'p':
                                e.preventDefault();
                                this.selectTool('pen');
                                break;
                            case 'v':
                            case 't':
                                e.preventDefault();
                                this._activeTransformTool = 'transform';
                                this._updateTransformButton('transform');
                                this.selectTool('transform');
                                break;
                            case 's':
                                e.preventDefault();
                                this._activeTransformTool = 'scale';
                                this._updateTransformButton('scale');
                                this.selectTool('scale');
                                break;
                            case 'r':
                                e.preventDefault();
                                this._activeTransformTool = 'rotate';
                                this._updateTransformButton('rotate');
                                this.selectTool('rotate');
                                break;
                            case 'h':
                                e.preventDefault();
                                this._activeNavTool = 'pan';
                                this._updateNavButton('pan');
                                this.selectTool('pan');
                                break;
                            case 'Home':
                                e.preventDefault();
                                this.zoomLevel = null;
                                this.applyZoom();
                                // Reset scroll to origin (centering handled by margins)
                                this.canvasContainer.scrollLeft = 0;
                                this.canvasContainer.scrollTop = 0;
                                this.render();
                                break;
                            case '\\':
                                e.preventDefault();
                                this.togglePasteboard();
                                break;
                            case 'z':
                                e.preventDefault();
                                this._activeNavTool = 'magnifier';
                                this._updateNavButton('magnifier');
                                this.selectTool('magnifier');
                                break;
                            case '[':
                                e.preventDefault();
                                this.brushSize = Math.max(1, this.brushSize - 1);
                                document.getElementById('brushSize').value = this.brushSize;
                                document.getElementById('sizeValue').textContent = this.brushSize;
                                this.syncBrushSizeUI();
                                this.updateBrushCursor();
                                break;
                            case ']':
                                e.preventDefault();
                                this.brushSize = Math.min(100, this.brushSize + 1);
                                document.getElementById('brushSize').value = this.brushSize;
                                document.getElementById('sizeValue').textContent = this.brushSize;
                                this.syncBrushSizeUI();
                                this.updateBrushCursor();
                                break;
                            case 'F5':
                                if (e.shiftKey) {
                                    e.preventDefault();
                                    this.deleteCurrentFrame();
                                } else {
                                    e.preventDefault();
                                    this.holdFrame();
                                }
                                break;
                            case 'F6':
                                e.preventDefault();
                                this.duplicateFrame();
                                break;
                            case 'F7':
                                e.preventDefault();
                                this.insertFrameAfterCurrent();
                                break;
                            case 'Backspace':
                                if (!this.selection) {
                                    e.preventDefault();
                                    this.clearCurrentFrame();
                                }
                                break;
                            case ' ':
                                e.preventDefault();
                                // Space hold = temporary pan mode
                                if (!this._spaceHeld) {
                                    this._spaceHeld = true;
                                    this._spaceDidPan = false;
                                    this._spaceShift = e.shiftKey;
                                    this._toolBeforeSpace = this.tool;
                                    this.canvas.style.cursor = 'grab';
                                    this.selectionCanvas.style.cursor = 'grab';
                                    this.canvasContainer.style.cursor = 'grab';
                                    this.brushCursor.style.display = 'none';
                                }
                                break;
                            case ',':
                                e.preventDefault();
                                this.previousFrame();
                                break;
                            case '.':
                                e.preventDefault();
                                this.goToNextFrame();
                                break;
                            case '<':
                                e.preventDefault();
                                this.goToFirstFrame();
                                break;
                            case '>':
                                e.preventDefault();
                                this.goToLastFrame();
                                break;
                            case 'o':
                                e.preventDefault();
                                this.onionSkinEnabled = !this.onionSkinEnabled;
                                const ot = document.getElementById('onionToggleSwitch');
                                if (ot) ot.className = 'onion-mini-toggle ' + (this.onionSkinEnabled ? 'on' : 'off');
                                document.getElementById('onionSkinToggle').style.opacity = this.onionSkinEnabled ? '1' : '0.5';
                                this.render();
                                break;
                            case '=':
                            case '+':
                                e.preventDefault();
                                this.zoomIn();
                                break;
                            case '-':
                                e.preventDefault();
                                this.zoomOut();
                                break;
                            case '0':
                                e.preventDefault();
                                this.zoomFit();
                                break;
                        }
                    }
                });
                
                // Space keyup: if no drag happened, toggle play/stop. Restore previous tool.
                document.addEventListener('keyup', (e) => {
                    if (e.key === ' ' && this._spaceHeld) {
                        e.preventDefault();
                        this._spaceHeld = false;
                        if (this.isPanning) {
                            this.stopPan();
                        }
                        // If user didn't drag at all, treat as play/stop toggle
                        if (!this._spaceDidPan) {
                            if (this.isPlaying) {
                                this.stop();
                            } else if (this._spaceShift) {
                                this.play('timeline');
                            } else {
                                this.play();
                            }
                        }
                        this._spaceDidPan = false;
                        this._spaceShift = false;
                        // Restore cursor to previous tool
                        if (this._toolBeforeSpace && this.tool !== 'pan') {
                            this.selectTool(this._toolBeforeSpace);
                        } else if (this.tool !== 'pan') {
                            this.selectTool(this.tool);
                        }
                        this._toolBeforeSpace = null;
                    }
                    // Alt release: restore magnifier cursor
                    if (e.key === 'Alt' && (this.tool === 'magnifier' || this.tool === 'magnifier-out')) {
                        const cur = this.tool === 'magnifier' ? 'zoom-in' : 'zoom-out';
                        this.canvas.style.cursor = cur;
                        this.selectionCanvas.style.cursor = cur;
                    }
                    if (e.key === 'Shift') {
                        this._shiftAnchor = null;
                        this._shiftLockedAngle = null;
                    }
                });
                
                // Alt key toggles magnifier between zoom-in and zoom-out cursor
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Alt' && (this.tool === 'magnifier' || this.tool === 'magnifier-out')) {
                        e.preventDefault();
                        const cur = this.tool === 'magnifier' ? 'zoom-out' : 'zoom-in';
                        this.canvas.style.cursor = cur;
                        this.selectionCanvas.style.cursor = cur;
                    }
                }, true);
                
                // Playback controls
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                
                // Play mode dropdown
                const playModeBtn = document.getElementById('playModeBtn');
                const playModeMenu = document.getElementById('playModeMenu');
                playModeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    _closeAllDropdowns('playModeMenu');
                    playModeMenu.classList.toggle('show');
                });
                playModeMenu.querySelectorAll('.play-mode-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.playbackMode = item.dataset.mode;
                        playModeMenu.querySelectorAll('.play-mode-item').forEach(el => el.classList.remove('active'));
                        item.classList.add('active');
                        playModeMenu.classList.remove('show');
                        // Update play button tooltip
                        document.getElementById('playBtn').title = this.playbackMode === 'timeline' 
                            ? 'Play Full Timeline (Space)' : 'Play Active Layer (Space)';
                    });
                });
                document.addEventListener('pointerdown', (e) => {
                    if (!playModeMenu.contains(e.target) && e.target !== playModeBtn) {
                        playModeMenu.classList.remove('show');
                    }
                });
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('firstFrame').addEventListener('click', () => this.goToFirstFrame());
                document.getElementById('prevFrame').addEventListener('click', () => this.previousFrame());
                document.getElementById('nextFrame').addEventListener('click', () => this.nextFrame());
                document.getElementById('lastFrame').addEventListener('click', () => this.goToLastFrame());
                document.getElementById('insertFrame').addEventListener('click', () => this.insertFrameAfterCurrent());
                document.getElementById('holdFrame').addEventListener('click', () => this.holdFrame());
                // Hold button: press and hold to keep adding hold frames
                const holdBtn = document.getElementById('holdFrame');
                holdBtn.addEventListener('pointerdown', (e) => {
                    if (e.button && e.button !== 0) return;
                    this._holdRepeatTimer = setTimeout(() => {
                        this._holdRepeatInterval = setInterval(() => {
                            this.holdFrame();
                        }, 120);
                    }, 300); // initial delay before repeating
                });
                const stopHoldRepeat = () => {
                    if (this._holdRepeatTimer) { clearTimeout(this._holdRepeatTimer); this._holdRepeatTimer = null; }
                    if (this._holdRepeatInterval) { clearInterval(this._holdRepeatInterval); this._holdRepeatInterval = null; }
                };
                holdBtn.addEventListener('pointerup', stopHoldRepeat);
                holdBtn.addEventListener('pointercancel', stopHoldRepeat);
                holdBtn.addEventListener('pointerleave', stopHoldRepeat);
                document.getElementById('duplicateFrame').addEventListener('click', () => this.duplicateFrame());
                document.getElementById('deleteFrame').addEventListener('click', () => this.deleteCurrentFrame());
                document.getElementById('frameSelectDone').addEventListener('click', () => this.exitFrameSelectMode());
                // FPS badge, stepper, and popover
                const fpsBadgeValue = document.getElementById('fpsBadgeValue');
                const fpsPopover = document.getElementById('fpsPopover');
                const fpsCustomInput = document.getElementById('fpsCustomInput');
                const fpsPresets = document.getElementById('fpsPresets');
                
                const setFps = (val) => {
                    val = Math.max(1, Math.min(120, Math.round(val)));
                    this.fps = val;
                    fpsBadgeValue.textContent = val;
                    fpsCustomInput.value = val;
                    // Update active preset
                    fpsPresets.querySelectorAll('.fps-preset').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.fps) === val);
                    });
                    if (this.audioTracks.length) this.renderAudioWaveform();
                };
                
                document.getElementById('fpsDown').addEventListener('click', (e) => {
                    e.stopPropagation();
                    setFps(this.fps - 1);
                });
                document.getElementById('fpsUp').addEventListener('click', (e) => {
                    e.stopPropagation();
                    setFps(this.fps + 1);
                });
                
                document.getElementById('fpsBadge').addEventListener('click', (e) => {
                    e.stopPropagation();
                    _closeAllDropdowns('fpsPopover');
                    fpsPopover.classList.toggle('show');
                    if (fpsPopover.classList.contains('show')) {
                        fpsCustomInput.value = this.fps;
                    }
                });
                
                fpsPopover.addEventListener('click', (e) => e.stopPropagation());
                
                fpsPresets.querySelectorAll('.fps-preset').forEach(btn => {
                    btn.addEventListener('click', () => {
                        setFps(parseInt(btn.dataset.fps));
                        fpsPopover.classList.remove('show');
                    });
                });
                
                fpsCustomInput.addEventListener('change', (e) => {
                    setFps(parseInt(e.target.value) || 12);
                });
                fpsCustomInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        setFps(parseInt(e.target.value) || 12);
                        fpsPopover.classList.remove('show');
                    }
                });
                
                // Timeline zoom controls
                document.getElementById('tlZoomIn').addEventListener('click', () => this.timelineZoomIn());
                document.getElementById('tlZoomOut').addEventListener('click', () => this.timelineZoomOut());
                document.getElementById('tlZoomFit').addEventListener('click', () => this.timelineZoomFit());
                
                // Frame context menu
                const ctxMenu = document.getElementById('frameContextMenu');
                document.getElementById('ctxCopyFrame').addEventListener('click', () => {
                    this.copyFrame(this.contextMenuFrameIndex);
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxPasteFrame').addEventListener('click', () => {
                    if (this.copiedFrame || this.copiedFrames.length > 0) {
                        this.pasteFrame(this.contextMenuFrameIndex);
                    }
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxDuplicateFrame').addEventListener('click', () => {
                    this.duplicateFrame(this.contextMenuFrameIndex);
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxHoldFrame').addEventListener('click', () => {
                    // Navigate to context menu frame first, then hold
                    this.currentFrameIndex = this.contextMenuFrameIndex;
                    this.holdFrame();
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxReleaseHold').addEventListener('click', () => {
                    this.currentFrameIndex = this.contextMenuFrameIndex;
                    this.initializeFrame();
                    this.releaseHoldFrame();
                    ctxMenu.classList.remove('show');
                });
                
                // Close context menu on click outside
                document.addEventListener('click', () => {
                    ctxMenu.classList.remove('show');
                });
                
                // Layer controls
                document.getElementById('addLayerBtn').addEventListener('click', () => this.addLayer());
                document.getElementById('duplicateLayerBtn').addEventListener('click', () => this.duplicateLayer());
                document.getElementById('deleteLayerBtn').addEventListener('click', () => this.deleteLayer());
                
                // File menu (Save, Load, Export)
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const fileMenuDropdown = document.getElementById('fileMenuDropdown');
                fileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    _closeAllDropdowns('fileMenuDropdown');
                    fileMenuDropdown.classList.toggle('show');
                });
                document.getElementById('saveProjectBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    this.saveProject();
                });
                document.getElementById('loadProjectBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.getElementById('loadProjectInput').click();
                });
                document.getElementById('loadProjectInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadProject(e.target.files[0]);
                        e.target.value = ''; // Reset so same file can be loaded again
                    }
                });
                document.getElementById('importSequenceBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.querySelectorAll('.dropdown-submenu-container').forEach(c => c.classList.remove('touch-open'));
                    document.getElementById('importSequenceInput').click();
                });
                document.getElementById('importSequenceInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.importImageSequence(Array.from(e.target.files));
                        e.target.value = '';
                    }
                });
                
                // Audio import
                document.getElementById('importAudioBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.querySelectorAll('.dropdown-submenu-container').forEach(c => c.classList.remove('touch-open'));
                    document.getElementById('importAudioInput').click();
                });
                document.getElementById('importAudioInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.importAudio(e.target.files[0]);
                        e.target.value = '';
                    }
                });
                
                // Sync scroll: frames â†” audio waveforms â†” scrub ruler
                const framesSection = document.getElementById('timelineFramesSection');
                const scrubRuler = document.getElementById('scrubRuler');
                let _syncingScroll = false;
                
                this._syncScroll = (source) => {
                    if (_syncingScroll) return;
                    _syncingScroll = true;
                    const sl = source.scrollLeft;
                    if (source !== framesSection) framesSection.scrollLeft = sl;
                    if (source !== scrubRuler) scrubRuler.scrollLeft = sl;
                    // Sync all audio waveform containers
                    document.querySelectorAll('.audio-timeline-waveform').forEach(wc => {
                        if (wc !== source) wc.scrollLeft = sl;
                    });
                    this.updatePlayheadPosition();
                    _syncingScroll = false;
                };
                
                framesSection.addEventListener('scroll', () => this._syncScroll(framesSection));
                scrubRuler.addEventListener('scroll', () => this._syncScroll(scrubRuler));
                // Audio waveform scroll sync is attached via MutationObserver
                const audioContainer = document.getElementById('audioTracksContainer');
                const audioScrollObserver = new MutationObserver(() => {
                    document.querySelectorAll('.audio-timeline-waveform').forEach(wc => {
                        wc.onscroll = () => this._syncScroll(wc);
                    });
                });
                audioScrollObserver.observe(audioContainer, { childList: true, subtree: true });
                
                // Scrub ruler interaction: click/drag to scrub through frames
                const scrubToX = (clientX) => {
                    if (this.isPlaying) this.stop();
                    const rect = scrubRuler.getBoundingClientRect();
                    const x = clientX - rect.left + scrubRuler.scrollLeft;
                    const { cellW, padding } = this.getTimelineMetrics();
                    const timelinePos = Math.floor((x - padding + cellW / 2) / cellW);
                    const layer = this.getCurrentLayer();
                    const offset = layer.startFrame || 0;
                    const localIdx = timelinePos - offset;
                    const maxLocal = layer.frames.length - 1;
                    const newIdx = Math.max(0, Math.min(maxLocal, localIdx));
                    if (newIdx !== this.currentFrameIndex) {
                        if (this.selection) { this._dismissTransform(); }
                        this.currentFrameIndex = newIdx;
                        this.render();
                        this.scrubAudio(this.getPlayheadPosition());
                    }
                };
                
                scrubRuler.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    if (this.selectedFrames.size > 0) {
                        this.selectedFrames.clear();
                        this._timelineDirty = true;
                        this._scheduleRenderTimeline();
                    }
                    scrubRuler.setPointerCapture(e.pointerId);
                    this._isScrubbing = true;
                    scrubToX(e.clientX);
                });
                scrubRuler.addEventListener('pointermove', (e) => {
                    if (!this._isScrubbing) return;
                    scrubToX(e.clientX);
                });
                scrubRuler.addEventListener('pointerup', (e) => {
                    this._isScrubbing = false;
                    this.stopScrubAudio();
                    if (scrubRuler.hasPointerCapture(e.pointerId)) {
                        scrubRuler.releasePointerCapture(e.pointerId);
                    }
                });
                scrubRuler.addEventListener('pointercancel', (e) => {
                    this._isScrubbing = false;
                    this.stopScrubAudio();
                });
                document.getElementById('exportPngZip').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.querySelectorAll('.dropdown-submenu-container').forEach(c => c.classList.remove('touch-open'));
                    this.exportGif();
                });
                document.getElementById('exportGifBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.querySelectorAll('.dropdown-submenu-container').forEach(c => c.classList.remove('touch-open'));
                    this.exportAsGif();
                });
                document.getElementById('exportMp4Btn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.querySelectorAll('.dropdown-submenu-container').forEach(c => c.classList.remove('touch-open'));
                    this.exportAsMp4();
                });
                
                // Touch support for submenus â€” toggle on tap since hover doesn't work on touch
                document.querySelectorAll('.submenu-trigger').forEach(trigger => {
                    trigger.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        const container = trigger.closest('.dropdown-submenu-container');
                        // Close other submenus first
                        document.querySelectorAll('.dropdown-submenu-container.touch-open').forEach(c => {
                            if (c !== container) c.classList.remove('touch-open');
                        });
                        container.classList.toggle('touch-open');
                    });
                });
                
                // Canvas Size modal
                const csModal = document.getElementById('canvasSizeModal');
                const csWidthIn = document.getElementById('canvasWidthInput');
                const csHeightIn = document.getElementById('canvasHeightInput');
                const csPreset = document.getElementById('canvasPreset');
                const csLinkBtn = document.getElementById('canvasLinkBtn');
                const csInfo = document.getElementById('canvasSizeInfo');
                let csLinked = false;
                let csAspect = 1;
                
                const csUpdateInfo = () => {
                    const w = parseInt(csWidthIn.value) || 0;
                    const h = parseInt(csHeightIn.value) || 0;
                    const curW = this.projectWidth;
                    const curH = this.projectHeight;
                    if (w === curW && h === curH) {
                        csInfo.textContent = `Current size: ${curW} Ã— ${curH}`;
                    } else {
                        csInfo.textContent = `${curW} Ã— ${curH}  â†’  ${w} Ã— ${h}`;
                    }
                };
                
                document.getElementById('canvasSizeBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    csWidthIn.value = this.projectWidth;
                    csHeightIn.value = this.projectHeight;
                    csPreset.value = 'custom';
                    csAspect = this.projectWidth / this.projectHeight;
                    document.getElementById('canvasBgColor').value = this.bgColor;
                    document.getElementById('canvasBgColorLabel').textContent = this.bgColor;
                    csUpdateInfo();
                    csModal.classList.add('show');
                });
                
                // Background color â€” live preview
                document.getElementById('canvasBgColor').addEventListener('input', (e) => {
                    this.bgColor = e.target.value;
                    document.getElementById('canvasBgColorLabel').textContent = e.target.value;
                    this.canvasWrapper.style.background = this.bgColor;
                });
                
                const csClose = () => csModal.classList.remove('show');
                document.getElementById('canvasSizeClose').addEventListener('click', csClose);
                document.getElementById('canvasSizeCancel').addEventListener('click', csClose);
                csModal.addEventListener('click', (e) => { if (e.target === csModal) csClose(); });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && csModal.classList.contains('show')) {
                        e.preventDefault();
                        e.stopPropagation();
                        csClose();
                    }
                });
                
                csLinkBtn.addEventListener('click', () => {
                    csLinked = !csLinked;
                    csLinkBtn.classList.toggle('linked', csLinked);
                    if (csLinked) csAspect = (parseInt(csWidthIn.value) || 1) / (parseInt(csHeightIn.value) || 1);
                });
                
                csWidthIn.addEventListener('input', () => {
                    csPreset.value = 'custom';
                    if (csLinked) {
                        csHeightIn.value = Math.round((parseInt(csWidthIn.value) || 1) / csAspect);
                    }
                    csUpdateInfo();
                });
                csHeightIn.addEventListener('input', () => {
                    csPreset.value = 'custom';
                    if (csLinked) {
                        csWidthIn.value = Math.round((parseInt(csHeightIn.value) || 1) * csAspect);
                    }
                    csUpdateInfo();
                });
                
                csPreset.addEventListener('change', () => {
                    if (csPreset.value !== 'custom') {
                        const [w, h] = csPreset.value.split('x').map(Number);
                        csWidthIn.value = w;
                        csHeightIn.value = h;
                        if (csLinked) csAspect = w / h;
                        csUpdateInfo();
                    }
                });
                
                document.getElementById('canvasSizeApply').addEventListener('click', () => {
                    const newW = Math.max(1, Math.min(7680, parseInt(csWidthIn.value) || this.projectWidth));
                    const newH = Math.max(1, Math.min(7680, parseInt(csHeightIn.value) || this.projectHeight));
                    const mode = document.getElementById('canvasResizeMode').value;
                    csClose();
                    if (newW !== this.projectWidth || newH !== this.projectHeight) {
                        this.resizeCanvas(newW, newH, mode);
                    }
                });
            }
            
            selectTool(tool) {
                // Finalize pen path when switching away from pen tool
                if (this._penActive && tool !== 'pen') {
                    this._penFinalize(false);
                }
                
                // Cancel roundrect edit if switching away
                if (this._roundRectEdit && tool !== 'roundrect') {
                    this._cancelRoundRect();
                }
                
                // Finalize gradient edit if switching away
                if (this._gradientEdit && tool !== 'gradient') {
                    this._finalizeGradient();
                }
                
                this.tool = tool;
                document.querySelectorAll('.toolbar button').forEach(btn => btn.classList.remove('active'));
                const toolButton = document.getElementById(tool + 'Tool');
                if (toolButton) toolButton.classList.add('active');
                
                // For magnifier, magnifier-out and pan, highlight the navTool dropdown button
                if (tool === 'magnifier' || tool === 'magnifier-out' || tool === 'pan') {
                    document.getElementById('navTool').classList.add('active');
                }
                
                // For transform sub-tools, highlight the transformTool dropdown button
                if (tool === 'transform' || tool === 'scale' || tool === 'rotate' || tool === 'skew' || tool === 'distort') {
                    document.getElementById('transformTool').classList.add('active');
                }
                
                // For shape sub-tools, highlight the shapeTool dropdown button
                if (tool === 'pen' || tool === 'rect' || tool === 'roundrect' || tool === 'circle' || tool === 'triangle') {
                    document.getElementById('shapeTool').classList.add('active');
                }
                
                // For fill sub-tools, highlight the fillTool dropdown button
                if (tool === 'fill' || tool === 'gradient' || tool === 'eyedropper') {
                    document.getElementById('fillTool').classList.add('active');
                    // Update button icon to match selected sub-tool
                    const _fillIcons = {
                        'fill': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="16" height="16"><path d="M8 2C8 2 3 7.5 3 10.5a5 5 0 0010 0C13 7.5 8 2 8 2z" fill="currentColor"/></svg>',
                        'gradient': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="16" height="16"><rect x="2" y="2" width="12" height="12" rx="1.5"/><line x1="5" y1="14" x2="14" y2="5" stroke-opacity="0.4"/><line x1="2" y1="14" x2="14" y2="2" stroke-opacity="0.6"/><line x1="2" y1="11" x2="11" y2="2" stroke-opacity="0.4"/></svg>',
                        'eyedropper': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="16" height="16"><path d="M13.5 2.5a1.4 1.4 0 00-2 0L10 4l-1-.5-5 5-.5 3.5 3.5-.5 5-5L11.5 6l1.5-1.5a1.4 1.4 0 000-2z"/><path d="M3.5 12l.5.5"/></svg>'
                    };
                    const _fillNames = { 'fill': 'Fill', 'gradient': 'Gradient', 'eyedropper': 'Eyedropper' };
                    const _fb = document.getElementById('fillTool');
                    _fb.innerHTML = `${_fillIcons[tool]} <span class="btn-label">${_fillNames[tool]} â–¼</span><span class="gradient-badge"></span>`;
                }
                
                // Sync gradient UI state
                this._syncGradientUI();
                
                // Sync pill pan button
                const pillPan = document.getElementById('pillPanBtn');
                if (pillPan) {
                    pillPan.classList.toggle('pill-active', tool === 'pan');
                }
                
                // Clear selection when switching away from transform (but not for pan/magnifier)
                const isTransformTool = tool === 'transform' || tool === 'scale' || tool === 'rotate' || tool === 'skew' || tool === 'distort';
                const isNavTool = tool === 'pan' || tool === 'magnifier' || tool === 'magnifier-out';
                if (!isTransformTool && !isNavTool && this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                // Show transform handles if transform-family tool and selection exists
                if (isTransformTool && this.selection) {
                    this.showTransformHandles();
                } else if (isTransformTool && !this.selection) {
                    // Auto-select all content in the current frame
                    this.selectAllInFrame();
                } else {
                    this.hideTransformHandles();
                }
                
                // Manage brush cursor visibility and canvas default cursor
                if (tool === 'brush' || tool === 'eraser') {
                    this.canvas.style.cursor = 'none';
                    this.selectionCanvas.style.cursor = 'none';
                    this.canvasContainer.style.cursor = 'none';
                    this.canvasWrapper.style.cursor = 'none';
                } else if (tool === 'fill' || tool === 'gradient' || tool === 'lasso') {
                    this.canvas.style.cursor = 'crosshair';
                    this.selectionCanvas.style.cursor = 'crosshair';
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'eyedropper') {
                    // Custom eyedropper cursor via inline SVG data URI
                    const eyedropperCursor = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Ccircle cx='12' cy='12' r='9' stroke='white' stroke-width='1.5'/%3E%3Ccircle cx='12' cy='12' r='9' stroke='black' stroke-width='3' stroke-opacity='0.25'/%3E%3Ccircle cx='12' cy='12' r='9' stroke='white' stroke-width='1.5'/%3E%3Cline x1='12' y1='2' x2='12' y2='7' stroke='black' stroke-width='2.5' stroke-opacity='0.25'/%3E%3Cline x1='12' y1='2' x2='12' y2='7' stroke='white' stroke-width='1.5'/%3E%3Cline x1='12' y1='17' x2='12' y2='22' stroke='black' stroke-width='2.5' stroke-opacity='0.25'/%3E%3Cline x1='12' y1='17' x2='12' y2='22' stroke='white' stroke-width='1.5'/%3E%3Cline x1='2' y1='12' x2='7' y2='12' stroke='black' stroke-width='2.5' stroke-opacity='0.25'/%3E%3Cline x1='2' y1='12' x2='7' y2='12' stroke='white' stroke-width='1.5'/%3E%3Cline x1='17' y1='12' x2='22' y2='12' stroke='black' stroke-width='2.5' stroke-opacity='0.25'/%3E%3Cline x1='17' y1='12' x2='22' y2='12' stroke='white' stroke-width='1.5'/%3E%3C/svg%3E") 12 12, crosshair`;
                    this.canvas.style.cursor = eyedropperCursor;
                    this.selectionCanvas.style.cursor = eyedropperCursor;
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'pen') {
                    this.canvas.style.cursor = 'crosshair';
                    this.selectionCanvas.style.cursor = 'crosshair';
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'pan') {
                    this.canvas.style.cursor = 'grab';
                    this.selectionCanvas.style.cursor = 'grab';
                    this.canvasContainer.style.cursor = 'grab';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'magnifier') {
                    this.canvas.style.cursor = 'zoom-in';
                    this.selectionCanvas.style.cursor = 'zoom-in';
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'magnifier-out') {
                    this.canvas.style.cursor = 'zoom-out';
                    this.selectionCanvas.style.cursor = 'zoom-out';
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'rect' || tool === 'roundrect' || tool === 'circle' || tool === 'triangle') {
                    this.canvas.style.cursor = 'crosshair';
                    this.selectionCanvas.style.cursor = 'crosshair';
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                } else {
                    this.canvas.style.cursor = 'default';
                    this.selectionCanvas.style.cursor = 'default';
                    this.canvasContainer.style.cursor = '';
                    this.canvasWrapper.style.cursor = '';
                    this.brushCursor.style.display = 'none';
                }
            }
            
            _updateNavButton(navtool) {
                const navButton = document.getElementById('navTool');
                const icons = {
                    'magnifier': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg>',
                    'magnifier-out': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M5 7h4"/><path d="M11 11l3.5 3.5"/></svg>',
                    'pan': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5.5 8V3.5a1 1 0 012 0V7"/><path d="M7.5 7V2.5a1 1 0 012 0V7"/><path d="M9.5 7V3.5a1 1 0 012 0V7"/><path d="M11.5 5.5a1 1 0 012 0V10c0 2.5-2 4.5-4.5 4.5h-1C6 14.5 4 12.5 4 10V8.5"/><path d="M5.5 8c0 0-2-1-2.5-2s0-2 1-1.5l1.5 1"/></svg>'
                };
                const labels = { 'magnifier': 'Zoom In', 'magnifier-out': 'Zoom Out', 'pan': 'Pan' };
                navButton.innerHTML = `${icons[navtool]} <span class="btn-label">${labels[navtool]} â–¼</span>`;
            }
            
            _updateTransformButton(xformtool) {
                const btn = document.getElementById('transformTool');
                const icons = {
                    'transform': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2.5" y="2.5" width="11" height="11" rx="0.5" stroke-dasharray="2 2"/><circle cx="2.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg>',
                    'scale': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10 2h4v4"/><path d="M14 2l-4.5 4.5"/><path d="M6 14H2v-4"/><path d="M2 14l4.5-4.5"/></svg>',
                    'rotate': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 8A5.5 5.5 0 112.5 5.5"/><path d="M2.5 1.5v4h4"/></svg>',
                    'skew': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 2.5h9.5v11H2.5V6"/><circle cx="4" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg>',
                    'distort': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 1.5L13 3l1 11.5L2 13z"/><circle cx="4" cy="1.5" r="1" fill="currentColor" stroke="none"/><circle cx="13" cy="3" r="1" fill="currentColor" stroke="none"/><circle cx="3" cy="13" r="1" fill="currentColor" stroke="none"/><circle cx="14" cy="14.5" r="1" fill="currentColor" stroke="none"/></svg>'
                };
                const labels = { 'transform': 'Transform', 'scale': 'Scale', 'rotate': 'Rotate', 'skew': 'Skew', 'distort': 'Distort' };
                btn.innerHTML = `${icons[xformtool]} <span class="btn-label">${labels[xformtool]} â–¼</span>`;
            }
            
            updateBrushCursor() {
                const shape = this.tool === 'eraser' ? this.eraserShape : this.brushShape;
                const rect = this.canvas.getBoundingClientRect();
                const displayScale = rect.width / this.canvas.width;
                const size = Math.max(2, this.brushSize * displayScale);
                
                let w = size, h = size;
                if (shape === 'oval-h') {
                    w = size;
                    h = size * 0.4;
                } else if (shape === 'oval-v') {
                    w = size * 0.4;
                    h = size;
                }
                
                this.brushCursor.style.width = w + 'px';
                this.brushCursor.style.height = h + 'px';
                this.brushCursor.className = 'brush-cursor ' + shape;
            }
            
            syncBrushSizeUI() {
                // Sync the dropdown diameter sliders with the current brushSize
                if (this.tool === 'brush') {
                    document.getElementById('brushDiameter').value = this.brushSize;
                    document.getElementById('brushDiameterValue').textContent = this.brushSize;
                } else if (this.tool === 'eraser') {
                    document.getElementById('eraserDiameter').value = this.brushSize;
                    document.getElementById('eraserDiameterValue').textContent = this.brushSize;
                }
            }
            
            getCurrentBrushShape() {
                return this.tool === 'eraser' ? this.eraserShape : this.brushShape;
            }
            
            getSmoothing() {
                return this.tool === 'eraser' ? this.eraserSmoothing : this.brushSmoothing;
            }
            
            constrainToAxis(anchorX, anchorY, x, y) {
                const dx = x - anchorX;
                const dy = y - anchorY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (this._shiftLockedAngle === null) {
                    if (dist < 8) return { x: anchorX, y: anchorY };
                    const angle = Math.atan2(dy, dx);
                    this._shiftLockedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                }
                const ax = Math.cos(this._shiftLockedAngle);
                const ay = Math.sin(this._shiftLockedAngle);
                const proj = dx * ax + dy * ay;
                return { x: anchorX + ax * proj, y: anchorY + ay * proj };
            }
            
            selectAllInFrame() {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (!frame) return;
                
                const frameCtx = frame.getContext('2d');
                const pixelData = frameCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = pixelData.data;
                
                // Find tight bounding box of non-transparent pixels
                let minX = frame.width, minY = frame.height, maxX = -1, maxY = -1;
                
                for (let py = 0; py < frame.height; py++) {
                    for (let px = 0; px < frame.width; px++) {
                        const alpha = pixels[(py * frame.width + px) * 4 + 3];
                        if (alpha > 0) {
                            if (px < minX) minX = px;
                            if (px > maxX) maxX = px;
                            if (py < minY) minY = py;
                            if (py > maxY) maxY = py;
                        }
                    }
                }
                
                // Nothing on the frame
                if (maxX < 0 || maxY < 0) {
                    this.hideTransformHandles();
                    return;
                }
                
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                
                // Create selection canvas with the content
                const selectedCanvas = document.createElement('canvas');
                selectedCanvas.width = width;
                selectedCanvas.height = height;
                const selectedCtx = selectedCanvas.getContext('2d');
                selectedCtx.drawImage(frame, minX, minY, width, height, 0, 0, width, height);
                
                // Store selection
                this.selection = {
                    imageData: selectedCanvas,
                    bounds: { x: minX, y: minY, width, height },
                    originalBounds: { x: minX, y: minY, width, height }
                };
                
                // Erase content from original frame
                this.saveState();
                frameCtx.clearRect(0, 0, frame.width, frame.height);
                
                this.showTransformHandles();
                this.render();
            }
            
            // === UNDO SYSTEM: Two-tier snapshots ===
            // saveState()     â†’ fast, single-frame (brush, fill, eraser, clear, lasso, paste)
            // saveFullState() â†’ slow, all frames   (add/delete layer/frame, resize, import)
            
            snapshotFrame() {
                // Fast: only copy current frame on current layer (1 getImageData call)
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                let frameData = null;
                if (frame) {
                    frameData = {
                        width: frame.width,
                        height: frame.height,
                        originX: frame._originX || 0,
                        originY: frame._originY || 0,
                        imageData: frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
                    };
                }
                return {
                    type: 'frame',
                    layerId: this.currentLayerId,
                    frameIndex: this.currentFrameIndex,
                    frameData: frameData
                };
            }
            
            snapshotState() {
                // Full: copy ALL frames as ImageData (N getImageData calls)
                // Track hold frame relationships (shared canvases)
                return {
                    type: 'full',
                    layers: this.layers.map(layer => {
                        const canvasIdMap = new Map();
                        return {
                            id: layer.id,
                            name: layer.name,
                            visible: layer.visible,
                            opacity: layer.opacity,
                            startFrame: layer.startFrame || 0,
                            frames: layer.frames.map((frame, fi) => {
                                if (!frame) return null;
                                if (canvasIdMap.has(frame)) {
                                    return { holdRef: canvasIdMap.get(frame) };
                                }
                                canvasIdMap.set(frame, fi);
                                return {
                                    width: frame.width,
                                    height: frame.height,
                                    originX: frame._originX || 0,
                                    originY: frame._originY || 0,
                                    imageData: frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
                                };
                            }),
                            transformKeyframes: (layer.transformKeyframes || []).map(kf => ({...kf})),
                            parentId: layer.parentId || null
                        };
                    }),
                    currentLayerId: this.currentLayerId,
                    currentFrameIndex: this.currentFrameIndex,
                    nextLayerId: this.nextLayerId
                };
            }
            
            _pushUndo(entry) {
                // Dynamically limit undo stack based on project complexity
                // to prevent out-of-memory on large projects (especially iPad)
                const totalFrames = this.layers.reduce((sum, l) => sum + l.frames.filter(f => f).length, 0);
                const effectiveMax = totalFrames > 50 ? Math.max(5, Math.floor(this.maxHistorySize / 3))
                                   : totalFrames > 20 ? Math.max(10, Math.floor(this.maxHistorySize / 2))
                                   : this.maxHistorySize;
                
                this.undoStack.push(entry);
                while (this.undoStack.length > effectiveMax) this.undoStack.shift();
                this.redoStack = [];
                this.updateUndoRedoButtons();
            }
            
            saveState() {
                // Fast path â€” single frame snapshot
                this._pushUndo(this.snapshotFrame());
            }
            
            saveFullState() {
                // Slow path â€” full snapshot for structural changes
                this._timelineDirty = true; // Structural change â€” timeline needs rebuild
                this._invalidateCompositeCache();
                // Wrapped in try-catch because snapshotting many large frames
                // can exceed memory limits (especially on iPad)
                try {
                    this._pushUndo(this.snapshotState());
                } catch(e) {
                    console.warn('Full undo snapshot failed (likely memory):', e.message);
                    // Trim undo stack to free memory and retry once
                    if (this.undoStack.length > 2) {
                        this.undoStack.splice(0, Math.floor(this.undoStack.length / 2));
                        try {
                            this._pushUndo(this.snapshotState());
                        } catch(e2) {
                            console.warn('Undo snapshot skipped after retry:', e2.message);
                        }
                    }
                    this.updateUndoRedoButtons();
                }
            }
            
            // Snapshot current state matching the type of entry about to be restored
            _snapshotMatching(entry) {
                if (entry.type === 'frame') {
                    const layer = this.layers.find(l => l.id === entry.layerId);
                    if (layer && layer.frames[entry.frameIndex]) {
                        const frame = layer.frames[entry.frameIndex];
                        return {
                            type: 'frame',
                            layerId: entry.layerId,
                            frameIndex: entry.frameIndex,
                            frameData: {
                                width: frame.width,
                                height: frame.height,
                                originX: frame._originX || 0,
                                originY: frame._originY || 0,
                                imageData: frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
                            }
                        };
                    }
                    // Layer/frame gone â€” fall back to full
                    return this.snapshotState();
                }
                return this.snapshotState();
            }
            
            undo() {
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    if (this._pendingSnapshot) {
                        this._pushUndo(this._pendingSnapshot);
                        this._pendingSnapshot = null;
                    } else {
                        this.saveState();
                    }
                }
                
                if (this.selection && this.selectionUndoStack.length > 0) {
                    this.restoreSelectionState();
                    return;
                }
                
                if (this.undoStack.length === 0) return;
                
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                    this.hideTransformHandles();
                }
                
                const prev = this.undoStack.pop();
                this.redoStack.push(this._snapshotMatching(prev));
                this.restoreState(prev);
                this.updateUndoRedoButtons();
            }
            
            redo() {
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    if (this._pendingSnapshot) {
                        this._pushUndo(this._pendingSnapshot);
                        this._pendingSnapshot = null;
                    } else {
                        this.saveState();
                    }
                }
                
                if (this.selection && this.selectionRedoStack.length > 0) {
                    this.redoSelectionState();
                    return;
                }
                
                if (this.redoStack.length === 0) return;
                
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                    this.hideTransformHandles();
                }
                
                const next = this.redoStack.pop();
                this.undoStack.push(this._snapshotMatching(next));
                this.restoreState(next);
                this.updateUndoRedoButtons();
            }
            
            restoreState(state) {
                this._invalidateCompositeCache();
                if (state.type === 'frame') {
                    // Fast restore â€” overwrite just one frame's pixels
                    const layer = this.layers.find(l => l.id === state.layerId);
                    if (layer && layer.frames[state.frameIndex] && state.frameData) {
                        const frame = layer.frames[state.frameIndex];
                        // Resize frame if snapshot was different size (auto-expand undo)
                        if (frame.width !== state.frameData.width || frame.height !== state.frameData.height) {
                            frame.width = state.frameData.width;
                            frame.height = state.frameData.height;
                        }
                        frame._originX = state.frameData.originX || 0;
                        frame._originY = state.frameData.originY || 0;
                        const ctx = frame.getContext('2d');
                        ctx.clearRect(0, 0, frame.width, frame.height);
                        ctx.putImageData(state.frameData.imageData, 0, 0);
                        this._dirtyThumb(frame);
                    }
                    this.render();
                    return;
                }
                
                // Full restore â€” rebuild all layers (preserving hold frame relationships)
                this._timelineDirty = true;
                this.layers = state.layers.map(layer => ({
                    id: layer.id,
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    startFrame: layer.startFrame || 0,
                    parentId: layer.parentId || null,
                    transformKeyframes: (layer.transformKeyframes || []).map(kf => ({...kf})),
                    frames: (() => {
                        const canvasMap = new Map();
                        return layer.frames.map((snapshot, fi) => {
                            if (!snapshot) return null;
                            if (snapshot.holdRef !== undefined) {
                                return canvasMap.get(snapshot.holdRef) || null;
                            }
                            const c = document.createElement('canvas');
                            c.width = snapshot.width;
                            c.height = snapshot.height;
                            c._originX = snapshot.originX || 0;
                            c._originY = snapshot.originY || 0;
                            c.getContext('2d').putImageData(snapshot.imageData, 0, 0);
                            canvasMap.set(fi, c);
                            return c;
                        });
                    })()
                }));
                
                this.currentLayerId = state.currentLayerId;
                this.currentFrameIndex = state.currentFrameIndex;
                this.nextLayerId = state.nextLayerId;
                
                this.render();
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                const canUndo = this.undoStack.length > 0 || (this.selection && this.selectionUndoStack.length > 0);
                const canRedo = this.redoStack.length > 0 || (this.selection && this.selectionRedoStack.length > 0);
                
                undoBtn.disabled = !canUndo;
                redoBtn.disabled = !canRedo;
                
                undoBtn.style.opacity = canUndo ? '1' : '0.5';
                redoBtn.style.opacity = canRedo ? '1' : '0.5';
            }
            
            startDrawing(e) {
                // Pan and magnifier tools don't draw
                if (this.tool === 'pan' || this.tool === 'magnifier' || this.tool === 'magnifier-out') return;
                
                // Handle fill tool
                if (this.tool === 'fill') {
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    // Convert to world then frame-local
                    const worldX = canvasX + this.viewportX;
                    const worldY = canvasY + this.viewportY;
                    const layer = this.getCurrentLayer();
                    const frame = layer.frames[this.currentFrameIndex];
                    if (frame) {
                        const local = this.worldToLocal(worldX, worldY, frame);
                        const lx = Math.floor(local.x);
                        const ly = Math.floor(local.y);
                        // If a gradient is stored, use gradient fill; otherwise solid fill
                        if (this.gradientDef) {
                            this.gradientFill(lx, ly, this.gradientDef);
                        } else {
                            this.floodFill(lx, ly);
                        }
                    }
                    return;
                }
                
                // Handle gradient tool (Step 2 will add drag interaction)
                if (this.tool === 'gradient') {
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const worldX = canvasX + this.viewportX;
                    const worldY = canvasY + this.viewportY;
                    const layer = this.getCurrentLayer();
                    const frame = layer.frames[this.currentFrameIndex];
                    if (!frame) return;
                    const local = this.worldToLocal(worldX, worldY, frame);
                    
                    // If in edit mode, check if clicking near an endpoint to drag it
                    if (this._gradientEdit) {
                        const edit = this._gradientEdit;
                        const hitRadius = 16 / (this.zoomLevel || 1); // scale hit target with zoom
                        const distStart = Math.hypot(local.x - edit.startLocal.x, local.y - edit.startLocal.y);
                        const distEnd = Math.hypot(local.x - edit.endLocal.x, local.y - edit.endLocal.y);
                        
                        if (distStart < hitRadius || distEnd < hitRadius) {
                            // Drag the nearest endpoint
                            edit.dragging = distStart <= distEnd ? 'start' : 'end';
                            this.isDrawing = true;
                            return;
                        }
                        
                        // Clicking elsewhere â€” finalize current, then start new drag
                        this._finalizeGradient();
                    }
                    
                    this._gradientDrag = {
                        startLocal: { x: local.x, y: local.y },
                        endLocal: { x: local.x, y: local.y },
                        originX: frame._originX || 0,
                        originY: frame._originY || 0,
                    };
                    // Pre-compute the fill mask at the start point for live preview
                    this._gradientMaskCache = this._computeGradientMask(frame, Math.floor(local.x), Math.floor(local.y));
                    if (this._gradientMaskCache) {
                        this._gradientMaskCache.frameRef = frame;
                        this._gradientMaskCache.frameIndex = this.currentFrameIndex;
                        this._gradientMaskCache.layerId = this.currentLayerId;
                    }
                    this.isDrawing = true;
                    return;
                }
                
                // Handle eyedropper tool
                if (this.tool === 'eyedropper') {
                    this._pickColor(e);
                    return;
                }
                
                // Handle lasso tool differently
                if (this.tool === 'lasso') {
                    this.saveState(); // Save before starting lasso selection
                    this.lassoPath = [];
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    this.lassoPath.push({x, y});
                    this.isDrawing = true;
                    return;
                }
                
                // Handle transform tool
                if (this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate' || this.tool === 'skew' || this.tool === 'distort') {
                    // Check if clicking on a handle
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    for (let handle of this.transformHandles) {
                        const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                        if (dist < 20) { // Large hit area for Apple Pencil & touch
                            const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                           handle.type === 'se' || handle.type === 'sw';
                            
                            // Rotate tool: corners always rotate
                            // Scale tool: corners always resize (never rotate)
                            // Free transform: hover-based rotation mode
                            const shouldRotate = (this.tool === 'rotate' && isCorner) ||
                                                 (this.tool === 'transform' && this.rotationMode && isCorner);
                            
                            if (shouldRotate) {
                                this.activeHandle = {type: 'rotate', corner: handle.type};
                                this.isRotating = true;
                                this.initialRotation = this.selection.rotation || 0;
                                const off = this.getSelectionDisplayOffset();
                                const anchorX = this.selection.anchorX + off.x;
                                const anchorY = this.selection.anchorY + off.y;
                                this.startAngle = Math.atan2(y - anchorY, x - anchorX);
                                this.updateRotationCursor(handle.type, true);
                            } else if (this.tool !== 'rotate') {
                                // Scale or free transform resize
                                this.activeHandle = handle;
                            } else {
                                // Rotate tool on edge handles: allow move only
                                continue;
                            }
                            
                            this.transformStart = {x, y};
                            this.isTransforming = true;
                            this.saveSelectionState();
                            return;
                        }
                    }
                    
                    // Check if clicking inside selection to move it
                    if (this.selection && this.isPointInSelection(x, y)) {
                        this.activeHandle = {type: 'move'};
                        this.transformStart = {x, y};
                        this.isTransforming = true;
                        this.saveSelectionState();
                        return;
                    }
                    
                    // Clicked outside selection â€” apply, deselect, switch to lasso
                    if (this.selection) {
                        this._dismissTransform();
                        return;
                    }
                    return;
                }
                
                // === Pen Tool ===
                if (this.tool === 'pen') {
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    const hitRadius = 10 / (rect.width / this.canvas.width);
                    
                    // Guard: if we're already dragging a new handle (point just placed),
                    // skip duplicate events from iPad touch+pointer firing both
                    if (this._penDragType === 'newHandle' && (performance.now() - (this._penLastPointTime || 0)) < 200) {
                        return;
                    }
                    
                    // Guard: skip events immediately after finalize/cancel (button tap bleed-through)
                    if (this._penFinalizeTime && (performance.now() - this._penFinalizeTime) < 300) {
                        return;
                    }
                    
                    if (!this._penActive) {
                        // Save state before first pen point
                        this.saveState();
                    }
                    
                    // Check if clicking near first point to close path
                    // Guard: skip if last point was just placed (prevents duplicate event finalization on iPad)
                    const _timeSinceLastPt = performance.now() - (this._penLastPointTime || 0);
                    if (this._penPoints.length >= 2 && _timeSinceLastPt > 150) {
                        const fp = this._penPoints[0];
                        if (Math.hypot(x - fp.x, y - fp.y) < hitRadius) {
                            this._penFinalize(true);
                            return;
                        }
                        // Tap last point to finalize as open path
                        const lp = this._penPoints[this._penPoints.length - 1];
                        if (Math.hypot(x - lp.x, y - lp.y) < hitRadius) {
                            this._penFinalize(false);
                            return;
                        }
                    }
                    
                    // Check if clicking an existing point/handle to drag
                    for (let i = 0; i < this._penPoints.length; i++) {
                        const pt = this._penPoints[i];
                        if (Math.hypot(x - pt.x, y - pt.y) < hitRadius) {
                            this._penDragIdx = i;
                            this._penDragType = 'point';
                            this._penDragStart = { x, y, origX: pt.x, origY: pt.y };
                            return;
                        }
                        if (pt.handleOut && Math.hypot(x - pt.handleOut.x, y - pt.handleOut.y) < hitRadius) {
                            this._penDragIdx = i;
                            this._penDragType = 'handleOut';
                            return;
                        }
                        if (pt.handleIn && Math.hypot(x - pt.handleIn.x, y - pt.handleIn.y) < hitRadius) {
                            this._penDragIdx = i;
                            this._penDragType = 'handleIn';
                            return;
                        }
                    }
                    
                    // Add new point
                    this._penActive = true;
                    let px = x, py = y;
                    // Shift: snap to 45Â° angle from previous point
                    if (e.shiftKey && this._penPoints.length > 0) {
                        const prev = this._penPoints[this._penPoints.length - 1];
                        const snapped = this._penSnap45(prev.x, prev.y, x, y);
                        px = snapped.x;
                        py = snapped.y;
                    }
                    this._penPoints.push({ x: px, y: py, handleIn: null, handleOut: null });
                    this._penLastPointTime = performance.now();
                    this._penDragIdx = this._penPoints.length - 1;
                    this._penDragType = 'newHandle';
                    this._penNewHandleOrigin = { x: px, y: py };
                    this._penShiftHeld = e.shiftKey;
                    this._penRenderPreview();
                    return;
                }
                
                // Draw FIRST for instant visual feedback (critical for iPad)
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                
                // Convert to world coords, then frame-local
                const worldX = canvasX + this.viewportX;
                const worldY = canvasY + this.viewportY;
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    const layer = this.getCurrentLayer();
                    const frame = layer.frames[this.currentFrameIndex];
                    this._drawingFrameIndex = this.currentFrameIndex; // Track which frame the stroke started on
                    // Cache per-stroke values to avoid method calls on every pointermove
                    this._strokeShape = this.getCurrentBrushShape();
                    this._strokeSmoothing = this.getSmoothing();
                    this._strokeCompositeOp = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                    this._strokeColor = this.color;
                    this._strokeMode = this.smoothingMode; // 'standard' or 'smooth'
                    // Initialize post-stroke smoothing: collect raw points during drawing
                    this._strokePoints = (this._strokeMode === 'smooth') ? [] : null;
                    if (frame) {
                        const growth = this.ensureFrameCovers(frame, worldX, worldY);
                        if ((growth.dx !== 0 || growth.dy !== 0) && this._lastStrokeEnd) {
                            this._lastStrokeEnd.x += growth.dx;
                            this._lastStrokeEnd.y += growth.dy;
                        }
                    }
                    const local = this.worldToLocal(worldX, worldY, frame);
                    this.lastX = local.x;
                    this.lastY = local.y;
                    this.smoothX = local.x;
                    this.smoothY = local.y;
                } else {
                    // Shape tools work in canvas-pixel space (viewport-relative)
                    this.lastX = canvasX;
                    this.lastY = canvasY;
                }
                this.shapeStart = { x: this.lastX, y: this.lastY };
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    // Capture undo snapshot BEFORE the first mark goes down
                    if (!this.strokeStateSaved) {
                        this.strokeStateSaved = true;
                        this._pendingSnapshot = this.snapshotFrame();
                        // Store pre-stroke frame data for post-stroke smoothing restore (smooth mode only)
                        if (this._strokeMode === 'smooth' && this._pendingSnapshot && this._pendingSnapshot.frameData) {
                            this._preStrokeData = this._pendingSnapshot.frameData;
                        }
                    }
                    
                    // Shift+click = straight line from last stroke end (Photoshop-style)
                    if (e.shiftKey && this._lastStrokeEnd) {
                        this.drawLine(this._lastStrokeEnd.x, this._lastStrokeEnd.y, this.lastX, this.lastY);
                        // Add the line start to point buffer so post-stroke smoothing preserves it
                        if (this._strokePoints) {
                            this._strokePoints.push({ x: this._lastStrokeEnd.x, y: this._lastStrokeEnd.y, pressure: this.currentPressure });
                        }
                        this._lastStrokeEnd = { x: this.lastX, y: this.lastY };
                        // Skip post-stroke smoothing for shift+click straight lines
                        this._skipPostSmooth = true;
                    } else {
                        this._lastStrokeEnd = { x: this.lastX, y: this.lastY };
                        this._skipPostSmooth = false;
                    }
                    this.drawPoint(this.lastX, this.lastY);
                    // Seed point buffer for post-stroke smoothing
                    if (this._strokePoints) {
                        this._strokePoints.push({ x: this.lastX, y: this.lastY, pressure: this.currentPressure });
                    }
                    
                    // Push the pre-stroke snapshot to undo stack asynchronously
                    // (the snapshot is already captured â€” this just defers the stack push)
                    if (this._pendingSnapshot) {
                        const snap = this._pendingSnapshot;
                        this._pendingSnapshot = null;
                        this._pendingSaveTimer = setTimeout(() => {
                            this._pendingSaveTimer = null;
                            this._pushUndo(snap);
                            this.updateUndoRedoButtons();
                        }, 0);
                    }
                }
                
                // For shape tools, save state asynchronously as before
                if (this.tool !== 'brush' && this.tool !== 'eraser') {
                    if (!this.strokeStateSaved) {
                        this.strokeStateSaved = true;
                        this._pendingSaveTimer = setTimeout(() => {
                            this._pendingSaveTimer = null;
                            this.saveState();
                        }, 0);
                    }
                }
            }
            
            // Get effective brush size factoring in Apple Pencil pressure
            getPressureBrushSize() {
                if (this.pressureEnabled && (this.pointerType === 'pen' || this.hasStylusInput)) {
                    // Pen pressure: 0.0 to 1.0 â€” scale brush between 30% and 100% of set size
                    const pressureScale = 0.3 + this.currentPressure * 0.7;
                    return Math.max(1, this.brushSize * pressureScale);
                }
                return this.brushSize;
            }
            
            
            draw(e) {
                // Handle hover detection for rotation mode (free transform only, not scale-only)
                if (this.tool === 'transform' && this.selection && !this.isDrawing && !this.isTransforming) {
                    this.checkRotationHover(e);
                }
                // Rotate tool: always show rotation cursor near corners
                if (this.tool === 'rotate' && this.selection && !this.isDrawing && !this.isTransforming) {
                    this.checkRotateCursor(e);
                }
                // Skew/Distort: show move cursor on handles
                if ((this.tool === 'skew' || this.tool === 'distort') && this.selection && !this.isDrawing && !this.isTransforming) {
                    this._checkSkewDistortCursor(e);
                }
                
                // Gradient edit mode: show grab cursor near handles
                if (this.tool === 'gradient' && this._gradientEdit && !this.isDrawing) {
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const worldX = canvasX + this.viewportX;
                    const worldY = canvasY + this.viewportY;
                    const edit = this._gradientEdit;
                    const lx = worldX - edit.originX;
                    const ly = worldY - edit.originY;
                    const hitRadius = 16 / (this.zoomLevel || 1);
                    const nearStart = Math.hypot(lx - edit.startLocal.x, ly - edit.startLocal.y) < hitRadius;
                    const nearEnd = Math.hypot(lx - edit.endLocal.x, ly - edit.endLocal.y) < hitRadius;
                    this.canvas.style.cursor = (nearStart || nearEnd) ? 'grab' : 'crosshair';
                    this.selectionCanvas.style.cursor = this.canvas.style.cursor;
                }
                
                // Gradient tool: update end point during drag or edit-mode endpoint drag
                if (this.tool === 'gradient' && this.isDrawing) {
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const canvasX = (e.clientX - rect.left) * scaleX;
                    const canvasY = (e.clientY - rect.top) * scaleY;
                    const worldX = canvasX + this.viewportX;
                    const worldY = canvasY + this.viewportY;
                    
                    if (this._gradientEdit && this._gradientEdit.dragging) {
                        // Edit mode: drag endpoint
                        const edit = this._gradientEdit;
                        const localPt = {
                            x: worldX - edit.originX,
                            y: worldY - edit.originY,
                        };
                        if (edit.dragging === 'start') {
                            edit.startLocal = localPt;
                        } else {
                            edit.endLocal = localPt;
                        }
                        this.canvas.style.cursor = 'grabbing';
                        this.selectionCanvas.style.cursor = 'grabbing';
                        this.renderCanvasOnly();
                        return;
                    }
                    
                    if (this._gradientDrag) {
                        // Initial drag
                        this._gradientDrag.endLocal = {
                            x: worldX - this._gradientDrag.originX,
                            y: worldY - this._gradientDrag.originY,
                        };
                        this.renderCanvasOnly();
                        this._drawGradientPreview();
                        return;
                    }
                }
                
                // Pen tool: handle drag and preview
                if (this.tool === 'pen') {
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    this._penMousePos = { x, y };
                    this._penShiftHeld = e.shiftKey;
                    
                    if (this._penDragIdx >= 0) {
                        const pt = this._penPoints[this._penDragIdx];
                        // Track shift state dynamically during drag
                        this._penShiftHeld = e.shiftKey;
                        
                        if (this._penDragType === 'newHandle') {
                            // Creating handles on new point by dragging
                            const ox = this._penNewHandleOrigin.x;
                            const oy = this._penNewHandleOrigin.y;
                            let hx = x, hy = y;
                            // Shift: constrain handle to 45Â° from anchor
                            if (e.shiftKey) {
                                const snapped = this._penSnap45(ox, oy, x, y);
                                hx = snapped.x;
                                hy = snapped.y;
                            }
                            const dx = hx - ox, dy = hy - oy;
                            if (Math.hypot(dx, dy) > 3) {
                                pt.handleOut = { x: hx, y: hy };
                                pt.handleIn = { x: ox - dx, y: oy - dy };
                            }
                        } else if (this._penDragType === 'handleOut') {
                            let hx = x, hy = y;
                            if (e.shiftKey) {
                                const snapped = this._penSnap45(pt.x, pt.y, x, y);
                                hx = snapped.x;
                                hy = snapped.y;
                            }
                            pt.handleOut = { x: hx, y: hy };
                            pt.handleIn = { x: pt.x * 2 - hx, y: pt.y * 2 - hy };
                        } else if (this._penDragType === 'handleIn') {
                            let hx = x, hy = y;
                            if (e.shiftKey) {
                                const snapped = this._penSnap45(pt.x, pt.y, x, y);
                                hx = snapped.x;
                                hy = snapped.y;
                            }
                            pt.handleIn = { x: hx, y: hy };
                            pt.handleOut = { x: pt.x * 2 - hx, y: pt.y * 2 - hy };
                        } else if (this._penDragType === 'point') {
                            const dx = x - this._penDragStart.x;
                            const dy = y - this._penDragStart.y;
                            pt.x = this._penDragStart.origX + dx;
                            pt.y = this._penDragStart.origY + dy;
                            if (pt.handleIn) {
                                pt.handleIn.x += (x - (this._penDragStart.lastX || this._penDragStart.x));
                                pt.handleIn.y += (y - (this._penDragStart.lastY || this._penDragStart.y));
                            }
                            if (pt.handleOut) {
                                pt.handleOut.x += (x - (this._penDragStart.lastX || this._penDragStart.x));
                                pt.handleOut.y += (y - (this._penDragStart.lastY || this._penDragStart.y));
                            }
                            this._penDragStart.lastX = x;
                            this._penDragStart.lastY = y;
                        }
                    }
                    
                    this._penRenderPreview();
                    return;
                }
                
                if (!this.isDrawing && !this.isTransforming) return;
                
                // Store last mouse event for shape finalization
                this.lastMouseEvent = e;
                
                const canvas = this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Handle lasso
                if (this.tool === 'lasso' && this.isDrawing) {
                    this.lassoPath.push({x, y});
                    this.drawLassoPath();
                    return;
                }
                
                // Handle transform / scale / rotate
                if (this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate' || this.tool === 'skew' || this.tool === 'distort') {
                    if (this.isTransforming) this.performTransform(x, y, e);
                    return;
                }
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    // Convert to world, auto-expand, then frame-local
                    const worldX = x + this.viewportX;
                    const worldY = y + this.viewportY;
                    const layer = this.getCurrentLayer();
                    const frame = layer.frames[this.currentFrameIndex];
                    
                    // Detect frame change during playback â€” reset stroke to avoid cross-frame lines
                    if (this._drawingFrameIndex !== undefined && this._drawingFrameIndex !== this.currentFrameIndex) {
                        // Invalidate thumbnail cache for the frame we just drew on so its keyframe indicator updates
                        const prevFrame = layer.frames[this._drawingFrameIndex];
                        if (prevFrame) this._dirtyThumb(prevFrame);
                        this._drawingFrameIndex = this.currentFrameIndex;
                        // Save undo state for this new frame
                        this.strokeStateSaved = true;
                        this._pendingSnapshot = null;
                        this._preStrokeData = null; // Discard â€” belongs to previous frame
                        setTimeout(() => this.saveState(), 0);
                        // Reset stroke position to current point (new drawPoint, not drawLine)
                        if (frame) {
                            this.ensureFrameCovers(frame, worldX, worldY);
                            const local = this.worldToLocal(worldX, worldY, frame);
                            this.lastX = local.x;
                            this.lastY = local.y;
                            this.smoothX = local.x;
                            this.smoothY = local.y;
                            // Reset point buffer for new frame
                            if (this._strokePoints) {
                                this._strokePoints = [{ x: local.x, y: local.y, pressure: this.currentPressure }];
                            }
                            this.drawPoint(local.x, local.y);
                        }
                        return;
                    }
                    
                    // Expand frame if needed â€” shift stored coords by the growth amount
                    if (frame) {
                        const growth = this.ensureFrameCovers(frame, worldX, worldY);
                        if (growth.dx !== 0 || growth.dy !== 0) {
                            // Frame origin shifted: adjust all stored frame-local positions
                            this.lastX += growth.dx;
                            this.lastY += growth.dy;
                            this.smoothX += growth.dx;
                            this.smoothY += growth.dy;
                            if (this._shiftAnchor) {
                                this._shiftAnchor.x += growth.dx;
                                this._shiftAnchor.y += growth.dy;
                            }
                            if (this._lastStrokeEnd) {
                                this._lastStrokeEnd.x += growth.dx;
                                this._lastStrokeEnd.y += growth.dy;
                            }
                        }
                    }
                    const local = this.worldToLocal(worldX, worldY, frame);
                    let tx = local.x, ty = local.y;
                    
                    // Shift-constrain: lock to axis from anchor point
                    if (this._shiftAnchor) {
                        const c = this.constrainToAxis(this._shiftAnchor.x, this._shiftAnchor.y, tx, ty);
                        tx = c.x;
                        ty = c.y;
                    }
                    
                    const smoothing = this._strokeSmoothing !== undefined ? this._strokeSmoothing : this.getSmoothing();
                    const mode = this._strokeMode || 'standard';
                    
                    // Safety: if pointer teleported (edge glitch during playback, etc.),
                    // start a new stroke segment instead of connecting with a long line.
                    const jumpDx = tx - this.lastX;
                    const jumpDy = ty - this.lastY;
                    const jumpDist = Math.sqrt(jumpDx * jumpDx + jumpDy * jumpDy);
                    const maxJump = Math.max(this.brushSize * 30, 400);
                    if (jumpDist > maxJump) {
                        this.lastX = tx;
                        this.lastY = ty;
                        this.smoothX = tx;
                        this.smoothY = ty;
                        this.drawPoint(tx, ty);
                        if (this._strokePoints) {
                            this._strokePoints.push({ x: tx, y: ty, pressure: this.currentPressure });
                        }
                        return;
                    }
                    
                    if (mode === 'standard') {
                        // Standard mode: real-time EMA smoothing
                        if (smoothing > 0) {
                            const factor = 1 - (smoothing / 100) * 0.95;
                            this.smoothX += (tx - this.smoothX) * factor;
                            this.smoothY += (ty - this.smoothY) * factor;
                            this.drawLine(this.lastX, this.lastY, this.smoothX, this.smoothY);
                            this.lastX = this.smoothX;
                            this.lastY = this.smoothY;
                        } else {
                            this.drawLine(this.lastX, this.lastY, tx, ty);
                            this.lastX = tx;
                            this.lastY = ty;
                        }
                    } else {
                        // Smooth mode: draw raw for instant feedback, collect for post-stroke
                        this.drawLine(this.lastX, this.lastY, tx, ty);
                        this.lastX = tx;
                        this.lastY = ty;
                        this.smoothX = tx;
                        this.smoothY = ty;
                        
                        if (this._strokePoints) {
                            this._strokePoints.push({ x: tx, y: ty, pressure: this.currentPressure });
                        }
                    }
                } else if (this.shapeStart) {
                    // Preview shape (line, rect, circle, triangle)
                    this.drawShape(this.shapeStart.x, this.shapeStart.y, x, y, true, e.shiftKey, e.altKey);
                }
            }
            
            checkRotationHover(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Check if hovering near a corner handle
                let nearCorner = false;
                let hoveredHandle = null;
                
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    
                    const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                     handle.type === 'se' || handle.type === 'sw';
                    
                    const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                    
                    // Larger hover area for rotation detection (20px)
                    if (dist < 20 && isCorner) {
                        nearCorner = true;
                        hoveredHandle = handle;
                        break;
                    }
                }
                
                // Set up hover timer for rotation mode
                if (nearCorner) {
                    // If we're hovering and don't have a timer running, start one
                    if (!this.hoverTimer) {
                        this.hoverHandle = hoveredHandle;
                        
                        // After 500ms of hovering, switch to rotation mode
                        this.hoverTimer = setTimeout(() => {
                            this.rotationMode = true;
                            // Create custom cursor with rotation arrow based on corner
                            this.updateRotationCursor(hoveredHandle.type);
                            this.hoverTimer = null; // Clear timer reference
                        }, 500);
                    }
                } else {
                    // Clear hover state when not near any corner
                    if (this.hoverTimer) {
                        clearTimeout(this.hoverTimer);
                        this.hoverTimer = null;
                    }
                    this.hoverHandle = null;
                    this.rotationMode = false;
                    this.selectionCanvas.style.cursor = 'default';
                }
            }
            
            checkRotateCursor(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                let nearCorner = false;
                let hoveredHandle = null;
                
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                     handle.type === 'se' || handle.type === 'sw';
                    const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                    if (dist < 20 && isCorner) {
                        nearCorner = true;
                        hoveredHandle = handle;
                        break;
                    }
                }
                
                if (nearCorner) {
                    this.updateRotationCursor(hoveredHandle.type);
                } else {
                    this.selectionCanvas.style.cursor = 'default';
                }
            }
            
            updateRotationCursor(cornerType, isActive = false) {
                // Create SVG cursor with rotation arrow based on corner position
                let arrow, rotation;
                
                // Determine which arrow and rotation based on corner
                switch(cornerType) {
                    case 'nw': // Top-left: counter-clockwise arrow
                        arrow = 'â†¶';
                        rotation = 0;
                        break;
                    case 'ne': // Top-right: clockwise arrow
                        arrow = 'â†·';
                        rotation = 0;
                        break;
                    case 'se': // Bottom-right: counter-clockwise arrow
                        arrow = 'â†¶';
                        rotation = 180;
                        break;
                    case 'sw': // Bottom-left: clockwise arrow
                        arrow = 'â†·';
                        rotation = 180;
                        break;
                    default:
                        arrow = 'â†»';
                        rotation = 0;
                }
                
                // Create SVG cursor with visible dark colors
                const svg = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
                        <text x="16" y="20" font-size="26" text-anchor="middle" 
                              transform="rotate(${rotation}, 16, 16)"
                              fill="${isActive ? '#5b8def' : '#222'}" 
                              stroke="#000" 
                              stroke-width="0.5"
                              paint-order="stroke">${arrow}</text>
                    </svg>
                `;
                
                const encodedSvg = encodeURIComponent(svg);
                this.selectionCanvas.style.cursor = `url('data:image/svg+xml;utf8,${encodedSvg}') 16 16, pointer`;
            }
            
            _checkSkewDistortCursor(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                for (const handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    const dist = Math.hypot(x - handle.x, y - handle.y);
                    if (dist < 20) {
                        if (this.tool === 'skew') {
                            const isEdge = handle.type === 'n' || handle.type === 's' || handle.type === 'e' || handle.type === 'w';
                            if (isEdge) {
                                this.selectionCanvas.style.cursor = (handle.type === 'n' || handle.type === 's') ? 'ew-resize' : 'ns-resize';
                            } else {
                                this.selectionCanvas.style.cursor = 'nwse-resize';
                            }
                        } else {
                            this.selectionCanvas.style.cursor = 'move';
                        }
                        return;
                    }
                }
                
                // Inside selection = move
                if (this.tool === 'distort' && this.selection.corners) {
                    if (this._pointInPolygon(x, y, this.selection.corners)) {
                        this.selectionCanvas.style.cursor = 'move';
                        return;
                    }
                } else if (this.isPointInSelection(x, y)) {
                    this.selectionCanvas.style.cursor = 'move';
                    return;
                }
                
                this.selectionCanvas.style.cursor = 'default';
            }
            
            stopDrawing() {
                // Pen tool: just stop dragging (don't finalize)
                if (this.tool === 'pen') {
                    this._penDragIdx = -1;
                    this._penDragType = null;
                    this._penDragStart = null;
                    return;
                }
                
                // Gradient tool: finalize drag â†’ enter edit mode
                if (this.tool === 'gradient' && this.isDrawing) {
                    this.isDrawing = false;
                    
                    // Edit mode: releasing an endpoint drag
                    if (this._gradientEdit && this._gradientEdit.dragging) {
                        this._gradientEdit.dragging = null;
                        this.canvas.style.cursor = 'crosshair';
                        this.selectionCanvas.style.cursor = 'crosshair';
                        this.renderCanvasOnly();
                        return;
                    }
                    
                    if (this._gradientDrag) {
                        const drag = this._gradientDrag;
                        const s = drag.startLocal;
                        const end = drag.endLocal;
                        this._gradientDrag = null;
                        
                        const dist = Math.hypot(end.x - s.x, end.y - s.y);
                        
                        if (dist < 3) {
                            // Short click â€” replay stored gradient if available
                            this._gradientMaskCache = null;
                            if (this.gradientDef) {
                                this.gradientFill(Math.floor(s.x), Math.floor(s.y), this.gradientDef);
                            }
                            this.renderCanvasOnly();
                            return;
                        }
                        
                        // Enter gradient edit mode
                        this._gradientEdit = {
                            startLocal: { ...s },
                            endLocal: { ...end },
                            originX: drag.originX,
                            originY: drag.originY,
                            dragging: null,
                            frameIndex: this.currentFrameIndex,
                            layerId: this.currentLayerId,
                        };
                        this.renderCanvasOnly();
                        return;
                    }
                    return;
                }
                
                if (!this.isDrawing && !this.isTransforming) return;
                
                // Reset stroke state flag for next stroke
                this.strokeStateSaved = false;
                
                // Handle lasso completion
                if (this.tool === 'lasso' && this.isDrawing) {
                    this.isDrawing = false;
                    this.completeLassoSelection();
                    return;
                }
                
                // Handle transform completion
                if ((this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate' || this.tool === 'skew' || this.tool === 'distort') && this.isTransforming) {
                    this.isTransforming = false;
                    this.isRotating = false;
                    if (this.tool === 'transform') this.rotationMode = false;
                    this.activeHandle = null;
                    this.transformStart = null;
                    if (this.hoverTimer) {
                        clearTimeout(this.hoverTimer);
                        this.hoverTimer = null;
                    }
                    this.hoverHandle = null;
                    this.selectionCanvas.style.cursor = 'default';
                    this.render();
                    return;
                }
                
                if (['rect', 'circle', 'triangle'].includes(this.tool) && this.shapeStart) {
                    // Get current mouse position from last draw
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    // Finalize shape by drawing it to the frame
                    const mouseEvent = this.lastMouseEvent;
                    if (mouseEvent) {
                        const x = (mouseEvent.clientX - rect.left) * scaleX;
                        const y = (mouseEvent.clientY - rect.top) * scaleY;
                        this.drawShape(this.shapeStart.x, this.shapeStart.y, x, y, false, mouseEvent.shiftKey, mouseEvent.altKey);
                    }
                }
                
                // Rounded rect: enter radius edit mode instead of finalizing
                if (this.tool === 'roundrect' && this.shapeStart) {
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const mouseEvent = this.lastMouseEvent;
                    if (mouseEvent) {
                        let ex = (mouseEvent.clientX - rect.left) * scaleX;
                        let ey = (mouseEvent.clientY - rect.top) * scaleY;
                        let sx1 = this.shapeStart.x, sy1 = this.shapeStart.y, sx2 = ex, sy2 = ey;
                        
                        if (mouseEvent.shiftKey) {
                            const dx = ex - sx1, dy = ey - sy1;
                            const size = Math.max(Math.abs(dx), Math.abs(dy));
                            sx2 = sx1 + size * Math.sign(dx || 1);
                            sy2 = sy1 + size * Math.sign(dy || 1);
                        }
                        if (mouseEvent.altKey) {
                            const dx = sx2 - sx1, dy = sy2 - sy1;
                            sx1 = this.shapeStart.x - dx;
                            sy1 = this.shapeStart.y - dy;
                            sx2 = this.shapeStart.x + dx;
                            sy2 = this.shapeStart.y + dy;
                        }
                        
                        const w = Math.abs(sx2 - sx1), h = Math.abs(sy2 - sy1);
                        if (w > 2 && h > 2) {
                            const maxR = Math.min(w, h) / 2;
                            this._roundRectEdit = {
                                x1: Math.min(sx1, sx2), y1: Math.min(sy1, sy2),
                                x2: Math.max(sx1, sx2), y2: Math.max(sy1, sy2),
                                radius: maxR * 0.25,
                                maxRadius: maxR
                            };
                            this.isDrawing = false;
                            this.shapeStart = null;
                            this._renderRoundRectPreview();
                            return; // Don't finalize yet
                        }
                    }
                }
                
                // Save last position for shift+click straight line
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    // Post-stroke smoothing: apply Chaikin's corner-cutting to collected points
                    // Skip for shift+click straight lines â€” those should stay perfectly straight
                    const smoothing = this._strokeSmoothing !== undefined ? this._strokeSmoothing : this.getSmoothing();
                    if (smoothing > 0 && !this._skipPostSmooth && this._strokePoints && this._strokePoints.length >= 3 && this._preStrokeData) {
                        this._applyPostStrokeSmoothing(smoothing);
                    }
                    this._lastStrokeEnd = { x: this.lastX, y: this.lastY };
                }
                
                this.isDrawing = false;
                // Capture which frame we were actually drawing on before clearing
                const _drawingFrame = this._drawingFrameIndex;
                this._drawingFrameIndex = undefined;
                this.shapeStart = null;
                this._shiftAnchor = null;
                this._shiftLockedAngle = null;
                // Clear cached per-stroke values
                this._strokeShape = undefined;
                this._strokeSmoothing = undefined;
                this._strokeCompositeOp = undefined;
                this._strokeColor = undefined;
                this._strokeMode = undefined;
                this._strokePoints = null;
                this._preStrokeData = null;
                this._skipPostSmooth = false;
                // Invalidate thumbnail cache so timeline indicators update
                const _layer = this.getCurrentLayer();
                if (_layer) this._dirtyThumb(_layer.frames[this.currentFrameIndex]);
                // Also dirty the frame we were actually drawing on (may differ during playback)
                if (_layer && _drawingFrame !== undefined && _drawingFrame !== this.currentFrameIndex) {
                    this._dirtyThumb(_layer.frames[_drawingFrame]);
                }
                this.render();
            }
            
            drawPoint(x, y) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const shape = this._strokeShape || this.getCurrentBrushShape();
                const size = this.getPressureBrushSize();
                const radius = size / 2;
                const compositeOp = this._strokeCompositeOp || (this.tool === 'eraser' ? 'destination-out' : 'source-over');
                const color = this._strokeColor || this.color;
                
                frameCtx.globalCompositeOperation = compositeOp;
                frameCtx.fillStyle = color;
                if (shape === 'square') {
                    frameCtx.fillRect(x - radius, y - radius, size, size);
                } else if (shape === 'oval-h') {
                    frameCtx.beginPath();
                    frameCtx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
                    frameCtx.fill();
                } else if (shape === 'oval-v') {
                    frameCtx.beginPath();
                    frameCtx.ellipse(x, y, radius * 0.4, radius, 0, 0, Math.PI * 2);
                    frameCtx.fill();
                } else {
                    frameCtx.beginPath();
                    frameCtx.arc(x, y, radius, 0, Math.PI * 2);
                    frameCtx.fill();
                }
                frameCtx.globalCompositeOperation = 'source-over';
                
                // Draw on display canvas with viewport offset
                const off = this.frameToDisplayOffset(frame);
                this.ctx.save();
                this.ctx.translate(off.x, off.y);
                this.ctx.globalCompositeOperation = compositeOp;
                this.ctx.fillStyle = color;
                if (shape === 'square') {
                    this.ctx.fillRect(x - radius, y - radius, size, size);
                } else if (shape === 'oval-h') {
                    this.ctx.beginPath();
                    this.ctx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (shape === 'oval-v') {
                    this.ctx.beginPath();
                    this.ctx.ellipse(x, y, radius * 0.4, radius, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.restore();
            }
            
            drawLine(x1, y1, x2, y2) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const shape = this._strokeShape || this.getCurrentBrushShape();
                const size = this.getPressureBrushSize();
                const off = this.frameToDisplayOffset(frame);
                const compositeOp = this._strokeCompositeOp || (this.tool === 'eraser' ? 'destination-out' : 'source-over');
                const color = this._strokeColor || this.color;
                
                if (shape === 'oval-h' || shape === 'oval-v') {
                    const rx = shape === 'oval-h' ? size / 2 : size * 0.2;
                    const ry = shape === 'oval-v' ? size / 2 : size * 0.2;
                    const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const step = Math.max(1, Math.min(rx, ry) * 0.3);
                    const steps = Math.max(1, Math.ceil(dist / step));
                    
                    // Draw to frame canvas (frame-local coords)
                    frameCtx.globalCompositeOperation = compositeOp;
                    frameCtx.fillStyle = color;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const px = x1 + (x2 - x1) * t;
                        const py = y1 + (y2 - y1) * t;
                        frameCtx.beginPath();
                        frameCtx.ellipse(px, py, rx, ry, 0, 0, Math.PI * 2);
                        frameCtx.fill();
                    }
                    frameCtx.globalCompositeOperation = 'source-over';
                    
                    // Draw to display canvas (with viewport offset)
                    this.ctx.save();
                    this.ctx.translate(off.x, off.y);
                    this.ctx.globalCompositeOperation = compositeOp;
                    this.ctx.fillStyle = color;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const px = x1 + (x2 - x1) * t;
                        const py = y1 + (y2 - y1) * t;
                        this.ctx.beginPath();
                        this.ctx.ellipse(px, py, rx, ry, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.restore();
                } else {
                    const cap = shape === 'square' ? 'square' : 'round';
                    const join = shape === 'square' ? 'miter' : 'round';
                    
                    // Draw to frame canvas
                    frameCtx.globalCompositeOperation = compositeOp;
                    frameCtx.strokeStyle = color;
                    frameCtx.lineWidth = size;
                    frameCtx.lineCap = cap;
                    frameCtx.lineJoin = join;
                    frameCtx.beginPath();
                    frameCtx.moveTo(x1, y1);
                    frameCtx.lineTo(x2, y2);
                    frameCtx.stroke();
                    frameCtx.globalCompositeOperation = 'source-over';
                    
                    // Draw to display canvas with viewport offset
                    this.ctx.save();
                    this.ctx.translate(off.x, off.y);
                    this.ctx.globalCompositeOperation = compositeOp;
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = size;
                    this.ctx.lineCap = cap;
                    this.ctx.lineJoin = join;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.restore();
                }
            }
            
            // Post-stroke smoothing: restore frame, decimate + smooth points, redraw
            _applyPostStrokeSmoothing(smoothing) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (!frame || !this._preStrokeData) return;
                
                const preData = this._preStrokeData;
                
                // Determine decimation and Chaikin passes from smoothing slider
                // Higher smoothing = more aggressive decimation (fewer points = longer segments = more rounding)
                // Plus more Chaikin passes for additional curve refinement
                const t = smoothing / 100; // 0 to 1
                
                // Decimation: keep every Nth point. At 100%, keep every ~12th point.
                // This creates real corners for Chaikin to work with.
                const keepEvery = Math.max(1, Math.round(1 + t * 11));
                
                // Chaikin passes: 2-4 based on smoothing level
                const passes = Math.max(2, Math.min(4, Math.ceil(t * 4)));
                
                // Decimate: sample every Nth point, always keeping first and last
                let points = this._strokePoints;
                if (points.length < 3) return;
                
                let decimated = [points[0]];
                for (let i = keepEvery; i < points.length - 1; i += keepEvery) {
                    decimated.push(points[i]);
                }
                decimated.push(points[points.length - 1]);
                
                // Need at least 3 points for meaningful smoothing
                if (decimated.length < 3) {
                    // Too few points after decimation â€” use less aggressive decimation
                    decimated = [points[0]];
                    const fallbackN = Math.max(1, Math.floor(keepEvery / 2));
                    for (let i = fallbackN; i < points.length - 1; i += fallbackN) {
                        decimated.push(points[i]);
                    }
                    decimated.push(points[points.length - 1]);
                }
                
                if (decimated.length < 3) return; // Still too short
                
                // Apply Chaikin smoothing to decimated points
                let smoothed = this._chaikinSmooth(decimated, passes);
                
                // Restore frame to pre-stroke state
                if (frame.width !== preData.width || frame.height !== preData.height) {
                    frame.width = preData.width;
                    frame.height = preData.height;
                }
                frame._originX = preData.originX || 0;
                frame._originY = preData.originY || 0;
                const ctx = frame.getContext('2d');
                ctx.clearRect(0, 0, frame.width, frame.height);
                ctx.putImageData(preData.imageData, 0, 0);
                
                // Ensure frame covers all smoothed points (may need to re-expand)
                for (const pt of smoothed) {
                    const worldX = pt.x + (frame._originX || 0);
                    const worldY = pt.y + (frame._originY || 0);
                    const growth = this.ensureFrameCovers(frame, worldX, worldY);
                    if (growth.dx !== 0 || growth.dy !== 0) {
                        for (const p of smoothed) {
                            p.x += growth.dx;
                            p.y += growth.dy;
                        }
                    }
                }
                
                // Redraw the smoothed path
                const savedPressure = this.currentPressure;
                this.currentPressure = smoothed[0].pressure;
                this.drawPoint(smoothed[0].x, smoothed[0].y);
                
                for (let i = 1; i < smoothed.length; i++) {
                    this.currentPressure = smoothed[i].pressure;
                    this.drawLine(smoothed[i - 1].x, smoothed[i - 1].y, smoothed[i].x, smoothed[i].y);
                }
                
                const last = smoothed[smoothed.length - 1];
                this.lastX = last.x;
                this.lastY = last.y;
                this.currentPressure = savedPressure;
            }
            
            // Chaikin's corner-cutting algorithm
            // Each pass replaces each segment with two new points at 25% and 75%,
            // preserving endpoints. Pressure is interpolated along with position.
            _chaikinSmooth(points, passes) {
                let pts = points;
                for (let pass = 0; pass < passes; pass++) {
                    const next = [];
                    next.push(pts[0]); // keep first
                    for (let i = 0; i < pts.length - 1; i++) {
                        const p0 = pts[i], p1 = pts[i + 1];
                        next.push({
                            x: p0.x * 0.75 + p1.x * 0.25,
                            y: p0.y * 0.75 + p1.y * 0.25,
                            pressure: p0.pressure * 0.75 + p1.pressure * 0.25
                        });
                        next.push({
                            x: p0.x * 0.25 + p1.x * 0.75,
                            y: p0.y * 0.25 + p1.y * 0.75,
                            pressure: p0.pressure * 0.25 + p1.pressure * 0.75
                        });
                    }
                    next.push(pts[pts.length - 1]); // keep last
                    pts = next;
                }
                return pts;
            }
            
            drawShape(x1, y1, x2, y2, preview = false, shiftKey = false, altKey = false) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                
                // Constrain aspect ratio when shift is held
                let sx1 = x1, sy1 = y1, sx2 = x2, sy2 = y2;
                if (shiftKey) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    
                    if (this.tool === 'pen') {
                        // Pen tool handled separately
                        return;
                    } else {
                        // Force square aspect ratio for rect, circle, triangle
                        const size = Math.max(absDx, absDy);
                        sx2 = x1 + size * Math.sign(dx || 1);
                        sy2 = y1 + size * Math.sign(dy || 1);
                    }
                }
                
                // Draw from center when alt/option is held
                if (altKey && this.tool !== 'pen') {
                    const dx = sx2 - sx1;
                    const dy = sy2 - sy1;
                    sx1 = x1 - dx;
                    sy1 = y1 - dy;
                    sx2 = x1 + dx;
                    sy2 = y1 + dy;
                }
                
                const drawShapeOnCtx = (ctx) => {
                    if (this.tool === 'rect') {
                        ctx.strokeRect(sx1, sy1, sx2 - sx1, sy2 - sy1);
                    } else if (this.tool === 'roundrect') {
                        const rr = this._roundRectEdit;
                        const r = rr ? rr.radius : Math.min(Math.abs(sx2 - sx1), Math.abs(sy2 - sy1)) * 0.15;
                        ctx.beginPath();
                        ctx.roundRect(sx1, sy1, sx2 - sx1, sy2 - sy1, r);
                        ctx.stroke();
                    } else if (this.tool === 'circle') {
                        // Draw ellipse inscribed in bounding box (corner-to-corner)
                        const cx = (sx1 + sx2) / 2;
                        const cy = (sy1 + sy2) / 2;
                        const rx = Math.abs(sx2 - sx1) / 2;
                        const ry = Math.abs(sy2 - sy1) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (this.tool === 'triangle') {
                        const midX = (sx1 + sx2) / 2;
                        ctx.beginPath();
                        ctx.moveTo(midX, sy1);
                        ctx.lineTo(sx2, sy2);
                        ctx.lineTo(sx1, sy2);
                        ctx.closePath();
                        ctx.stroke();
                    }
                };
                
                if (preview) {
                    // Clear and redraw everything for preview
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw all visible layers (cached if possible)
                    const _playheadPos = this.getPlayheadPosition();
                    if (this.layers.length > 2) {
                        this._drawWithCompositeCache(this.ctx, _playheadPos);
                    } else {
                        for (const l of this.layers) {
                            this.drawLayerWithTransform(this.ctx, l, _playheadPos);
                        }
                    }
                    
                    // Now draw the preview shape on top
                    this.ctx.strokeStyle = this.color;
                    this.ctx.lineWidth = this.brushSize;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.globalCompositeOperation = 'source-over';
                    drawShapeOnCtx(this.ctx);
                    this.drawPasteboardOverlay(this.ctx);
                } else {
                    // Draw final shape to frame â€” convert canvas-pixel coords to frame-local
                    // Ensure frame covers all shape points (for pasteboard drawing)
                    const worldX1 = sx1 + this.viewportX, worldY1 = sy1 + this.viewportY;
                    const worldX2 = sx2 + this.viewportX, worldY2 = sy2 + this.viewportY;
                    if (frame) {
                        this.ensureFrameCovers(frame, Math.min(worldX1, worldX2), Math.min(worldY1, worldY2));
                        this.ensureFrameCovers(frame, Math.max(worldX1, worldX2), Math.max(worldY1, worldY2));
                    }
                    
                    const frameCtx = frame.getContext('2d');
                    const fOx = (frame._originX || 0) - this.viewportX;
                    const fOy = (frame._originY || 0) - this.viewportY;
                    frameCtx.save();
                    frameCtx.translate(-fOx, -fOy);
                    frameCtx.strokeStyle = this.color;
                    frameCtx.lineWidth = this.brushSize;
                    frameCtx.lineCap = 'round';
                    frameCtx.lineJoin = 'round';
                    frameCtx.globalCompositeOperation = 'source-over';
                    drawShapeOnCtx(frameCtx);
                    frameCtx.restore();
                }
            }
            
            // === Rounded Rect Radius Edit Mode ===
            
            _renderRoundRectPreview() {
                if (!this._roundRectEdit) return;
                const rr = this._roundRectEdit;
                
                // Clear and redraw everything
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const _playheadPos = this.getPlayheadPosition();
                if (this.layers.length > 2) {
                    this._drawWithCompositeCache(this.ctx, _playheadPos);
                } else {
                    for (const l of this.layers) {
                        this.drawLayerWithTransform(this.ctx, l, _playheadPos);
                    }
                }
                
                // Draw the rounded rect preview
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = this.brushSize;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.beginPath();
                this.ctx.roundRect(rr.x1, rr.y1, rr.x2 - rr.x1, rr.y2 - rr.y1, rr.radius);
                this.ctx.stroke();
                
                // Draw radius handle (small circle at top-left corner + radius offset)
                const handleX = rr.x1 + rr.radius;
                const handleY = rr.y1;
                const handleR = Math.max(4, this.brushSize * 0.6);
                
                // Draw guide line from corner to handle
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(106, 173, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([3, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(rr.x1, rr.y1);
                this.ctx.lineTo(handleX, handleY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw handle dot
                this.ctx.fillStyle = '#6aadff';
                this.ctx.strokeStyle = '#2b2d31';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(handleX, handleY, handleR, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Draw radius label
                const rPx = Math.round(rr.radius);
                this.ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                this.ctx.fillStyle = 'rgba(106, 173, 255, 0.9)';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'bottom';
                this.ctx.fillText(`r: ${rPx}px`, handleX + handleR + 4, handleY - 2);
                
                // Draw hint text at bottom of rect
                this.ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
                this.ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('Drag to adjust radius Â· Click or Enter to confirm Â· Esc to cancel',
                    (rr.x1 + rr.x2) / 2, rr.y2 + 8 + this.brushSize / 2);
                
                this.ctx.restore();
                this.drawPasteboardOverlay(this.ctx);
            }
            
            _roundRectHandleMouseMove(e) {
                if (!this._roundRectEdit) return;
                const rr = this._roundRectEdit;
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;
                
                // Radius = distance from nearest corner along the edge
                // Use distance from top-left corner for simplicity
                const cx = rr.x1, cy = rr.y1;
                const dist = Math.hypot(mx - cx, my - cy);
                rr.radius = Math.max(0, Math.min(dist, rr.maxRadius));
                
                this._renderRoundRectPreview();
            }
            
            _finalizeRoundRect() {
                if (!this._roundRectEdit) return;
                const rr = this._roundRectEdit;
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                
                // Ensure frame covers the shape
                const worldX1 = rr.x1 + this.viewportX, worldY1 = rr.y1 + this.viewportY;
                const worldX2 = rr.x2 + this.viewportX, worldY2 = rr.y2 + this.viewportY;
                if (frame) {
                    this.ensureFrameCovers(frame, worldX1, worldY1);
                    this.ensureFrameCovers(frame, worldX2, worldY2);
                }
                
                const frameCtx = frame.getContext('2d');
                const fOx = (frame._originX || 0) - this.viewportX;
                const fOy = (frame._originY || 0) - this.viewportY;
                frameCtx.save();
                frameCtx.translate(-fOx, -fOy);
                frameCtx.strokeStyle = this.color;
                frameCtx.lineWidth = this.brushSize;
                frameCtx.lineCap = 'round';
                frameCtx.lineJoin = 'round';
                frameCtx.globalCompositeOperation = 'source-over';
                frameCtx.beginPath();
                frameCtx.roundRect(rr.x1, rr.y1, rr.x2 - rr.x1, rr.y2 - rr.y1, rr.radius);
                frameCtx.stroke();
                frameCtx.restore();
                
                this._roundRectEdit = null;
                this._dirtyThumb(frame);
                this.render();
            }
            
            _cancelRoundRect() {
                if (!this._roundRectEdit) return;
                this._roundRectEdit = null;
                this.render();
            }
            
            // === Pen Tool Methods ===
            
            _penBuildPath(ctx, points, close) {
                if (points.length < 1) return;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const cp1 = prev.handleOut || prev;
                    const cp2 = curr.handleIn || curr;
                    
                    if (cp1 === prev && cp2 === curr) {
                        ctx.lineTo(curr.x, curr.y);
                    } else {
                        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                    }
                }
                
                if (close && points.length > 1) {
                    const last = points[points.length - 1];
                    const first = points[0];
                    const cp1 = last.handleOut || last;
                    const cp2 = first.handleIn || first;
                    if (cp1 === last && cp2 === first) {
                        ctx.lineTo(first.x, first.y);
                    } else {
                        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, first.x, first.y);
                    }
                    ctx.closePath();
                }
            }
            
            _penRenderPreview() {
                const points = this._penPoints;
                if (points.length === 0) return;
                
                // Redraw canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const playheadPos = this.getPlayheadPosition();
                if (this.layers.length > 2) {
                    this._drawWithCompositeCache(this.ctx, playheadPos);
                } else {
                    for (const layer of this.layers) {
                        this.drawLayerWithTransform(this.ctx, layer, playheadPos);
                    }
                }
                this.drawPasteboardOverlay(this.ctx);
                
                // Draw the path
                this.ctx.save();
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = this.brushSize;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this._penBuildPath(this.ctx, points, false);
                
                // Preview segment from last point to mouse
                if (this._penMousePos && this._penDragIdx < 0 && points.length >= 1) {
                    const last = points[points.length - 1];
                    const first = points[0];
                    
                    // Shift: snap preview target to 45Â° from last point
                    let mouseTarget = this._penMousePos;
                    if (this._penShiftHeld && points.length >= 1) {
                        mouseTarget = this._penSnap45(last.x, last.y, this._penMousePos.x, this._penMousePos.y);
                    }
                    
                    const distLast = Math.hypot(mouseTarget.x - last.x, mouseTarget.y - last.y);
                    const distFirst = points.length >= 2 ? Math.hypot(this._penMousePos.x - first.x, this._penMousePos.y - first.y) : Infinity;
                    const hitR = 10 * (this.canvas.width / this.canvas.getBoundingClientRect().width);
                    
                    if (distLast > hitR) {
                        // Near first point: show closing segment snapped to first point
                        const target = (distFirst < hitR) ? first : mouseTarget;
                        const cp1 = last.handleOut || last;
                        const cp2 = (distFirst < hitR && first.handleIn) ? first.handleIn : target;
                        if (cp1 === last && cp2 === target) {
                            this.ctx.lineTo(target.x, target.y);
                        } else {
                            this.ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, target.x, target.y);
                        }
                    }
                }
                
                this.ctx.stroke();
                this.ctx.restore();
                
                // Draw control points overlay
                const dpr = this.canvas.width / this.canvas.getBoundingClientRect().width;
                const ptRadius = 4 * dpr;
                const handleRadius = 3 * dpr;
                
                for (let i = 0; i < points.length; i++) {
                    const pt = points[i];
                    
                    // Handle lines + dots
                    this.ctx.save();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = 'rgba(0,180,255,0.7)';
                    
                    if (pt.handleIn) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(pt.x, pt.y);
                        this.ctx.lineTo(pt.handleIn.x, pt.handleIn.y);
                        this.ctx.stroke();
                        // Handle dot
                        this.ctx.fillStyle = '#0bf';
                        this.ctx.beginPath();
                        this.ctx.arc(pt.handleIn.x, pt.handleIn.y, handleRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    if (pt.handleOut) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(pt.x, pt.y);
                        this.ctx.lineTo(pt.handleOut.x, pt.handleOut.y);
                        this.ctx.stroke();
                        this.ctx.fillStyle = '#0bf';
                        this.ctx.beginPath();
                        this.ctx.arc(pt.handleOut.x, pt.handleOut.y, handleRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    this.ctx.restore();
                    
                    // Anchor point square
                    this.ctx.save();
                    this.ctx.fillStyle = i === 0 ? '#fff' : '#0bf';
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 1;
                    const s = ptRadius;
                    this.ctx.fillRect(pt.x - s, pt.y - s, s * 2, s * 2);
                    this.ctx.strokeRect(pt.x - s, pt.y - s, s * 2, s * 2);
                    this.ctx.restore();
                }
                
                // Close indicator: circle around first point when mouse is near
                if (points.length >= 2 && this._penMousePos) {
                    const fp = points[0];
                    const lp = points[points.length - 1];
                    const hitRadius = 10 * dpr;
                    const distFirst = Math.hypot(this._penMousePos.x - fp.x, this._penMousePos.y - fp.y);
                    const distLast = Math.hypot(this._penMousePos.x - lp.x, this._penMousePos.y - lp.y);
                    
                    if (distFirst < hitRadius) {
                        // Green circle = close path
                        this.ctx.save();
                        this.ctx.strokeStyle = '#0f0';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(fp.x, fp.y, ptRadius + 4, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.restore();
                    } else if (distLast < hitRadius) {
                        // Orange circle = finalize open path
                        this.ctx.save();
                        this.ctx.strokeStyle = '#f90';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(lp.x, lp.y, ptRadius + 4, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
                
                // Update floating confirm/cancel buttons position
                this._penUpdateConfirmBtns();
            }
            
            // Snap a point to the nearest 45Â° angle relative to a reference point
            // Returns { x, y } snapped position
            _penSnap45(fromX, fromY, toX, toY) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const dist = Math.hypot(dx, dy);
                if (dist < 1) return { x: toX, y: toY };
                
                const angle = Math.atan2(dy, dx);
                // Snap to nearest 45Â° (Ï€/4) increment
                const snapped = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                return {
                    x: fromX + Math.cos(snapped) * dist,
                    y: fromY + Math.sin(snapped) * dist,
                };
            }
            
            _penUpdateConfirmBtns() {
                const btns = this._penConfirmBtns;
                if (!this._penActive || this._penPoints.length < 2) {
                    btns.classList.remove('show');
                    return;
                }
                // Position near the last anchor point in screen space
                const last = this._penPoints[this._penPoints.length - 1];
                const rect = this.canvas.getBoundingClientRect();
                const sx = rect.width / this.canvas.width;
                const sy = rect.height / this.canvas.height;
                // Convert canvas coords to container-relative coords
                const containerRect = this.canvasContainer.getBoundingClientRect();
                let screenX = rect.left + last.x * sx - containerRect.left;
                let screenY = rect.top + last.y * sy - containerRect.top;
                // Offset: place buttons to the right and slightly above
                const offsetX = 24;
                const offsetY = -20;
                let bx = screenX + offsetX;
                let by = screenY + offsetY;
                // Clamp to stay within container bounds
                const bw = 74; // approx width of 2 buttons + gap
                const bh = 34;
                bx = Math.max(4, Math.min(bx, containerRect.width - bw - 4));
                by = Math.max(4, Math.min(by, containerRect.height - bh - 4));
                btns.style.left = bx + 'px';
                btns.style.top = by + 'px';
                btns.classList.add('show');
            }
            
            _penHideConfirmBtns() {
                this._penConfirmBtns.classList.remove('show');
            }
            
            _penFinalize(close) {
                this._penHideConfirmBtns();
                this._penFinalizeTime = performance.now();
                if (this._penPoints.length < 2) {
                    this._penCancel();
                    return;
                }
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (!frame) return;
                
                // Auto-expand frame to cover all pen points
                for (const pt of this._penPoints) {
                    const wx = pt.x + this.viewportX;
                    const wy = pt.y + this.viewportY;
                    this.ensureFrameCovers(frame, wx, wy);
                    if (pt.handleIn) this.ensureFrameCovers(frame, pt.handleIn.x + this.viewportX, pt.handleIn.y + this.viewportY);
                    if (pt.handleOut) this.ensureFrameCovers(frame, pt.handleOut.x + this.viewportX, pt.handleOut.y + this.viewportY);
                }
                
                const frameCtx = frame.getContext('2d');
                const fOx = (frame._originX || 0) - this.viewportX;
                const fOy = (frame._originY || 0) - this.viewportY;
                frameCtx.save();
                frameCtx.translate(-fOx, -fOy);
                frameCtx.strokeStyle = this.color;
                frameCtx.lineWidth = this.brushSize;
                frameCtx.lineCap = 'round';
                frameCtx.lineJoin = 'round';
                frameCtx.globalCompositeOperation = 'source-over';
                
                this._penBuildPath(frameCtx, this._penPoints, close);
                frameCtx.stroke();
                frameCtx.restore();
                
                this._penPoints = [];
                this._penActive = false;
                this._penDragIdx = -1;
                this._penDragType = null;
                this._penMousePos = null;
                this._dirtyThumb(frame);
                this.render();
            }
            
            _penCancel() {
                this._penHideConfirmBtns();
                this._penFinalizeTime = performance.now();
                this._penPoints = [];
                this._penActive = false;
                this._penDragIdx = -1;
                this._penDragType = null;
                this._penMousePos = null;
                this.undo(); // Revert the state save from pen start
                this.render();
            }
            
            clearCurrentFrame() {
                const layer = this.getCurrentLayer();
                
                // If multiple frames are selected, clear all of them
                if (this.selectedFrames.size > 1) {
                    this.saveFullState(); // full state since multiple frames change
                    for (const fi of this.selectedFrames) {
                        if (fi >= 0 && fi < layer.frames.length) {
                            layer.frames[fi] = this.createEmptyFrame();
                            this._dirtyThumb(layer.frames[fi]);
                        }
                    }
                    this.selectedFrames.clear();
                    if (this.frameSelectMode) {
                        this.frameSelectMode = false;
                        document.getElementById('frameSelectBanner').classList.remove('show');
                    }
                    this._timelineDirty = true;
                    this.initializeFrame();
                    this.render();
                    return;
                }
                
                // Single frame clear
                // If this is a hold frame, clearing breaks the link â€” need full state save
                if (this.isHoldFrame(layer, this.currentFrameIndex)) {
                    this.saveFullState(); // marks dirty
                } else {
                    this.saveState();
                    this._timelineDirty = true; // new canvas replaces old
                }
                layer.frames[this.currentFrameIndex] = this.createEmptyFrame();
                this._dirtyThumb(layer.frames[this.currentFrameIndex]);
                this.initializeFrame();
                this.render();
            }
            
            // Render a tinted version of a frame onto the onion canvas
            drawOnionFrame(frame, tintColor, opacity) {
                // --- Onion skin tint caching ---
                // Cache the tinted version of each frame at its native size.
                // Only re-tint when frame pixels change (_thumbVer) or tint color changes.
                // Viewport offset is applied at draw time, so panning doesn't invalidate.
                if (!frame._onionCaches) frame._onionCaches = {};
                const ver = frame._thumbVer || 0;
                let cached = frame._onionCaches[tintColor];
                
                if (!cached || cached._ver !== ver) {
                    // Build tinted canvas at frame's native size
                    const tinted = document.createElement('canvas');
                    tinted.width = frame.width;
                    tinted.height = frame.height;
                    const tctx = tinted.getContext('2d');
                    tctx.drawImage(frame, 0, 0);
                    tctx.globalCompositeOperation = 'source-atop';
                    tctx.globalAlpha = 0.5;
                    tctx.fillStyle = tintColor;
                    tctx.fillRect(0, 0, frame.width, frame.height);
                    tctx.globalAlpha = 1;
                    tctx.globalCompositeOperation = 'source-over';
                    tinted._ver = ver;
                    frame._onionCaches[tintColor] = tinted;
                    cached = tinted;
                }
                
                // Draw cached tinted frame at viewport offset
                const offX = (frame._originX || 0) - this.viewportX;
                const offY = (frame._originY || 0) - this.viewportY;
                this.onionCtx.globalAlpha = opacity;
                this.onionCtx.drawImage(cached, offX, offY);
                this.onionCtx.globalAlpha = 1;
            }
            
            addLayer() {
                this.commitSelection();
                this.saveFullState();
                
                const newLayer = {
                    id: this.nextLayerId++,
                    name: `Layer ${this.layers.length + 1}`,
                    visible: true,
                    opacity: 1.0,
                    frames: [],
                    transformKeyframes: [],
                    startFrame: 0,
                    parentId: null
                };
                
                // Insert above (after in array) the current layer
                const currentIdx = this.layers.findIndex(l => l.id === this.currentLayerId);
                if (currentIdx >= 0) {
                    this.layers.splice(currentIdx + 1, 0, newLayer);
                } else {
                    this.layers.push(newLayer);
                }
                
                this.currentLayerId = newLayer.id;
                this.initializeFrame();
                this.render();
            }
            
            duplicateLayer() {
                this.commitSelection();
                this.saveFullState();
                
                const currentLayer = this.getCurrentLayer();
                // Map original canvas â†’ cloned canvas to preserve hold frame shared references
                const canvasMap = new Map();
                const newLayer = {
                    id: this.nextLayerId++,
                    name: currentLayer.name + ' copy',
                    visible: currentLayer.visible,
                    opacity: currentLayer.opacity,
                    frames: currentLayer.frames.map(frame => {
                        if (!frame) return null;
                        // If we already cloned this canvas, reuse it (hold frame)
                        if (canvasMap.has(frame)) return canvasMap.get(frame);
                        const copy = document.createElement('canvas');
                        copy.width = frame.width;
                        copy.height = frame.height;
                        copy._originX = frame._originX || 0;
                        copy._originY = frame._originY || 0;
                        copy.getContext('2d').drawImage(frame, 0, 0);
                        canvasMap.set(frame, copy);
                        return copy;
                    }),
                    transformKeyframes: (currentLayer.transformKeyframes || []).map(kf => ({...kf})),
                    startFrame: currentLayer.startFrame || 0,
                    parentId: currentLayer.parentId || null
                };
                
                // Insert after current layer
                const idx = this.layers.findIndex(l => l.id === this.currentLayerId);
                this.layers.splice(idx + 1, 0, newLayer);
                this.currentLayerId = newLayer.id;
                this.initializeFrame();
                this.render();
            }
            
            deleteLayer() {
                // If audio layer is selected, remove the audio track
                if (this.audioLayerSelected && this.audioTracks.length > 0) {
                    this.removeAudio();
                    this.audioLayerSelected = false;
                    this.render();
                    return;
                }
                
                // Don't delete if it's the only layer
                if (this.layers.length <= 1) {
                    alert('Cannot delete the only layer. Create another layer first.');
                    return;
                }
                
                this.commitSelection();
                this.saveFullState();
                
                // Find index of current layer
                const layerIndex = this.layers.findIndex(l => l.id === this.currentLayerId);
                
                // Remove the layer
                const deletedId = this.layers[layerIndex].id;
                this.layers.splice(layerIndex, 1);
                
                // Unparent any layers that were children of the deleted layer
                for (const l of this.layers) {
                    if (l.parentId === deletedId) l.parentId = null;
                }
                
                // Select a different layer
                if (layerIndex >= this.layers.length) {
                    // If we deleted the last layer, select the new last layer
                    this.currentLayerId = this.layers[this.layers.length - 1].id;
                } else {
                    // Select the layer that took this position
                    this.currentLayerId = this.layers[layerIndex].id;
                }
                
                this.initializeFrame();
                this.render();
            }
            
            enterFrameSelectMode(initialFrameIdx) {
                this.frameSelectMode = true;
                this.selectedFrames.clear();
                if (initialFrameIdx !== undefined) {
                    this.selectedFrames.add(initialFrameIdx);
                }
                this._updateSelectBanner();
                document.getElementById('frameSelectBanner').classList.add('show');
                this._timelineDirty = true;
                this.renderTimeline();
            }
            
            exitFrameSelectMode() {
                this.frameSelectMode = false;
                this.selectedFrames.clear();
                this._longPressTimer = null;
                document.getElementById('frameSelectBanner').classList.remove('show');
                this._timelineDirty = true;
                this.renderTimeline();
            }
            
            _updateSelectBanner() {
                const count = this.selectedFrames.size;
                const el = document.getElementById('frameSelectCount');
                if (count === 0) {
                    el.textContent = 'Tap frames to select';
                } else {
                    el.textContent = count + ' frame' + (count > 1 ? 's' : '') + ' selected';
                }
            }
            
            previousFrame() {
                if (this.selection) { this._dismissTransform(); }
                if (this.frameSelectMode) this.exitFrameSelectMode();
                else this.selectedFrames.clear();
                if (this.currentFrameIndex > 0) {
                    this.currentFrameIndex--;
                    this.initializeFrame();
                    this.render();
                    this.scrubAudio(this.getPlayheadPosition());
                }
            }
            
            goToFirstFrame() {
                if (this.selection) { this._dismissTransform(); }
                if (this.frameSelectMode) this.exitFrameSelectMode();
                else this.selectedFrames.clear();
                if (this.currentFrameIndex !== 0) {
                    this.currentFrameIndex = 0;
                    this.initializeFrame();
                    this.render();
                    this.scrubAudio(this.getPlayheadPosition());
                }
                const framesSection = document.getElementById('timelineFramesSection');
                if (framesSection) framesSection.scrollLeft = 0;
            }
            
            goToLastFrame() {
                if (this.selection) { this._dismissTransform(); }
                if (this.frameSelectMode) this.exitFrameSelectMode();
                else this.selectedFrames.clear();
                const layer = this.getCurrentLayer();
                const lastIdx = layer.frames.length - 1;
                if (this.currentFrameIndex !== lastIdx) {
                    this.currentFrameIndex = lastIdx;
                    this.initializeFrame();
                    this.render();
                    this.scrubAudio(this.getPlayheadPosition());
                }
                const framesSection = document.getElementById('timelineFramesSection');
                if (framesSection) framesSection.scrollLeft = framesSection.scrollWidth;
            }
            
            goToNextFrame() {
                if (this.selection) { this._dismissTransform(); }
                if (this.frameSelectMode) this.exitFrameSelectMode();
                else this.selectedFrames.clear();
                const layer = this.getCurrentLayer();
                if (this.currentFrameIndex < layer.frames.length - 1) {
                    this.currentFrameIndex++;
                    this.initializeFrame();
                    this.render();
                    this.scrubAudio(this.getPlayheadPosition());
                }
            }
            
            nextFrame() {
                if (this.selection) { this._dismissTransform(); }
                if (this.frameSelectMode) this.exitFrameSelectMode();
                else this.selectedFrames.clear();
                const layer = this.getCurrentLayer();
                if (this.currentFrameIndex < layer.frames.length - 1) {
                    this.currentFrameIndex++;
                    this.initializeFrame();
                    this.render();
                    this.scrubAudio(this.getPlayheadPosition());
                }
            }
            
            insertFrameAfterCurrent() {
                if (this.selection) { this._dismissTransform(); }
                else { this.commitSelection(); }
                this.saveFullState();
                this._timelineDirty = true;
                const layer = this.getCurrentLayer();
                const newFrame = this.createEmptyFrame();
                const newFrameIndex = this.currentFrameIndex + 1;
                layer.frames.splice(newFrameIndex, 0, newFrame);
                this.currentFrameIndex = newFrameIndex;
                this.render();
                this._scrollTimelineToFrame(this.currentFrameIndex);
            }
            
            holdFrame() {
                if (this.selection) { this._dismissTransform(); }
                else { this.commitSelection(); }
                const layer = this.getCurrentLayer();
                const currentCanvas = layer.frames[this.currentFrameIndex];
                if (!currentCanvas) return;
                
                this.saveFullState();
                
                // Number of holds to insert = number of selected frames, or 1
                const count = this.selectedFrames.size > 1 ? this.selectedFrames.size : 1;
                
                // Insert the SAME canvas reference â€” they share pixel data
                const newIndex = this.currentFrameIndex + 1;
                const holds = new Array(count).fill(currentCanvas);
                layer.frames.splice(newIndex, 0, ...holds);
                this.currentFrameIndex = newIndex + count - 1;
                this.selectedFrames.clear();
                this.render();
                this._scrollTimelineToFrame(this.currentFrameIndex);
            }
            
            getHoldGroups(layer) {
                // Use cached result if available (cleared when _timelineDirty is set)
                if (layer._holdGroupsCache) return layer._holdGroupsCache;
                
                // Returns a Map: canvas -> Set of frame indices sharing that canvas
                const canvasToIndices = new Map();
                for (let i = 0; i < layer.frames.length; i++) {
                    const c = layer.frames[i];
                    if (!c) continue;
                    if (!canvasToIndices.has(c)) {
                        canvasToIndices.set(c, new Set());
                    }
                    canvasToIndices.get(c).add(i);
                }
                // Only return groups with 2+ frames
                const groups = new Map();
                for (const [canvas, indices] of canvasToIndices) {
                    if (indices.size > 1) {
                        groups.set(canvas, indices);
                    }
                }
                layer._holdGroupsCache = groups;
                return groups;
            }
            
            isHoldFrame(layer, frameIndex) {
                const canvas = layer.frames[frameIndex];
                if (!canvas) return false;
                const groups = this.getHoldGroups(layer);
                return groups.has(canvas);
            }
            
            // Returns contiguous hold segments: [{startIndex, length, canvas, color}]
            // Only includes runs of 2+ consecutive frames sharing the same canvas object
            getHoldSegments(layer) {
                if (layer._holdSegmentsCache) return layer._holdSegmentsCache;
                
                const holdPalette = [
                    '#6ea8fe', '#f7a072', '#7ee8a2', '#d4a0f5',
                    '#f06292', '#ffe066', '#4dd0e1', '#ffab91',
                ];
                const segments = [];
                // Map canvas -> color for consistent coloring
                // Colors are stored on the canvas itself so they persist across reorders
                const canvasColorMap = new Map();
                let colorIdx = 0;
                // First pass: count existing assigned colors to avoid reusing them
                for (const f of layer.frames) {
                    if (f && f._holdColor) canvasColorMap.set(f, f._holdColor);
                }
                // Find next colorIdx that won't collide
                const usedColors = new Set(canvasColorMap.values());
                let i = 0;
                while (i < layer.frames.length) {
                    const canvas = layer.frames[i];
                    if (!canvas) { i++; continue; }
                    // Count consecutive frames with identical canvas reference
                    let len = 1;
                    while (i + len < layer.frames.length && layer.frames[i + len] === canvas) {
                        len++;
                    }
                    if (len > 1) {
                        if (!canvasColorMap.has(canvas)) {
                            // Assign a new color, skipping already-used ones when possible
                            let attempts = 0;
                            while (attempts < holdPalette.length && usedColors.has(holdPalette[colorIdx % holdPalette.length])) {
                                colorIdx++;
                                attempts++;
                            }
                            const color = holdPalette[colorIdx % holdPalette.length];
                            canvasColorMap.set(canvas, color);
                            usedColors.add(color);
                            canvas._holdColor = color;
                            colorIdx++;
                        }
                        segments.push({
                            startIndex: i,
                            length: len,
                            canvas: canvas,
                            color: canvasColorMap.get(canvas)
                        });
                    }
                    i += len;
                }
                
                // Build reverse map: frameIndex -> segment
                const frameMap = new Map();
                for (const seg of segments) {
                    for (let fi = seg.startIndex; fi < seg.startIndex + seg.length; fi++) {
                        frameMap.set(fi, seg);
                    }
                }
                
                layer._holdSegmentsCache = { segments, frameMap };
                return layer._holdSegmentsCache;
            }
            
            // Drag right edge of hold block to extend/shorten hold duration
            _startHoldResize(handle, e) {
                const layerId = parseInt(handle.dataset.layerId, 10);
                const holdStart = parseInt(handle.dataset.holdStart, 10);
                const holdLength = parseInt(handle.dataset.holdLength, 10);
                const layer = this.layers.find(l => l.id === layerId);
                if (!layer) return;
                
                const startX = e.clientX;
                const { cellW } = this.getTimelineMetrics();
                const draggedCanvas = layer.frames[holdStart];
                
                // Collect all selected hold blocks (plus the dragged one)
                // Each entry: { canvas, startIndex, originalLength }
                const { segments: holdSegs } = this.getHoldSegments(layer);
                const selectedBlocks = [];
                const addedCanvases = new Set();
                
                // Add dragged block first
                addedCanvases.add(draggedCanvas);
                selectedBlocks.push({ canvas: draggedCanvas, originalLength: holdLength });
                
                // Find other selected hold blocks
                if (this.selectedFrames.size > 0) {
                    for (const seg of holdSegs) {
                        if (addedCanvases.has(seg.canvas)) continue;
                        // Check if any frame in this segment is selected
                        for (let fi = seg.startIndex; fi < seg.startIndex + seg.length; fi++) {
                            if (this.selectedFrames.has(fi)) {
                                addedCanvases.add(seg.canvas);
                                selectedBlocks.push({ canvas: seg.canvas, originalLength: seg.length });
                                break;
                            }
                        }
                    }
                }
                
                let undoSaved = false;
                let snapshotFrames = null;
                let appliedDelta = 0;
                
                const onMove = (ev) => {
                    const dx = ev.clientX - startX;
                    const rawDelta = Math.round(dx / cellW);
                    
                    // Clamp so no block goes below length 1
                    let newDelta = rawDelta;
                    for (const blk of selectedBlocks) {
                        newDelta = Math.max(newDelta, 1 - blk.originalLength);
                    }
                    if (newDelta === appliedDelta) return;
                    
                    if (!undoSaved) {
                        this.saveFullState();
                        undoSaved = true;
                        // Clean snapshot: trim trailing empty frames first
                        this._trimTrailingEmptyFrames(layer);
                        snapshotFrames = [...layer.frames];
                    }
                    
                    // Reset to snapshot
                    layer.frames = [...snapshotFrames];
                    
                    // Apply delta to each block from right to left (so splices don't shift earlier blocks)
                    const blockInfos = selectedBlocks.map(blk => {
                        let start = -1;
                        for (let fi = 0; fi < layer.frames.length; fi++) {
                            if (layer.frames[fi] === blk.canvas) { start = fi; break; }
                        }
                        return { canvas: blk.canvas, start, originalLength: blk.originalLength };
                    }).filter(b => b.start >= 0).sort((a, b) => b.start - a.start);
                    
                    for (const blk of blockInfos) {
                        const targetLen = Math.max(1, blk.originalLength + newDelta);
                        const delta = targetLen - blk.originalLength;
                        
                        if (delta > 0) {
                            const insertAt = blk.start + blk.originalLength;
                            const holdFrames = new Array(delta).fill(blk.canvas);
                            layer.frames.splice(insertAt, 0, ...holdFrames);
                        } else if (delta < 0) {
                            const removeAt = blk.start + targetLen;
                            layer.frames.splice(removeAt, -delta);
                        }
                    }
                    
                    appliedDelta = newDelta;
                    this._trimTrailingEmptyFrames(layer);
                    layer._holdSegmentsCache = null;
                    this._invalidateCompositeCache();
                    this._timelineDirty = true;
                    this.renderTimeline();
                };
                
                const onUp = () => {
                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);
                    document.removeEventListener('pointercancel', onUp);
                    if (undoSaved) {
                        this._trimTrailingEmptyFrames(layer);
                        layer._holdSegmentsCache = null;
                        this._invalidateCompositeCache();
                        this.render();
                    }
                };
                
                document.addEventListener('pointermove', onMove);
                document.addEventListener('pointerup', onUp);
                document.addEventListener('pointercancel', onUp);
            }
            
            // Drag right edge of a single frame to extend it into a hold frame
            _startFrameExtend(handle, e) {
                const layerId = parseInt(handle.dataset.layerId, 10);
                const frameIdx = parseInt(handle.dataset.frameIndex, 10);
                const layer = this.layers.find(l => l.id === layerId);
                if (!layer) return;
                
                const canvas = layer.frames[frameIdx];
                if (!canvas) return;
                
                const startX = e.clientX;
                const { cellW } = this.getTimelineMetrics();
                let undoSaved = false;
                let currentExtension = 0;
                
                const onMove = (ev) => {
                    const dx = ev.clientX - startX;
                    const newExtension = Math.max(0, Math.round(dx / cellW));
                    
                    if (newExtension === currentExtension) return;
                    
                    if (!undoSaved) {
                        this.saveFullState();
                        undoSaved = true;
                        // Clean any trailing empty frames upfront
                        this._trimTrailingEmptyFrames(layer);
                    }
                    
                    // Remove previously inserted hold frames
                    if (currentExtension > 0) {
                        layer.frames.splice(frameIdx + 1, currentExtension);
                    }
                    
                    // Insert new hold frames (pushes everything right)
                    currentExtension = newExtension;
                    if (currentExtension > 0) {
                        const holdFrames = new Array(currentExtension).fill(canvas);
                        layer.frames.splice(frameIdx + 1, 0, ...holdFrames);
                    }
                    
                    // Trim trailing empty frames
                    this._trimTrailingEmptyFrames(layer);
                    
                    layer._holdSegmentsCache = null;
                    this._invalidateCompositeCache();
                    this._timelineDirty = true;
                    this.renderTimeline();
                };
                
                const onUp = () => {
                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);
                    document.removeEventListener('pointercancel', onUp);
                    if (undoSaved) {
                        this._trimTrailingEmptyFrames(layer);
                        layer._holdSegmentsCache = null;
                        this._invalidateCompositeCache();
                        this.render();
                    }
                };
                
                document.addEventListener('pointermove', onMove);
                document.addEventListener('pointerup', onUp);
                document.addEventListener('pointercancel', onUp);
            }
            
            // Move a hold block (contiguous group of held frames) to a new position
            _moveHoldBlock(holdStart, holdLength, insertIdx) {
                const layer = this.getCurrentLayer();
                if (!layer) return;
                
                this.saveFullState();
                
                // Extract the hold frames
                const holdFrames = layer.frames.splice(holdStart, holdLength);
                
                // Adjust insert index if it was after the removed block
                let adjustedIdx = insertIdx;
                if (insertIdx > holdStart) {
                    adjustedIdx -= holdLength;
                }
                adjustedIdx = Math.max(0, Math.min(adjustedIdx, layer.frames.length));
                
                // Insert at new position
                layer.frames.splice(adjustedIdx, 0, ...holdFrames);
                
                // Move playhead to the start of the moved block
                this.currentFrameIndex = adjustedIdx;
                
                this._invalidateCompositeCache();
                this._timelineDirty = true;
                this.render();
                this._scrollTimelineToFrame(this.currentFrameIndex);
            }
            
            _moveMultiFrames(indices, insertIdx) {
                const layer = this.getCurrentLayer();
                if (!layer) return;
                
                this.saveFullState();
                
                const sorted = [...indices].sort((a, b) => a - b);
                // Collect frames to move
                const frames = sorted.map(i => layer.frames[i]);
                
                // Remove from back to front to keep indices valid
                for (let i = sorted.length - 1; i >= 0; i--) {
                    layer.frames.splice(sorted[i], 1);
                }
                
                // Adjust insert index for removed frames that were before it
                let adj = insertIdx;
                for (const idx of sorted) {
                    if (idx < insertIdx) adj--;
                }
                adj = Math.max(0, Math.min(adj, layer.frames.length));
                
                // Insert all frames at target
                layer.frames.splice(adj, 0, ...frames);
                
                // Update playhead and selection to new positions
                this.currentFrameIndex = adj;
                this.selectedFrames.clear();
                for (let i = 0; i < frames.length; i++) {
                    this.selectedFrames.add(adj + i);
                }
                
                this._invalidateCompositeCache();
                this._timelineDirty = true;
                this.render();
                this._scrollTimelineToFrame(this.currentFrameIndex);
            }
            _frameHasContent(frame) {
                if (!frame || frame.width === 0 || frame.height === 0) return false;
                const ver = frame._thumbVer || 0;
                if (frame._hasContentVer === ver && frame._hasContentCached !== undefined) {
                    return frame._hasContentCached;
                }
                // Full scan with early exit â€” only runs once per content mutation
                // (cached until _dirtyThumb increments _thumbVer)
                const ctx = frame.getContext('2d');
                const data = ctx.getImageData(0, 0, frame.width, frame.height).data;
                let result = false;
                for (let j = 3, len = data.length; j < len; j += 4) {
                    if (data[j] > 0) { result = true; break; }
                }
                frame._hasContentCached = result;
                frame._hasContentVer = ver;
                return result;
            }
            
            // Trim trailing frames that are null or standalone blank canvases
            // Hold frames (canvas shared by 2+ array entries) are always preserved
            _trimTrailingEmptyFrames(layer) {
                // Precompute: which canvases appear more than once (hold groups)
                const refCount = new Map();
                for (const f of layer.frames) {
                    if (f) refCount.set(f, (refCount.get(f) || 0) + 1);
                }
                
                // Walk backwards â€” find the last frame we must keep
                let keepUntil = 0; // keep at least 1 frame
                for (let i = layer.frames.length - 1; i >= 0; i--) {
                    const f = layer.frames[i];
                    if (f === null) continue;
                    
                    // Part of a hold group â€” always keep
                    if (refCount.get(f) > 1) {
                        keepUntil = i + 1;
                        break;
                    }
                    
                    // Standalone frame â€” keep only if it has drawn content
                    if (f.width > 0 && f.height > 0) {
                        const ctx = f.getContext('2d');
                        const data = ctx.getImageData(0, 0, f.width, f.height).data;
                        let hasPixels = false;
                        for (let j = 3, len = data.length; j < len; j += 4) {
                            if (data[j] > 0) { hasPixels = true; break; }
                        }
                        if (hasPixels) {
                            keepUntil = i + 1;
                            break;
                        }
                    }
                    // Empty standalone frame â€” continue walking backwards
                }
                
                // Truncate, keeping at least 1 frame
                const newLen = Math.max(1, keepUntil);
                if (layer.frames.length > newLen) {
                    layer.frames.length = newLen;
                }
                // Always clamp playhead â€” array may have been shortened by splices before trim
                if (layer.id === this.currentLayerId && this.currentFrameIndex >= layer.frames.length) {
                    this.currentFrameIndex = layer.frames.length - 1;
                }
            }
            
            releaseHoldFrame() {
                // Break current frame out of its hold group by making an independent copy
                this.commitSelection();
                const layer = this.getCurrentLayer();
                const canvas = layer.frames[this.currentFrameIndex];
                if (!canvas || !this.isHoldFrame(layer, this.currentFrameIndex)) return;
                
                this.saveFullState();
                
                const copy = document.createElement('canvas');
                copy.width = canvas.width;
                copy.height = canvas.height;
                copy.getContext('2d').drawImage(canvas, 0, 0);
                layer.frames[this.currentFrameIndex] = copy;
                this.initializeFrame();
                this.render();
            }
            
            // ===== LAYER TRANSFORM KEYFRAMES =====
            
            getLayerTransformAtFrame(layer, frameIndex) {
                const kfs = layer.transformKeyframes;
                const baseOp = layer.opacity != null ? layer.opacity : 1.0;
                const defaults = { x: 0, y: 0, anchorX: 0, anchorY: 0, scaleX: 1, scaleY: 1, rotation: 0, opacity: baseOp };
                if (!kfs || kfs.length === 0) return defaults;
                
                // Find surrounding keyframes
                let before = null, after = null;
                for (const kf of kfs) {
                    if (kf.frame <= frameIndex) before = kf;
                    if (kf.frame >= frameIndex && !after) after = kf;
                }
                
                const kfOp = (kf) => kf.opacity != null ? kf.opacity : baseOp;
                const kfAx = (kf) => kf.anchorX || 0;
                const kfAy = (kf) => kf.anchorY || 0;
                
                if (!before && after) return { x: after.x, y: after.y, anchorX: kfAx(after), anchorY: kfAy(after), scaleX: after.scaleX, scaleY: after.scaleY, rotation: after.rotation, opacity: kfOp(after) };
                if (before && !after) return { x: before.x, y: before.y, anchorX: kfAx(before), anchorY: kfAy(before), scaleX: before.scaleX, scaleY: before.scaleY, rotation: before.rotation, opacity: kfOp(before) };
                if (before === after || before.frame === after.frame) return { x: before.x, y: before.y, anchorX: kfAx(before), anchorY: kfAy(before), scaleX: before.scaleX, scaleY: before.scaleY, rotation: before.rotation, opacity: kfOp(before) };
                
                // Bezier easing: use the "before" keyframe's easing for this segment
                const linearT = (frameIndex - before.frame) / (after.frame - before.frame);
                const t = this.easedT(linearT, before);
                
                return {
                    x: before.x + (after.x - before.x) * t,
                    y: before.y + (after.y - before.y) * t,
                    anchorX: kfAx(before) + (kfAx(after) - kfAx(before)) * t,
                    anchorY: kfAy(before) + (kfAy(after) - kfAy(before)) * t,
                    scaleX: before.scaleX + (after.scaleX - before.scaleX) * t,
                    scaleY: before.scaleY + (after.scaleY - before.scaleY) * t,
                    rotation: before.rotation + (after.rotation - before.rotation) * t,
                    opacity: kfOp(before) + (kfOp(after) - kfOp(before)) * t
                };
            }
            
            // Cubic bezier easing evaluation
            easedT(t, keyframe) {
                const x1 = keyframe.easeX1 != null ? keyframe.easeX1 : 0;
                const y1 = keyframe.easeY1 != null ? keyframe.easeY1 : 0;
                const x2 = keyframe.easeX2 != null ? keyframe.easeX2 : 1;
                const y2 = keyframe.easeY2 != null ? keyframe.easeY2 : 1;
                // Linear shortcut
                if (x1 === 0 && y1 === 0 && x2 === 1 && y2 === 1) return t;
                if (t <= 0) return 0;
                if (t >= 1) return 1;
                return this._solveCubicBezier(t, x1, y1, x2, y2);
            }
            
            _solveCubicBezier(t, x1, y1, x2, y2) {
                // Newton-Raphson: find u where bezierX(u) = t, return bezierY(u)
                const bx = (u) => 3*(1-u)*(1-u)*u*x1 + 3*(1-u)*u*u*x2 + u*u*u;
                const by = (u) => 3*(1-u)*(1-u)*u*y1 + 3*(1-u)*u*u*y2 + u*u*u;
                const bdx = (u) => 3*(1-u)*(1-u)*x1 + 6*(1-u)*u*(x2-x1) + 3*u*u*(1-x2);
                
                let u = t;
                for (let i = 0; i < 8; i++) {
                    const xu = bx(u);
                    const dxu = bdx(u);
                    if (Math.abs(dxu) < 1e-7) break;
                    u -= (xu - t) / dxu;
                    u = Math.max(0, Math.min(1, u));
                }
                // Bisection fallback for robustness
                if (Math.abs(bx(u) - t) > 0.001) {
                    let lo = 0, hi = 1;
                    for (let i = 0; i < 20; i++) {
                        u = (lo + hi) / 2;
                        if (bx(u) < t) lo = u; else hi = u;
                    }
                }
                return by(u);
            }
            
            setTransformKeyframe(layer, frameIndex, props) {
                if (!layer.transformKeyframes) layer.transformKeyframes = [];
                const existing = layer.transformKeyframes.find(kf => kf.frame === frameIndex);
                if (existing) {
                    Object.assign(existing, props);
                } else {
                    layer.transformKeyframes.push({ frame: frameIndex, ...props });
                    layer.transformKeyframes.sort((a, b) => a.frame - b.frame);
                }
                this._invalidateCompositeCache();
            }
            
            removeTransformKeyframe(layer, frameIndex) {
                if (!layer.transformKeyframes) return;
                layer.transformKeyframes = layer.transformKeyframes.filter(kf => kf.frame !== frameIndex);
                this._invalidateCompositeCache();
            }
            
            hasTransformKeyframeAt(layer, frameIndex) {
                return (layer.transformKeyframes || []).some(kf => kf.frame === frameIndex);
            }
            
            getTransformKeyframeFrames(layer) {
                return (layer.transformKeyframes || []).map(kf => kf.frame);
            }
            
            // Get ancestor chain from root to direct parent (excluding self)
            _getParentChain(layer) {
                const chain = [];
                const visited = new Set();
                let current = layer;
                while (current.parentId != null) {
                    if (visited.has(current.parentId)) break; // cycle guard
                    visited.add(current.parentId);
                    const parent = this.layers.find(l => l.id === current.parentId);
                    if (!parent) break;
                    chain.unshift(parent); // prepend so chain is rootâ†’parent order
                    current = parent;
                }
                return chain;
            }
            
            // Check if setting parentId on layer would create a cycle
            _wouldCreateCycle(layerId, parentId) {
                if (parentId == null) return false;
                if (parentId === layerId) return true;
                const visited = new Set([layerId]);
                let current = parentId;
                while (current != null) {
                    if (visited.has(current)) return true;
                    visited.add(current);
                    const layer = this.layers.find(l => l.id === current);
                    if (!layer) break;
                    current = layer.parentId;
                }
                return false;
            }
            
            // Apply a single layer's transform to the canvas context
            _applyLayerTransform(ctx, tf) {
                const ax = -this.viewportX + this.projectWidth / 2 + tf.anchorX;
                const ay = -this.viewportY + this.projectHeight / 2 + tf.anchorY;
                ctx.translate(ax + tf.x, ay + tf.y);
                ctx.rotate(tf.rotation * Math.PI / 180);
                ctx.scale(tf.scaleX, tf.scaleY);
                ctx.translate(-ax, -ay);
            }
            
            drawLayerWithTransform(ctx, layer, timelinePos) {
                const frame = this.getFrameAtPosition(layer, timelinePos);
                if (!layer.visible || !frame) return;
                
                const localIdx = timelinePos - (layer.startFrame || 0);
                const tf = this.getLayerTransformAtFrame(layer, localIdx);
                const hasOwnTransform = tf.x !== 0 || tf.y !== 0 || tf.anchorX !== 0 || tf.anchorY !== 0 || tf.scaleX !== 1 || tf.scaleY !== 1 || tf.rotation !== 0;
                
                // Get parent chain transforms
                const parentChain = this._getParentChain(layer);
                const hasParents = parentChain.length > 0;
                
                // Frame position relative to viewport
                const offX = (frame._originX || 0) - this.viewportX;
                const offY = (frame._originY || 0) - this.viewportY;
                
                ctx.save();
                ctx.globalAlpha = tf.opacity;
                
                // Apply parent transforms in order (root ancestor â†’ direct parent)
                if (hasParents) {
                    for (const parent of parentChain) {
                        const pLocalIdx = timelinePos - (parent.startFrame || 0);
                        const ptf = this.getLayerTransformAtFrame(parent, pLocalIdx);
                        this._applyLayerTransform(ctx, ptf);
                    }
                }
                
                // Apply this layer's own transform
                if (hasOwnTransform) {
                    this._applyLayerTransform(ctx, tf);
                }
                
                ctx.drawImage(frame, offX, offY);
                ctx.restore();
            }
            
            drawAnchorIndicator(ctx) {
                if (!this._showAnchorIndicator) return;
                const layer = this.getCurrentLayer();
                
                const tf = this.getLayerTransformAtFrame(layer, this.currentFrameIndex);
                const ax = -this.viewportX + this.projectWidth / 2 + tf.anchorX;
                const ay = -this.viewportY + this.projectHeight / 2 + tf.anchorY;
                const r = 12; // crosshair radius
                
                ctx.save();
                ctx.lineWidth = 1.5;
                
                // Outer circle - dark outline for contrast
                ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.arc(ax, ay, r, 0, Math.PI * 2);
                ctx.stroke();
                // Crosshair lines - dark
                ctx.beginPath();
                ctx.moveTo(ax - r - 4, ay); ctx.lineTo(ax - 3, ay);
                ctx.moveTo(ax + 3, ay); ctx.lineTo(ax + r + 4, ay);
                ctx.moveTo(ax, ay - r - 4); ctx.lineTo(ax, ay - 3);
                ctx.moveTo(ax, ay + 3); ctx.lineTo(ax, ay + r + 4);
                ctx.stroke();
                
                // Inner circle - bright colored
                ctx.strokeStyle = '#eebb00';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(ax, ay, r, 0, Math.PI * 2);
                ctx.stroke();
                // Crosshair lines - bright
                ctx.beginPath();
                ctx.moveTo(ax - r - 4, ay); ctx.lineTo(ax - 3, ay);
                ctx.moveTo(ax + 3, ay); ctx.lineTo(ax + r + 4, ay);
                ctx.moveTo(ax, ay - r - 4); ctx.lineTo(ax, ay - 3);
                ctx.moveTo(ax, ay + 3); ctx.lineTo(ax, ay + r + 4);
                ctx.stroke();
                
                // Center dot
                ctx.fillStyle = '#eebb00';
                ctx.beginPath();
                ctx.arc(ax, ay, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            updateTransformPanel() {
                // No-op: inline transform controls are rebuilt by renderTimeline
            }
            
            _readPropInputs(inputs) {
                const g = (key, def) => inputs[key] ? inputs[key].getValue() : def;
                return {
                    x: g('x', 0),
                    y: g('y', 0),
                    anchorX: g('anchorX', 0),
                    anchorY: g('anchorY', 0),
                    scaleX: g('scaleX', 100) / 100,
                    scaleY: g('scaleY', 100) / 100,
                    rotation: g('rotation', 0),
                    opacity: Math.max(0, Math.min(1, g('opacity', 100) / 100))
                };
            }
            
            // ============= CURVE EDITOR =============
            
            toggleCurveEditor(layer) {
                if (this._curveEditorActive && this._curveEditorLayerId === layer.id) {
                    this.closeCurveEditor();
                } else {
                    this.openCurveEditor(layer);
                }
            }
            
            openCurveEditor(layer) {
                const kfs = layer.transformKeyframes || [];
                if (kfs.length < 2) {
                    alert('Need at least 2 keyframes to edit curves.');
                    return;
                }
                this._curveEditorActive = true;
                this._curveEditorLayerId = layer.id;
                this._curveEditorProp = 'x';
                this._ceSegmentIndex = 0;
                
                // Find the segment the current frame is in
                for (let i = 0; i < kfs.length - 1; i++) {
                    if (this.currentFrameIndex >= kfs[i].frame && this.currentFrameIndex <= kfs[i+1].frame) {
                        this._ceSegmentIndex = i;
                        break;
                    }
                }
                
                document.getElementById('curveEditor').classList.add('active');
                document.getElementById('timelineFramesSection').style.display = 'none';
                
                this._initCurveEditorUI();
                // Set up handlers immediately
                const ceCanvas = document.getElementById('curveCanvas');
                ceCanvas.onpointerdown = (e) => this._cePointerDown(e);
                ceCanvas.onpointermove = (e) => this._cePointerMove(e);
                ceCanvas.onpointerup = (e) => this._cePointerUp(e);
                ceCanvas.ondblclick = (e) => this._ceDblClick(e);
                // Wait for layout before sizing canvas
                requestAnimationFrame(() => {
                    this.renderCurveEditor();
                });
                this._timelineDirty = true;
                this.renderTimeline(); // update button states
            }
            
            closeCurveEditor() {
                this._curveEditorActive = false;
                this._curveEditorLayerId = null;
                document.getElementById('curveEditor').classList.remove('active');
                document.getElementById('timelineFramesSection').style.display = '';
                this._timelineDirty = true;
                this.renderTimeline();
            }
            
            _initCurveEditorUI() {
                const propTabs = document.getElementById('cePropTabs');
                propTabs.innerHTML = '';
                const props = [
                    { key: 'x', label: 'Pos X' }, { key: 'y', label: 'Pos Y' },
                    { key: 'anchorX', label: 'Anc X' }, { key: 'anchorY', label: 'Anc Y' },
                    { key: 'scaleX', label: 'Scale X' }, { key: 'scaleY', label: 'Scale Y' },
                    { key: 'rotation', label: 'Rotation' }, { key: 'opacity', label: 'Opacity' }
                ];
                props.forEach(p => {
                    const btn = document.createElement('button');
                    btn.className = 'ce-prop-tab' + (p.key === this._curveEditorProp ? ' active' : '');
                    btn.textContent = p.label;
                    btn.addEventListener('click', () => {
                        this._curveEditorProp = p.key;
                        propTabs.querySelectorAll('.ce-prop-tab').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.renderCurveEditor();
                    });
                    propTabs.appendChild(btn);
                });
                
                // Presets
                const presets = document.getElementById('cePresets');
                presets.innerHTML = '';
                const presetData = [
                    { label: 'Linear', v: [0, 0, 1, 1] },
                    { label: 'Ease In', v: [0.42, 0, 1, 1] },
                    { label: 'Ease Out', v: [0, 0, 0.58, 1] },
                    { label: 'Ease In-Out', v: [0.42, 0, 0.58, 1] },
                    { label: 'Snap', v: [0, 1, 1, 1] },
                ];
                presetData.forEach(pr => {
                    const btn = document.createElement('button');
                    btn.className = 'ce-preset-btn';
                    btn.textContent = pr.label;
                    btn.addEventListener('click', () => {
                        this._applyEasingPreset(pr.v);
                    });
                    presets.appendChild(btn);
                });
                
                // Close button
                document.getElementById('ceCloseBtn').onclick = () => this.closeCurveEditor();
            }
            
            _applyEasingPreset(vals) {
                const layer = this.layers.find(l => l.id === this._curveEditorLayerId);
                if (!layer) return;
                const kfs = layer.transformKeyframes || [];
                const si = this._ceSegmentIndex;
                if (si >= kfs.length - 1) return;
                
                this.saveFullState();
                const kf = kfs[si];
                kf.easeX1 = vals[0];
                kf.easeY1 = vals[1];
                kf.easeX2 = vals[2];
                kf.easeY2 = vals[3];
                this.renderCurveEditor();
                this.renderCanvasOnly();
            }
            
            renderCurveEditor() {
                const canvas = document.getElementById('curveCanvas');
                if (!canvas) return;
                const wrap = canvas.parentElement;
                const rect = wrap.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                if (canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr)) {
                    canvas.width = Math.round(rect.width * dpr);
                    canvas.height = Math.round(rect.height * dpr);
                }
                
                const ctx = canvas.getContext('2d');
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                const W = rect.width;
                const H = rect.height;
                
                // Clear
                ctx.fillStyle = '#1a1a22';
                ctx.fillRect(0, 0, W, H);
                
                const layer = this.layers.find(l => l.id === this._curveEditorLayerId);
                if (!layer) return;
                const kfs = layer.transformKeyframes || [];
                if (kfs.length < 2) return;
                
                const si = this._ceSegmentIndex;
                const kfA = kfs[si];
                const kfB = kfs[si + 1];
                if (!kfA || !kfB) return;
                
                // Graph area with padding
                const pad = { l: 50, r: 30, t: 30, b: 30 };
                const gW = W - pad.l - pad.r;
                const gH = H - pad.t - pad.b;
                
                // Get property values
                const prop = this._curveEditorProp;
                const vA = this._getKfPropValue(kfA, prop, layer);
                const vB = this._getKfPropValue(kfB, prop, layer);
                
                // Draw grid
                ctx.strokeStyle = '#2a2a34';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = pad.t + (gH * i / 4);
                    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(pad.l + gW, y); ctx.stroke();
                    const x = pad.l + (gW * i / 4);
                    ctx.beginPath(); ctx.moveTo(x, pad.t); ctx.lineTo(x, pad.t + gH); ctx.stroke();
                }
                
                // Diagonal reference (linear)
                ctx.strokeStyle = '#333344';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(pad.l, pad.t + gH);
                ctx.lineTo(pad.l + gW, pad.t);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Easing values
                const x1 = kfA.easeX1 != null ? kfA.easeX1 : 0;
                const y1 = kfA.easeY1 != null ? kfA.easeY1 : 0;
                const x2 = kfA.easeX2 != null ? kfA.easeX2 : 1;
                const y2 = kfA.easeY2 != null ? kfA.easeY2 : 1;
                
                // Map normalized coords to pixel coords
                const toX = (n) => pad.l + n * gW;
                const toY = (n) => pad.t + gH - n * gH; // flip Y
                
                // Draw bezier curve
                ctx.strokeStyle = '#5599dd';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(toX(0), toY(0));
                for (let i = 1; i <= 60; i++) {
                    const t = i / 60;
                    const bx = 3*(1-t)*(1-t)*t*x1 + 3*(1-t)*t*t*x2 + t*t*t;
                    const by = 3*(1-t)*(1-t)*t*y1 + 3*(1-t)*t*t*y2 + t*t*t;
                    ctx.lineTo(toX(bx), toY(by));
                }
                ctx.stroke();
                
                // Control point handles
                // CP1 line
                ctx.strokeStyle = 'rgba(238,187,0,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(toX(0), toY(0));
                ctx.lineTo(toX(x1), toY(y1));
                ctx.stroke();
                // CP2 line
                ctx.beginPath();
                ctx.moveTo(toX(1), toY(1));
                ctx.lineTo(toX(x2), toY(y2));
                ctx.stroke();
                
                // CP1 handle
                ctx.fillStyle = '#eebb00';
                ctx.beginPath();
                ctx.arc(toX(x1), toY(y1), 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#aa8800';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // CP2 handle
                ctx.fillStyle = '#eebb00';
                ctx.beginPath();
                ctx.arc(toX(x2), toY(y2), 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#aa8800';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Start/end points
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(toX(0), toY(0), 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(toX(1), toY(1), 4, 0, Math.PI * 2); ctx.fill();
                
                // Axis labels
                ctx.fillStyle = '#667';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`F${kfA.frame + 1}`, toX(0), pad.t + gH + 18);
                ctx.fillText(`F${kfB.frame + 1}`, toX(1), pad.t + gH + 18);
                
                ctx.textAlign = 'right';
                const valFmt = (v) => Math.abs(v) >= 100 ? Math.round(v) : v.toFixed(1);
                ctx.fillText(valFmt(vA), pad.l - 6, toY(0) + 3);
                ctx.fillText(valFmt(vB), pad.l - 6, toY(1) + 3);
                
                // Segment selector (if multiple segments)
                if (kfs.length > 2) {
                    ctx.fillStyle = '#556';
                    ctx.textAlign = 'center';
                    ctx.font = '10px sans-serif';
                    const segLabel = `Segment ${si + 1}/${kfs.length - 1}`;
                    ctx.fillText(segLabel, W / 2, 16);
                    
                    // Prev/Next arrows
                    if (si > 0) {
                        ctx.fillStyle = '#8ac';
                        ctx.fillText('â—€ Prev', W / 2 - 65, 16);
                    }
                    if (si < kfs.length - 2) {
                        ctx.fillStyle = '#8ac';
                        ctx.fillText('Next â–¶', W / 2 + 65, 16);
                    }
                }
                
                // Current playhead position on curve
                if (this.currentFrameIndex >= kfA.frame && this.currentFrameIndex <= kfB.frame) {
                    const lt = (this.currentFrameIndex - kfA.frame) / (kfB.frame - kfA.frame);
                    const et = this.easedT(lt, kfA);
                    ctx.fillStyle = 'rgba(255,80,80,0.9)';
                    ctx.beginPath();
                    ctx.arc(toX(lt), toY(et), 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Store layout for hit testing
                this._ceLayout = { pad, gW, gH, W, H, x1, y1, x2, y2 };
            }
            
            _getKfPropValue(kf, prop, layer) {
                if (prop === 'opacity') return (kf.opacity != null ? kf.opacity : (layer.opacity || 1)) * 100;
                if (prop === 'scaleX') return kf.scaleX * 100;
                if (prop === 'scaleY') return kf.scaleY * 100;
                return kf[prop] || 0;
            }
            
            _cePointerDown(e) {
                const canvas = document.getElementById('curveCanvas');
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const L = this._ceLayout;
                if (!L) return;
                
                // Check segment navigation clicks
                const layer = this.layers.find(l => l.id === this._curveEditorLayerId);
                if (!layer) return;
                const kfs = layer.transformKeyframes || [];
                
                if (kfs.length > 2 && my < 24) {
                    const cx = L.W / 2;
                    if (mx < cx - 20 && this._ceSegmentIndex > 0) {
                        this._ceSegmentIndex--;
                        this.renderCurveEditor();
                        return;
                    }
                    if (mx > cx + 20 && this._ceSegmentIndex < kfs.length - 2) {
                        this._ceSegmentIndex++;
                        this.renderCurveEditor();
                        return;
                    }
                }
                
                // Hit test control points
                const toX = (n) => L.pad.l + n * L.gW;
                const toY = (n) => L.pad.t + L.gH - n * L.gH;
                
                const d1 = Math.hypot(mx - toX(L.x1), my - toY(L.y1));
                const d2 = Math.hypot(mx - toX(L.x2), my - toY(L.y2));
                
                if (d1 < 14) {
                    this._ceDragHandle = 'cp1';
                    this.saveFullState();
                    canvas.setPointerCapture(e.pointerId);
                    e.preventDefault();
                } else if (d2 < 14) {
                    this._ceDragHandle = 'cp2';
                    this.saveFullState();
                    canvas.setPointerCapture(e.pointerId);
                    e.preventDefault();
                }
            }
            
            _cePointerMove(e) {
                if (!this._ceDragHandle) return;
                const canvas = document.getElementById('curveCanvas');
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const L = this._ceLayout;
                if (!L) return;
                
                // Convert pixel to normalized
                let nx = Math.max(0, Math.min(1, (mx - L.pad.l) / L.gW));
                let ny = Math.max(-0.5, Math.min(1.5, 1 - (my - L.pad.t) / L.gH));
                
                const layer = this.layers.find(l => l.id === this._curveEditorLayerId);
                if (!layer) return;
                const kf = layer.transformKeyframes[this._ceSegmentIndex];
                if (!kf) return;
                
                if (this._ceDragHandle === 'cp1') {
                    kf.easeX1 = Math.round(nx * 100) / 100;
                    kf.easeY1 = Math.round(ny * 100) / 100;
                } else {
                    kf.easeX2 = Math.round(nx * 100) / 100;
                    kf.easeY2 = Math.round(ny * 100) / 100;
                }
                
                this.renderCurveEditor();
                this.renderCanvasOnly();
            }
            
            _cePointerUp(e) {
                this._ceDragHandle = null;
            }
            
            _ceDblClick(e) {
                // Reset the segment to linear
                const layer = this.layers.find(l => l.id === this._curveEditorLayerId);
                if (!layer) return;
                const kf = layer.transformKeyframes[this._ceSegmentIndex];
                if (!kf) return;
                this.saveFullState();
                kf.easeX1 = 0; kf.easeY1 = 0;
                kf.easeX2 = 1; kf.easeY2 = 1;
                this.renderCurveEditor();
                this.renderCanvasOnly();
            }
            
            // ============= END CURVE EDITOR =============
            
            deleteCurrentFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                
                // Multi-frame delete
                if (this.selectedFrames.size > 1) {
                    // Don't delete all frames
                    if (this.selectedFrames.size >= layer.frames.length) {
                        alert('Cannot delete all frames. At least one frame must remain.');
                        return;
                    }
                    
                    this.saveFullState();
                    
                    // Delete from highest index to lowest so indices stay valid
                    const sortedDesc = [...this.selectedFrames].sort((a, b) => b - a);
                    for (const idx of sortedDesc) {
                        if (idx >= 0 && idx < layer.frames.length) {
                            layer.frames.splice(idx, 1);
                        }
                    }
                    
                    // Navigate to frame before the first deleted, or 0
                    const minDeleted = Math.min(...this.selectedFrames);
                    this.currentFrameIndex = Math.min(minDeleted, layer.frames.length - 1);
                    if (this.currentFrameIndex < 0) this.currentFrameIndex = 0;
                    this.selectedFrames.clear();
                    if (this.frameSelectMode) {
                        this.frameSelectMode = false;
                        document.getElementById('frameSelectBanner').classList.remove('show');
                    }
                    this.render();
                    return;
                }
                
                // Single frame delete
                if (layer.frames.length <= 1) {
                    alert('Cannot delete the only frame. Create another frame first.');
                    return;
                }
                
                this.saveFullState();
                
                layer.frames.splice(this.currentFrameIndex, 1);
                
                if (this.currentFrameIndex >= layer.frames.length) {
                    this.currentFrameIndex = layer.frames.length - 1;
                }
                
                this.selectedFrames.clear();
                if (this.frameSelectMode) {
                    this.frameSelectMode = false;
                    document.getElementById('frameSelectBanner').classList.remove('show');
                }
                this.render();
            }
            
            // Lasso Selection Methods
            drawLassoPath() {
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                if (this.lassoPath.length < 2) return;
                
                this.selectionCtx.strokeStyle = '#5b8def';
                this.selectionCtx.lineWidth = 2;
                this.selectionCtx.setLineDash([5, 5]);
                this.selectionCtx.beginPath();
                this.selectionCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                
                for (let i = 1; i < this.lassoPath.length; i++) {
                    this.selectionCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                
                this.selectionCtx.closePath();
                this.selectionCtx.stroke();
                this.selectionCtx.setLineDash([]);
            }
            
            completeLassoSelection() {
                if (this.lassoPath.length < 3) {
                    this.lassoPath = [];
                    this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                    return;
                }
                
                // Convert lasso path from display canvas coords to frame-local coords
                const off = this.getSelectionDisplayOffset();
                const localPath = this.lassoPath.map(p => ({
                    x: p.x - off.x,
                    y: p.y - off.y
                }));
                
                // Calculate lasso path bounds in frame-local coords
                let lassoMinX = Infinity, lassoMinY = Infinity, lassoMaxX = -Infinity, lassoMaxY = -Infinity;
                for (let point of localPath) {
                    lassoMinX = Math.min(lassoMinX, point.x);
                    lassoMinY = Math.min(lassoMinY, point.y);
                    lassoMaxX = Math.max(lassoMaxX, point.x);
                    lassoMaxY = Math.max(lassoMaxY, point.y);
                }
                
                // Get frame for bounds clamping
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                
                // Clamp to frame bounds
                lassoMinX = Math.max(0, Math.floor(lassoMinX));
                lassoMinY = Math.max(0, Math.floor(lassoMinY));
                lassoMaxX = Math.min(frame.width, Math.ceil(lassoMaxX));
                lassoMaxY = Math.min(frame.height, Math.ceil(lassoMaxY));
                
                const lassoWidth = lassoMaxX - lassoMinX;
                const lassoHeight = lassoMaxY - lassoMinY;
                
                if (lassoWidth <= 0 || lassoHeight <= 0) {
                    this.lassoPath = [];
                    return;
                }
                
                // Create a mask for the lasso selection (frame-local coords)
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = frame.width;
                maskCanvas.height = frame.height;
                const maskCtx = maskCanvas.getContext('2d');
                
                // Draw lasso path as mask using frame-local coords
                maskCtx.fillStyle = 'white';
                maskCtx.beginPath();
                maskCtx.moveTo(localPath[0].x, localPath[0].y);
                for (let i = 1; i < localPath.length; i++) {
                    maskCtx.lineTo(localPath[i].x, localPath[i].y);
                }
                maskCtx.closePath();
                maskCtx.fill();
                
                // Create masked selection at lasso bounds size
                const maskedCanvas = document.createElement('canvas');
                maskedCanvas.width = lassoWidth;
                maskedCanvas.height = lassoHeight;
                const maskedCtx = maskedCanvas.getContext('2d');
                
                // Copy frame content within lasso bounds
                maskedCtx.drawImage(frame, lassoMinX, lassoMinY, lassoWidth, lassoHeight, 0, 0, lassoWidth, lassoHeight);
                
                // Apply lasso mask
                maskedCtx.globalCompositeOperation = 'destination-in';
                maskedCtx.drawImage(maskCanvas, lassoMinX, lassoMinY, lassoWidth, lassoHeight, 0, 0, lassoWidth, lassoHeight);
                maskedCtx.globalCompositeOperation = 'source-over';
                
                // Scan pixel data to find tight bounding box of actual content
                const pixelData = maskedCtx.getImageData(0, 0, lassoWidth, lassoHeight);
                const pixels = pixelData.data;
                
                let tightMinX = lassoWidth, tightMinY = lassoHeight, tightMaxX = -1, tightMaxY = -1;
                
                for (let py = 0; py < lassoHeight; py++) {
                    for (let px = 0; px < lassoWidth; px++) {
                        const alpha = pixels[(py * lassoWidth + px) * 4 + 3];
                        if (alpha > 0) {
                            if (px < tightMinX) tightMinX = px;
                            if (px > tightMaxX) tightMaxX = px;
                            if (py < tightMinY) tightMinY = py;
                            if (py > tightMaxY) tightMaxY = py;
                        }
                    }
                }
                
                // If no pixels found, nothing to select
                if (tightMaxX < 0 || tightMaxY < 0) {
                    this.lassoPath = [];
                    this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                    return;
                }
                
                // Calculate tight bounds in frame-local coordinates
                const tightWidth = tightMaxX - tightMinX + 1;
                const tightHeight = tightMaxY - tightMinY + 1;
                const finalX = lassoMinX + tightMinX;
                const finalY = lassoMinY + tightMinY;
                
                // Create final trimmed selection canvas
                const selectedCanvas = document.createElement('canvas');
                selectedCanvas.width = tightWidth;
                selectedCanvas.height = tightHeight;
                const selectedCtx = selectedCanvas.getContext('2d');
                
                // Copy only the tight region from the masked canvas
                selectedCtx.drawImage(maskedCanvas, tightMinX, tightMinY, tightWidth, tightHeight, 0, 0, tightWidth, tightHeight);
                
                // Store selection with tight bounds (frame-local coords)
                this.selection = {
                    imageData: selectedCanvas,
                    bounds: { x: finalX, y: finalY, width: tightWidth, height: tightHeight },
                    originalBounds: { x: finalX, y: finalY, width: tightWidth, height: tightHeight }
                };
                
                // Erase selected area from original frame (using frame-local lasso path)
                frameCtx.save();
                frameCtx.globalCompositeOperation = 'destination-out';
                frameCtx.beginPath();
                frameCtx.moveTo(localPath[0].x, localPath[0].y);
                for (let i = 1; i < localPath.length; i++) {
                    frameCtx.lineTo(localPath[i].x, localPath[i].y);
                }
                frameCtx.closePath();
                frameCtx.fill();
                frameCtx.restore();
                
                // Clear lasso path
                this.lassoPath = [];
                
                // Switch to transform tool
                this.selectTool('transform');
                this.render();
            }
            
            // Transform Methods
            isPointInSelection(x, y) {
                if (!this.selection) return false;
                
                // Convert display canvas coords to frame-local
                const off = this.getSelectionDisplayOffset();
                let lx = x - off.x;
                let ly = y - off.y;
                
                // Distort mode: point-in-quad test
                if (this.tool === 'distort' && this.selection.corners) {
                    return this._pointInPolygon(lx, ly, this.selection.corners);
                }
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const skewX = this.selection.skewX || 0;
                const skewY = this.selection.skewY || 0;
                
                // If rotated or skewed, un-transform the test point around the anchor
                if (rotation !== 0 || skewX !== 0 || skewY !== 0) {
                    const ax = this.selection.anchorX || (b.x + b.width / 2);
                    const ay = this.selection.anchorY || (b.y + b.height / 2);
                    // Translate to anchor-relative
                    let px = lx - ax;
                    let py = ly - ay;
                    // Un-skew
                    if (skewX !== 0 || skewY !== 0) {
                        const det = 1 - skewX * skewY;
                        if (Math.abs(det) > 1e-6) {
                            const ux = (px - skewX * py) / det;
                            const uy = (py - skewY * px) / det;
                            px = ux;
                            py = uy;
                        }
                    }
                    // Un-rotate
                    if (rotation !== 0) {
                        const cos = Math.cos(-rotation);
                        const sin = Math.sin(-rotation);
                        const rx = px * cos - py * sin;
                        const ry = px * sin + py * cos;
                        px = rx;
                        py = ry;
                    }
                    // Translate back
                    lx = px + ax;
                    ly = py + ay;
                }
                
                return lx >= b.x && lx <= b.x + b.width && ly >= b.y && ly <= b.y + b.height;
            }
            
            _pointInPolygon(px, py, poly) {
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].x, yi = poly[i].y;
                    const xj = poly[j].x, yj = poly[j].y;
                    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }
            
            showTransformHandles() {
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                
                // Initialize anchor point at center if not set
                if (!this.selection.anchorX || !this.selection.anchorY) {
                    this.selection.anchorX = b.x + b.width / 2;
                    this.selection.anchorY = b.y + b.height / 2;
                }
                
                // Initialize rotation if not set
                if (this.selection.rotation === undefined) {
                    this.selection.rotation = 0;
                }
                
                // Initialize skew if not set
                if (this.selection.skewX === undefined) this.selection.skewX = 0;
                if (this.selection.skewY === undefined) this.selection.skewY = 0;
                
                // Initialize distort corners if not set
                if (!this.selection.corners) {
                    this.selection.corners = [
                        { x: b.x, y: b.y },                   // TL
                        { x: b.x + b.width, y: b.y },         // TR
                        { x: b.x + b.width, y: b.y + b.height }, // BR
                        { x: b.x, y: b.y + b.height }          // BL
                    ];
                }
                
                if (this.tool === 'distort') {
                    // Distort mode: handles at free corners
                    const c = this.selection.corners;
                    this.transformHandles = [
                        { x: c[0].x, y: c[0].y, type: 'distort-tl', cornerIdx: 0 },
                        { x: c[1].x, y: c[1].y, type: 'distort-tr', cornerIdx: 1 },
                        { x: c[2].x, y: c[2].y, type: 'distort-br', cornerIdx: 2 },
                        { x: c[3].x, y: c[3].y, type: 'distort-bl', cornerIdx: 3 },
                    ];
                    // Add move handle at centroid
                    const cx = (c[0].x + c[1].x + c[2].x + c[3].x) / 4;
                    const cy = (c[0].y + c[1].y + c[2].y + c[3].y) / 4;
                    this.transformHandles.push({ x: cx, y: cy, type: 'anchor' });
                } else {
                    const rotation = this.selection.rotation;
                    const anchorX = this.selection.anchorX;
                    const anchorY = this.selection.anchorY;
                    
                    // Helper function to rotate a point around anchor
                    const rotatePoint = (px, py) => {
                        const cos = Math.cos(rotation);
                        const sin = Math.sin(rotation);
                        const dx = px - anchorX;
                        const dy = py - anchorY;
                        return {
                            x: anchorX + dx * cos - dy * sin,
                            y: anchorY + dx * sin + dy * cos
                        };
                    };
                    
                    // Calculate handle positions in unrotated space, then rotate them
                    const unrotatedHandles = [
                        { x: b.x, y: b.y, type: 'nw' },
                        { x: b.x + b.width, y: b.y, type: 'ne' },
                        { x: b.x + b.width, y: b.y + b.height, type: 'se' },
                        { x: b.x, y: b.y + b.height, type: 'sw' },
                        { x: b.x + b.width / 2, y: b.y, type: 'n' },
                        { x: b.x + b.width, y: b.y + b.height / 2, type: 'e' },
                        { x: b.x + b.width / 2, y: b.y + b.height, type: 's' },
                        { x: b.x, y: b.y + b.height / 2, type: 'w' }
                    ];
                    
                    // Rotate all handle positions
                    this.transformHandles = unrotatedHandles.map(h => {
                        const rotated = rotatePoint(h.x, h.y);
                        return { x: rotated.x, y: rotated.y, type: h.type };
                    });
                    
                    // Add anchor point (not rotated)
                    this.transformHandles.push({ x: anchorX, y: anchorY, type: 'anchor' });
                }
                
                // Offset all handles from frame-local to display canvas coords
                const off = this.getSelectionDisplayOffset();
                for (const h of this.transformHandles) {
                    h.x += off.x;
                    h.y += off.y;
                }
                
                this.drawTransformHandles();
            }
            
            hideTransformHandles() {
                this.transformHandles = [];
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
            }
            
            // Commit active free transform, clear selection, switch to lasso
            _dismissTransform() {
                if (!this.selection) return;
                this.applySelection();
                this.clearSelection();
                this.hideTransformHandles();
                this.isTransforming = false;
                this.isRotating = false;
                this.activeHandle = null;
                this.render();
            }
            
            drawTransformHandles() {
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const off = this.getSelectionDisplayOffset();
                const anchorX = (this.selection.anchorX || (b.x + b.width / 2)) + off.x;
                const anchorY = (this.selection.anchorY || (b.y + b.height / 2)) + off.y;
                
                if (this.tool === 'distort' && this.selection.corners) {
                    // Draw distort quad outline (offset corners to display space)
                    const c = this.selection.corners;
                    this.selectionCtx.strokeStyle = '#cc44ff';
                    this.selectionCtx.lineWidth = 2;
                    this.selectionCtx.setLineDash([5, 5]);
                    this.selectionCtx.beginPath();
                    this.selectionCtx.moveTo(c[0].x + off.x, c[0].y + off.y);
                    this.selectionCtx.lineTo(c[1].x + off.x, c[1].y + off.y);
                    this.selectionCtx.lineTo(c[2].x + off.x, c[2].y + off.y);
                    this.selectionCtx.lineTo(c[3].x + off.x, c[3].y + off.y);
                    this.selectionCtx.closePath();
                    this.selectionCtx.stroke();
                    this.selectionCtx.setLineDash([]);
                    
                    // Draw corner handles
                    for (const handle of this.transformHandles) {
                        if (handle.type === 'anchor') continue;
                        this.selectionCtx.fillStyle = '#cc44ff';
                        this.selectionCtx.strokeStyle = '#fff';
                        this.selectionCtx.lineWidth = 2;
                        this.selectionCtx.beginPath();
                        this.selectionCtx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
                        this.selectionCtx.fill();
                        this.selectionCtx.stroke();
                    }
                } else {
                    // Standard bounding box (with rotation + skew)
                    const skewX = this.selection.skewX || 0;
                    const skewY = this.selection.skewY || 0;
                    
                    this.selectionCtx.save();
                    this.selectionCtx.translate(anchorX, anchorY);
                    this.selectionCtx.rotate(rotation);
                    if (skewX || skewY) {
                        this.selectionCtx.transform(1, skewY, skewX, 1, 0, 0);
                    }
                    this.selectionCtx.translate(-anchorX, -anchorY);
                    
                    const skewColor = (skewX || skewY) ? '#cc44ff' : '#5b8def';
                    this.selectionCtx.strokeStyle = skewColor;
                    this.selectionCtx.lineWidth = 2;
                    this.selectionCtx.setLineDash([5, 5]);
                    this.selectionCtx.strokeRect(b.x + off.x, b.y + off.y, b.width, b.height);
                    this.selectionCtx.setLineDash([]);
                    
                    this.selectionCtx.restore();
                    
                    // Draw resize/rotate handles
                    for (let handle of this.transformHandles) {
                        if (handle.type === 'anchor') continue;
                        
                        const isEdge = handle.type === 'n' || handle.type === 's' || handle.type === 'e' || handle.type === 'w';
                        const handleColor = (this.tool === 'skew' && isEdge) ? '#cc44ff' : 'white';
                        
                        this.selectionCtx.fillStyle = handleColor;
                        this.selectionCtx.strokeStyle = '#5b8def';
                        this.selectionCtx.lineWidth = 2;
                        this.selectionCtx.beginPath();
                        
                        if (this.tool === 'skew' && isEdge) {
                            // Diamond shape for skew edge handles
                            this.selectionCtx.moveTo(handle.x, handle.y - 6);
                            this.selectionCtx.lineTo(handle.x + 6, handle.y);
                            this.selectionCtx.lineTo(handle.x, handle.y + 6);
                            this.selectionCtx.lineTo(handle.x - 6, handle.y);
                            this.selectionCtx.closePath();
                        } else {
                            this.selectionCtx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
                        }
                        this.selectionCtx.fill();
                        this.selectionCtx.stroke();
                    }
                    
                    // Draw anchor point crosshair
                    const anchorHandle = this.transformHandles.find(h => h.type === 'anchor');
                    if (anchorHandle) {
                        this.selectionCtx.strokeStyle = '#ff6600';
                        this.selectionCtx.lineWidth = 2;
                        this.selectionCtx.beginPath();
                        this.selectionCtx.moveTo(anchorHandle.x - 8, anchorHandle.y);
                        this.selectionCtx.lineTo(anchorHandle.x + 8, anchorHandle.y);
                        this.selectionCtx.moveTo(anchorHandle.x, anchorHandle.y - 8);
                        this.selectionCtx.lineTo(anchorHandle.x, anchorHandle.y + 8);
                        this.selectionCtx.stroke();
                        
                        this.selectionCtx.strokeStyle = '#ff6600';
                        this.selectionCtx.fillStyle = 'white';
                        this.selectionCtx.beginPath();
                        this.selectionCtx.arc(anchorHandle.x, anchorHandle.y, 6, 0, Math.PI * 2);
                        this.selectionCtx.fill();
                        this.selectionCtx.stroke();
                    }
                }
            }
            
            performTransform(x, y, e) {
                if (!this.selection || !this.activeHandle || !this.transformStart) return;
                
                const dx = x - this.transformStart.x;
                const dy = y - this.transformStart.y;
                const shiftKey = e ? e.shiftKey : false;
                const altKey = e ? e.altKey : false;
                
                // Offset for converting display â†” frame-local coords
                const off = this.getSelectionDisplayOffset();
                
                if (this.activeHandle.type === 'move') {
                    // Move selection and anchor point together
                    this.selection.bounds.x += dx;
                    this.selection.bounds.y += dy;
                    this.selection.anchorX += dx;
                    this.selection.anchorY += dy;
                    // Also move distort corners if they exist
                    if (this.selection.corners) {
                        for (const c of this.selection.corners) {
                            c.x += dx;
                            c.y += dy;
                        }
                    }
                    this.transformStart = { x, y };
                } else if (this.activeHandle.type === 'anchor') {
                    // Move anchor point independently â€” convert display to frame-local
                    this.selection.anchorX = x - off.x;
                    this.selection.anchorY = y - off.y;
                } else if (this.activeHandle.type.startsWith('distort-')) {
                    // Distort: move individual corner freely
                    const idx = this.activeHandle.cornerIdx;
                    this.selection.corners[idx].x += dx;
                    this.selection.corners[idx].y += dy;
                    this.transformStart = { x, y };
                } else if (this.activeHandle.type === 'rotate' || this.isRotating) {
                    // Calculate rotation angle from anchor point (offset anchor to display space)
                    const anchorX = this.selection.anchorX + off.x;
                    const anchorY = this.selection.anchorY + off.y;
                    const currentAngle = Math.atan2(y - anchorY, x - anchorX);
                    const angleDelta = currentAngle - this.startAngle;
                    this.selection.rotation = this.initialRotation + angleDelta;
                } else if (this.tool === 'skew') {
                    // Skew: edge handles apply shear
                    const b = this.selection.bounds;
                    const type = this.activeHandle.type;
                    const isEdge = type === 'n' || type === 's' || type === 'e' || type === 'w';
                    
                    if (isEdge) {
                        if (type === 'n' || type === 's') {
                            // Horizontal skew
                            this.selection.skewX = (this.selection.skewX || 0) + dx / b.height;
                        } else {
                            // Vertical skew
                            this.selection.skewY = (this.selection.skewY || 0) + dy / b.width;
                        }
                        this.transformStart = { x, y };
                    } else {
                        // Corner handles: resize as normal
                        this._performResize(dx, dy, shiftKey, altKey, x, y);
                    }
                } else {
                    // Resize selection
                    this._performResize(dx, dy, shiftKey, altKey, x, y);
                }
                
                this.showTransformHandles();
                this.render();
            }
            
            _performResize(dx, dy, shiftKey, altKey, rawX, rawY) {
                const b = this.selection.bounds;
                const type = this.activeHandle.type;
                
                // Shift = proportional scaling (lock aspect ratio) for corner handles
                if (shiftKey && (this.tool === 'scale' || this.tool === 'transform')) {
                    const isCorner = (type === 'nw' || type === 'ne' || type === 'sw' || type === 'se');
                    if (isCorner && b.width > 0 && b.height > 0) {
                        const signX = type.includes('e') ? 1 : -1;
                        const signY = type.includes('s') ? 1 : -1;
                        const scaleW = (b.width + dx * signX) / b.width;
                        const scaleH = (b.height + dy * signY) / b.height;
                        const scale = Math.abs(scaleW - 1) > Math.abs(scaleH - 1) ? scaleW : scaleH;
                        dx = (scale * b.width - b.width) * signX;
                        dy = (scale * b.height - b.height) * signY;
                    }
                }
                
                // Alt (Option) = scale from center: apply resize symmetrically
                if (altKey && (this.tool === 'scale' || this.tool === 'transform')) {
                    if (type.includes('n')) {
                        const g = -dy;
                        if (b.height + g * 2 > 10) { b.y -= g; b.height += g * 2; }
                    }
                    if (type.includes('s')) {
                        const g = dy;
                        if (b.height + g * 2 > 10) { b.y -= g; b.height += g * 2; }
                    }
                    if (type.includes('w')) {
                        const g = -dx;
                        if (b.width + g * 2 > 10) { b.x -= g; b.width += g * 2; }
                    }
                    if (type.includes('e')) {
                        const g = dx;
                        if (b.width + g * 2 > 10) { b.x -= g; b.width += g * 2; }
                    }
                    this.selection.anchorX = b.x + b.width / 2;
                    this.selection.anchorY = b.y + b.height / 2;
                    if (this.selection.corners) {
                        this.selection.corners = [
                            { x: b.x, y: b.y },
                            { x: b.x + b.width, y: b.y },
                            { x: b.x + b.width, y: b.y + b.height },
                            { x: b.x, y: b.y + b.height }
                        ];
                    }
                    this.transformStart = { x: rawX, y: rawY };
                    return;
                }
                
                if (type.includes('n')) {
                    const newY = b.y + dy;
                    const newHeight = b.height - dy;
                    if (newHeight > 10) {
                        b.y = newY;
                        b.height = newHeight;
                    }
                }
                if (type.includes('s')) {
                    b.height += dy;
                    if (b.height < 10) b.height = 10;
                }
                if (type.includes('w')) {
                    const newX = b.x + dx;
                    const newWidth = b.width - dx;
                    if (newWidth > 10) {
                        b.x = newX;
                        b.width = newWidth;
                    }
                }
                if (type.includes('e')) {
                    b.width += dx;
                    if (b.width < 10) b.width = 10;
                }
                
                // Update corners to match new bounds
                if (this.selection.corners) {
                    this.selection.corners = [
                        { x: b.x, y: b.y },
                        { x: b.x + b.width, y: b.y },
                        { x: b.x + b.width, y: b.y + b.height },
                        { x: b.x, y: b.y + b.height }
                    ];
                }
                
                this.transformStart = { x: rawX, y: rawY };
            }
            
            // Shared selection preview: handles rotation, skew, and distort
            _drawSelectionPreview(ctx) {
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                const skewX = this.selection.skewX || 0;
                const skewY = this.selection.skewY || 0;
                
                // Offset from frame-local coords to display canvas coords
                const off = this.getSelectionDisplayOffset();
                
                // Distort mode: draw image mapped to free quad
                if (this.tool === 'distort' && this.selection.corners) {
                    // Offset corners to display space
                    const displayCorners = this.selection.corners.map(c => ({
                        x: c.x + off.x, y: c.y + off.y
                    }));
                    this._drawImageToQuad(ctx, this.selection.imageData, displayCorners);
                    return;
                }
                
                const rotation = this.selection.rotation || 0;
                const anchorX = (this.selection.anchorX || (b.x + b.width / 2)) + off.x;
                const anchorY = (this.selection.anchorY || (b.y + b.height / 2)) + off.y;
                
                ctx.save();
                ctx.translate(anchorX, anchorY);
                ctx.rotate(rotation);
                if (skewX || skewY) {
                    ctx.transform(1, skewY, skewX, 1, 0, 0);
                }
                ctx.translate(-anchorX, -anchorY);
                ctx.drawImage(this.selection.imageData, b.x + off.x, b.y + off.y, b.width, b.height);
                ctx.restore();
            }
            
            applySelection() {
                if (!this.selection) return;
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                const skewX = this.selection.skewX || 0;
                const skewY = this.selection.skewY || 0;
                
                if (this.selection.corners && this.tool === 'distort') {
                    // Distort: map image to arbitrary quad using two triangles
                    this._drawImageToQuad(frameCtx, this.selection.imageData, this.selection.corners);
                } else {
                    frameCtx.save();
                    
                    // Apply transform around anchor point
                    frameCtx.translate(anchorX, anchorY);
                    frameCtx.rotate(rotation);
                    // Apply skew via transform matrix: [1, skewY, skewX, 1, 0, 0]
                    if (skewX || skewY) {
                        frameCtx.transform(1, skewY, skewX, 1, 0, 0);
                    }
                    frameCtx.translate(-anchorX, -anchorY);
                    
                    frameCtx.drawImage(
                        this.selection.imageData,
                        b.x, b.y, b.width, b.height
                    );
                    
                    frameCtx.restore();
                }
                
                // Update timeline indicator â€” frame now has content
                this._dirtyThumb(frame);
                this._timelineDirty = true;
                this.renderTimeline();
            }
            
            // Draw an image mapped onto an arbitrary quadrilateral using triangle subdivision
            _drawImageToQuad(ctx, img, corners) {
                const sw = img.width;
                const sh = img.height;
                const c = corners; // TL, TR, BR, BL
                
                // Subdivide into grid for smoother mapping
                const divisions = 8;
                
                ctx.save();
                for (let gy = 0; gy < divisions; gy++) {
                    for (let gx = 0; gx < divisions; gx++) {
                        const u0 = gx / divisions, u1 = (gx + 1) / divisions;
                        const v0 = gy / divisions, v1 = (gy + 1) / divisions;
                        
                        // Bilinear interpolation of corner positions
                        const lerp2d = (u, v) => ({
                            x: (1-u)*(1-v)*c[0].x + u*(1-v)*c[1].x + u*v*c[2].x + (1-u)*v*c[3].x,
                            y: (1-u)*(1-v)*c[0].y + u*(1-v)*c[1].y + u*v*c[2].y + (1-u)*v*c[3].y
                        });
                        
                        const p00 = lerp2d(u0, v0);
                        const p10 = lerp2d(u1, v0);
                        const p11 = lerp2d(u1, v1);
                        const p01 = lerp2d(u0, v1);
                        
                        // Source rect in image
                        const sx0 = u0 * sw, sx1 = u1 * sw;
                        const sy0 = v0 * sh, sy1 = v1 * sh;
                        const ssw = sx1 - sx0, ssh = sy1 - sy0;
                        
                        // Draw two triangles for this cell
                        this._drawTriangle(ctx, img,
                            sx0, sy0, ssw, ssh,
                            p00.x, p00.y, p10.x, p10.y, p01.x, p01.y,
                            0, 0, 1, 0, 0, 1);
                        this._drawTriangle(ctx, img,
                            sx0, sy0, ssw, ssh,
                            p10.x, p10.y, p11.x, p11.y, p01.x, p01.y,
                            1, 0, 1, 1, 0, 1);
                    }
                }
                ctx.restore();
            }
            
            _drawTriangle(ctx, img, sx, sy, sw, sh, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.closePath();
                ctx.clip();
                
                // Affine transform from UV to destination
                const denom = u0*(v1-v2) - u1*(v0-v2) + u2*(v0-v1);
                if (Math.abs(denom) < 1e-10) { ctx.restore(); return; }
                
                const a = (x0*(v1-v2) - x1*(v0-v2) + x2*(v0-v1)) / denom;
                const b = -(x0*(u1-u2) - x1*(u0-u2) + x2*(u0-u1)) / denom;
                const c = (x0*(u1*v2-u2*v1) - x1*(u0*v2-u2*v0) + x2*(u0*v1-u1*v0)) / denom;
                const d = (y0*(v1-v2) - y1*(v0-v2) + y2*(v0-v1)) / denom;
                const e = -(y0*(u1-u2) - y1*(u0-u2) + y2*(u0-u1)) / denom;
                const f = (y0*(u1*v2-u2*v1) - y1*(u0*v2-u2*v0) + y2*(u0*v1-u1*v0)) / denom;
                
                ctx.setTransform(a, d, b, e, c, f);
                ctx.drawImage(img, sx, sy, sw, sh, 0, 0, 1, 1);
                ctx.restore();
            }
            
            clearSelection() {
                this.selection = null;
                this.transformHandles = [];
                this.selectionUndoStack = [];
                this.selectionRedoStack = [];
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                this.updateUndoRedoButtons();
            }
            
            saveSelectionState() {
                if (!this.selection) return;
                this.selectionUndoStack.push({
                    bounds: { ...this.selection.bounds },
                    originalBounds: { ...this.selection.originalBounds },
                    rotation: this.selection.rotation || 0,
                    anchorX: this.selection.anchorX,
                    anchorY: this.selection.anchorY
                });
                // New transform action invalidates redo history
                this.selectionRedoStack = [];
                this.updateUndoRedoButtons();
            }
            
            restoreSelectionState() {
                if (!this.selection || this.selectionUndoStack.length === 0) return false;
                // Save current state to redo stack before restoring
                this.selectionRedoStack.push({
                    bounds: { ...this.selection.bounds },
                    originalBounds: { ...this.selection.originalBounds },
                    rotation: this.selection.rotation || 0,
                    anchorX: this.selection.anchorX,
                    anchorY: this.selection.anchorY
                });
                const state = this.selectionUndoStack.pop();
                this.selection.bounds = { ...state.bounds };
                this.selection.originalBounds = { ...state.originalBounds };
                this.selection.rotation = state.rotation;
                this.selection.anchorX = state.anchorX;
                this.selection.anchorY = state.anchorY;
                this.showTransformHandles();
                this.render();
                this.updateUndoRedoButtons();
                return true;
            }
            
            redoSelectionState() {
                if (!this.selection || this.selectionRedoStack.length === 0) return false;
                // Save current state to undo stack before redoing
                this.selectionUndoStack.push({
                    bounds: { ...this.selection.bounds },
                    originalBounds: { ...this.selection.originalBounds },
                    rotation: this.selection.rotation || 0,
                    anchorX: this.selection.anchorX,
                    anchorY: this.selection.anchorY
                });
                const state = this.selectionRedoStack.pop();
                this.selection.bounds = { ...state.bounds };
                this.selection.originalBounds = { ...state.originalBounds };
                this.selection.rotation = state.rotation;
                this.selection.anchorX = state.anchorX;
                this.selection.anchorY = state.anchorY;
                this.showTransformHandles();
                this.render();
                this.updateUndoRedoButtons();
                return true;
            }
            
            // Apply any active selection back to its frame and dismiss it
            commitSelection() {
                if (this.selection) {
                    this.applySelection();
                    const _layer = this.getCurrentLayer();
                    if (_layer) this._dirtyThumb(_layer.frames[this.currentFrameIndex]);
                    this.clearSelection();
                }
            }
            
            // Clipboard Methods - Selection
            copySelection() {
                if (!this.selection) return;
                
                // Deep copy the selection image data to a new canvas
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = this.selection.imageData.width;
                copyCanvas.height = this.selection.imageData.height;
                const copyCtx = copyCanvas.getContext('2d');
                copyCtx.drawImage(this.selection.imageData, 0, 0);
                
                this.copiedSelection = {
                    imageData: copyCanvas,
                    width: this.selection.bounds.width,
                    height: this.selection.bounds.height,
                    x: this.selection.bounds.x,
                    y: this.selection.bounds.y
                };
                
                // Apply selection back to the frame and dismiss bounding box
                this.applySelection();
                this.clearSelection();
                this.selectTool('brush');
                this.render();
            }
            
            pasteSelection() {
                if (!this.copiedSelection) return;
                
                // Apply any current selection first
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                this.saveState();
                
                // Create a new canvas copy for the pasted selection
                const pasteCanvas = document.createElement('canvas');
                pasteCanvas.width = this.copiedSelection.imageData.width;
                pasteCanvas.height = this.copiedSelection.imageData.height;
                const pasteCtx = pasteCanvas.getContext('2d');
                pasteCtx.drawImage(this.copiedSelection.imageData, 0, 0);
                
                // Paste centered on project area (frame-local coords)
                const centerX = Math.round((this.projectWidth - this.copiedSelection.width) / 2);
                const centerY = Math.round((this.projectHeight - this.copiedSelection.height) / 2);
                
                this.selection = {
                    imageData: pasteCanvas,
                    bounds: {
                        x: centerX,
                        y: centerY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    },
                    originalBounds: {
                        x: centerX,
                        y: centerY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    }
                };
                
                // Switch to transform tool so the user can position it
                this.selectTool('transform');
                this.render();
            }
            
            pasteSelectionInPlace() {
                if (!this.copiedSelection) return;
                
                // Apply any current selection first
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                this.saveState();
                
                // Create a new canvas copy for the pasted selection
                const pasteCanvas = document.createElement('canvas');
                pasteCanvas.width = this.copiedSelection.imageData.width;
                pasteCanvas.height = this.copiedSelection.imageData.height;
                const pasteCtx = pasteCanvas.getContext('2d');
                pasteCtx.drawImage(this.copiedSelection.imageData, 0, 0);
                
                // Paste at original position
                const origX = this.copiedSelection.x;
                const origY = this.copiedSelection.y;
                
                this.selection = {
                    imageData: pasteCanvas,
                    bounds: {
                        x: origX,
                        y: origY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    },
                    originalBounds: {
                        x: origX,
                        y: origY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    }
                };
                
                // Switch to transform tool
                this.selectTool('transform');
                this.render();
            }
            
            // Clipboard Methods - Frames
            copyFrame(frameIndex) {
                const layer = this.getCurrentLayer();
                
                // Multi-frame copy if frames are selected
                if (this.selectedFrames.size > 1) {
                    const sortedIndices = [...this.selectedFrames].sort((a, b) => a - b);
                    // Preserve hold frame relationships: frames sharing a canvas
                    // in the source should share a canvas in the copy
                    const srcToCopy = new Map(); // source canvas â†’ copied canvas
                    this.copiedFrames = sortedIndices.map(idx => {
                        const src = layer.frames[idx];
                        if (!src) return null;
                        // If we already copied this canvas (hold frame), reuse the copy
                        if (srcToCopy.has(src)) {
                            return srcToCopy.get(src);
                        }
                        const c = document.createElement('canvas');
                        c.width = src.width;
                        c.height = src.height;
                        c._originX = src._originX || 0;
                        c._originY = src._originY || 0;
                        c.getContext('2d').drawImage(src, 0, 0);
                        srcToCopy.set(src, c);
                        return c;
                    }).filter(Boolean);
                    this.copiedFrame = this.copiedFrames[0];
                    return;
                }
                
                // Single frame copy
                const idx = (frameIndex !== undefined) ? frameIndex : this.currentFrameIndex;
                const sourceFrame = layer.frames[idx];
                if (!sourceFrame) return;
                
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = sourceFrame.width;
                copyCanvas.height = sourceFrame.height;
                copyCanvas._originX = sourceFrame._originX || 0;
                copyCanvas._originY = sourceFrame._originY || 0;
                copyCanvas.getContext('2d').drawImage(sourceFrame, 0, 0);
                
                this.copiedFrame = copyCanvas;
                this.copiedFrames = [copyCanvas];
            }
            
            isFrameBlank(frame) {
                if (!frame) return true;
                const ctx = frame.getContext('2d');
                const data = ctx.getImageData(0, 0, frame.width, frame.height).data;
                // Check alpha channel only â€” any non-zero alpha means content exists
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0) return false;
                }
                return true;
            }
            
            pasteFrame(afterIndex) {
                if (!this.copiedFrame && this.copiedFrames.length === 0) return;
                
                this.commitSelection();
                this.saveFullState();
                
                const layer = this.getCurrentLayer();
                const idx = (afterIndex !== undefined) ? afterIndex : this.currentFrameIndex;
                
                const framesToPaste = (this.copiedFrames.length > 1) ? this.copiedFrames : [this.copiedFrame];
                
                // Preserve hold frame relationships: if copied frames share a canvas,
                // create one new canvas and reference it from all corresponding positions
                const srcToPasted = new Map(); // copied canvas â†’ new canvas
                const newFrames = framesToPaste.map(src => {
                    if (srcToPasted.has(src)) {
                        return srcToPasted.get(src); // Same reference = hold frame
                    }
                    const nf = document.createElement('canvas');
                    nf.width = src.width;
                    nf.height = src.height;
                    nf._originX = src._originX || 0;
                    nf._originY = src._originY || 0;
                    nf.getContext('2d').drawImage(src, 0, 0);
                    srcToPasted.set(src, nf);
                    return nf;
                });
                
                // If the target frame is blank, replace it with the first pasted frame
                // and insert the rest after it
                const targetBlank = this.isFrameBlank(layer.frames[idx]);
                
                if (targetBlank) {
                    layer.frames[idx] = newFrames[0];
                    if (newFrames.length > 1) {
                        layer.frames.splice(idx + 1, 0, ...newFrames.slice(1));
                    }
                    
                    this.selectedFrames.clear();
                    for (let i = 0; i < newFrames.length; i++) {
                        this.selectedFrames.add(idx + i);
                    }
                    this.currentFrameIndex = idx + newFrames.length - 1;
                } else {
                    layer.frames.splice(idx + 1, 0, ...newFrames);
                    
                    this.selectedFrames.clear();
                    for (let i = 0; i < newFrames.length; i++) {
                        this.selectedFrames.add(idx + 1 + i);
                    }
                    this.currentFrameIndex = idx + newFrames.length;
                }
                
                this.render();
                this._scrollTimelineToFrame(this.currentFrameIndex);
            }
            
            duplicateFrame(frameIndex) {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                
                // Multi-frame duplicate
                if (this.selectedFrames.size > 1) {
                    this.saveFullState();
                    
                    const sortedIndices = [...this.selectedFrames].sort((a, b) => a - b);
                    const lastIdx = sortedIndices[sortedIndices.length - 1];
                    
                    // Preserve hold frame relationships
                    const srcToDup = new Map();
                    const newFrames = sortedIndices.map(idx => {
                        const src = layer.frames[idx];
                        if (!src) return null;
                        if (srcToDup.has(src)) {
                            return srcToDup.get(src); // Hold frame â€” same reference
                        }
                        const nf = document.createElement('canvas');
                        nf.width = src.width;
                        nf.height = src.height;
                        nf._originX = src._originX || 0;
                        nf._originY = src._originY || 0;
                        nf.getContext('2d').drawImage(src, 0, 0);
                        srcToDup.set(src, nf);
                        return nf;
                    }).filter(Boolean);
                    
                    // Insert after the last selected frame
                    layer.frames.splice(lastIdx + 1, 0, ...newFrames);
                    
                    // Select the duplicated range
                    this.selectedFrames.clear();
                    for (let i = 0; i < newFrames.length; i++) {
                        this.selectedFrames.add(lastIdx + 1 + i);
                    }
                    this.currentFrameIndex = lastIdx + newFrames.length;
                    
                    if (this.frameSelectMode) {
                        this._updateSelectBanner();
                    }
                    this.render();
                    this._scrollTimelineToFrame(this.currentFrameIndex);
                    return;
                }
                
                // Single frame duplicate
                const idx = (frameIndex !== undefined) ? frameIndex : this.currentFrameIndex;
                const sourceFrame = layer.frames[idx];
                if (!sourceFrame) return;
                
                this.saveFullState();
                
                const newFrame = document.createElement('canvas');
                newFrame.width = sourceFrame.width;
                newFrame.height = sourceFrame.height;
                newFrame._originX = sourceFrame._originX || 0;
                newFrame._originY = sourceFrame._originY || 0;
                newFrame.getContext('2d').drawImage(sourceFrame, 0, 0);
                
                layer.frames.splice(idx + 1, 0, newFrame);
                this.currentFrameIndex = idx + 1;
                this.render();
                this._scrollTimelineToFrame(this.currentFrameIndex);
            }
            
            // Update the gradient swatch preview
            _updateGradientSwatch() {
                const swatch = document.getElementById('gradientSwatch');
                if (!swatch) return;
                const cA = this.color;
                const cB = this.colorB;
                if (this.gradientType === 'linear') {
                    swatch.style.background = `linear-gradient(to right, ${cA}, ${cB})`;
                } else {
                    swatch.style.background = `radial-gradient(circle, ${cA}, ${cB})`;
                }
                // Sync stored state
                swatch.classList.toggle('has-gradient', this.gradientDef !== null);
            }
            
            // Master UI sync â€” call whenever gradientDef, tool, or colors change
            _syncGradientUI() {
                const colorWrap = document.getElementById('colorPickersWrap');
                const swatch = document.getElementById('gradientSwatch');
                const fillBtn = document.getElementById('fillTool');
                const hasStored = this.gradientDef !== null;
                const isGradTool = this.tool === 'gradient';
                
                // gradient-active: show full controls (pickers, swap, type toggle)
                colorWrap.classList.toggle('gradient-active', isGradTool);
                
                // gradient-stored: show just the swatch even when not on gradient tool
                colorWrap.classList.toggle('gradient-stored', hasStored && !isGradTool);
                
                // Badge on fill tool button
                fillBtn.classList.toggle('has-stored-gradient', hasStored);
                
                // Swatch state
                this._updateGradientSwatch();
                
                // Update fill tool tooltip
                if (hasStored) {
                    fillBtn.title = 'Fill with stored gradient (F)';
                } else {
                    fillBtn.title = 'Paint Bucket (K / F)';
                }
            }
            
            // Draw gradient preview line on the canvas during drag
            _drawGradientPreview() {
                if (!this._gradientDrag) return;
                const drag = this._gradientDrag;
                const s = drag.startLocal;
                const end = drag.endLocal;
                
                // Render the live gradient fill preview into the mask region
                // Only if mask matches current frame context
                const dist = Math.hypot(end.x - s.x, end.y - s.y);
                if (dist > 3 && this._gradientMaskCache) {
                    this._renderGradientMaskPreview(s, end);
                }
                
                // Convert frame-local coords to canvas (screen) coords
                const sx = s.x + drag.originX - this.viewportX;
                const sy = s.y + drag.originY - this.viewportY;
                const ex = end.x + drag.originX - this.viewportX;
                const ey = end.y + drag.originY - this.viewportY;
                
                const ctx = this.ctx;
                ctx.save();
                
                // Draw the gradient line
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw color A circle at start
                ctx.beginPath();
                ctx.arc(sx, sy, 8, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw color B circle at end
                ctx.beginPath();
                ctx.arc(ex, ey, 8, 0, Math.PI * 2);
                ctx.fillStyle = this.colorB;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw a small gradient preview rectangle along the midpoint
                const mx = (sx + ex) / 2;
                const my = (sy + ey) / 2;
                const angle = Math.atan2(ey - sy, ex - sx);
                const previewW = Math.min(60, Math.hypot(ex - sx, ey - sy) * 0.5);
                const previewH = 12;
                
                if (previewW > 10) {
                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle);
                    
                    // Create gradient for the preview bar
                    const pg = ctx.createLinearGradient(-previewW / 2, 0, previewW / 2, 0);
                    pg.addColorStop(0, this.color);
                    pg.addColorStop(1, this.colorB);
                    
                    ctx.fillStyle = pg;
                    ctx.beginPath();
                    const r = 4;
                    ctx.roundRect(-previewW / 2, -previewH / 2, previewW, previewH, r);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.restore();
            }
            
            // Draw the gradient edit mode overlay â€” shows handles, line, and gradient preview
            _drawGradientEditPreview() {
                if (!this._gradientEdit) return;
                // Only show on the frame/layer where the gradient was started
                if (this._gradientEdit.frameIndex !== this.currentFrameIndex ||
                    this._gradientEdit.layerId !== this.currentLayerId) return;
                const edit = this._gradientEdit;
                const s = edit.startLocal;
                const end = edit.endLocal;
                
                // Render the live gradient fill preview into the mask region
                this._renderGradientMaskPreview(s, end);
                
                // Convert frame-local to canvas coords
                const sx = s.x + edit.originX - this.viewportX;
                const sy = s.y + edit.originY - this.viewportY;
                const ex = end.x + edit.originX - this.viewportX;
                const ey = end.y + edit.originY - this.viewportY;
                
                const ctx = this.ctx;
                ctx.save();
                
                const mx = (sx + ex) / 2;
                const my = (sy + ey) / 2;
                
                // Gradient line
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Shadow line underneath for contrast
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 4;
                ctx.setLineDash([6, 4]);
                ctx.lineDashOffset = 3;
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
                
                // Color A handle (start) â€” larger, with label
                const handleRadius = 10;
                ctx.beginPath();
                ctx.arc(sx, sy, handleRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // "A" label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Check luminance to pick label color
                const aRgb = this.hexToRgb(this.color);
                const aLum = (aRgb.r * 299 + aRgb.g * 587 + aRgb.b * 114) / 1000;
                ctx.fillStyle = aLum > 128 ? '#000' : '#fff';
                ctx.fillText('A', sx, sy);
                
                // Color B handle (end)
                ctx.beginPath();
                ctx.arc(ex, ey, handleRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.colorB;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // "B" label
                const bRgb = this.hexToRgb(this.colorB);
                const bLum = (bRgb.r * 299 + bRgb.g * 587 + bRgb.b * 114) / 1000;
                ctx.fillStyle = bLum > 128 ? '#000' : '#fff';
                ctx.font = 'bold 9px system-ui, sans-serif';
                ctx.fillText('B', ex, ey);
                
                // Gradient preview bar at midpoint
                const angle = Math.atan2(ey - sy, ex - sx);
                const previewW = Math.min(80, Math.hypot(ex - sx, ey - sy) * 0.6);
                const previewH = 14;
                
                if (previewW > 15) {
                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle);
                    
                    let pg;
                    if (this.gradientType === 'radial') {
                        pg = ctx.createRadialGradient(0, 0, 0, 0, 0, previewW / 2);
                    } else {
                        pg = ctx.createLinearGradient(-previewW / 2, 0, previewW / 2, 0);
                    }
                    pg.addColorStop(0, this.color);
                    pg.addColorStop(1, this.colorB);
                    
                    ctx.fillStyle = pg;
                    ctx.beginPath();
                    ctx.roundRect(-previewW / 2, -previewH / 2, previewW, previewH, 5);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Hint text
                ctx.fillStyle = 'rgba(255,255,255,0.55)';
                ctx.font = '11px system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const hintY = Math.max(sy, ey) + 24;
                ctx.fillText('Drag handles to adjust Â· Enter to apply Â· Esc to cancel', mx, hintY);
                
                ctx.restore();
                
                // Position floating confirm/cancel buttons near end handle
                this._updateGradConfirmBtns(ex, ey);
            }
            
            // Position gradient confirm/cancel buttons near a canvas point
            _updateGradConfirmBtns(canvasX, canvasY) {
                if (!this._gradConfirmBtns) return;
                const rect = this.canvas.getBoundingClientRect();
                const containerRect = this.canvasContainer.getBoundingClientRect();
                const scaleX = rect.width / this.canvas.width;
                const scaleY = rect.height / this.canvas.height;
                let left = rect.left - containerRect.left + canvasX * scaleX + 24;
                let top = rect.top - containerRect.top + canvasY * scaleY - 20;
                // Clamp to container bounds
                left = Math.max(4, Math.min(left, containerRect.width - 80));
                top = Math.max(4, Math.min(top, containerRect.height - 40));
                this._gradConfirmBtns.style.left = left + 'px';
                this._gradConfirmBtns.style.top = top + 'px';
                this._gradConfirmBtns.classList.add('show');
            }
            
            _hideGradConfirmBtns() {
                if (this._gradConfirmBtns) {
                    this._gradConfirmBtns.classList.remove('show');
                }
            }
            
            // Finalize the gradient edit â€” apply the fill
            _finalizeGradient() {
                if (!this._gradientEdit) return;
                const edit = this._gradientEdit;
                
                const gradDef = {
                    type: this.gradientType,
                    colorA: this.color,
                    colorB: this.colorB,
                    x0: edit.startLocal.x,
                    y0: edit.startLocal.y,
                    x1: edit.endLocal.x,
                    y1: edit.endLocal.y,
                };
                
                this._gradientEdit = null;
                this._gradientMaskCache = null;
                this._hideGradConfirmBtns();
                this.gradientFill(Math.floor(gradDef.x0), Math.floor(gradDef.y0), gradDef);
            }
            
            // Cancel the gradient edit â€” discard without filling
            _cancelGradient() {
                if (!this._gradientEdit) return;
                this._gradientEdit = null;
                this._gradientMaskCache = null;
                this._hideGradConfirmBtns();
                this.renderCanvasOnly();
            }
            
            // Refresh the gradient edit preview (call when colors or type change during edit)
            _refreshGradientEdit() {
                if (!this._gradientEdit) return;
                this.renderCanvasOnly();
            }
            
            // Compute the fill mask for gradient preview â€” same neighbor-walk as gradientFill
            // Returns { mask: Uint8Array, width, height, originX, originY } or null
            _computeGradientMask(frame, startX, startY) {
                const width = frame.width;
                const height = frame.height;
                if (startX < 0 || startX >= width || startY < 0 || startY >= height) return null;
                
                const imageData = frame.getContext('2d').getImageData(0, 0, width, height);
                const data = imageData.data;
                const startPos = (startY * width + startX) * 4;
                
                if (data[startPos + 3] < 5) {
                    // Clicked on transparent â€” do a simple transparent-region fill
                    const visited = new Uint8Array(width * height);
                    const startIdx = startX + startY * width;
                    const stack = [startIdx];
                    visited[startIdx] = 1;
                    while (stack.length > 0) {
                        const idx = stack.pop();
                        const cx = idx % width;
                        const cy = (idx - cx) / width;
                        const neighbors = [];
                        if (cx > 0) neighbors.push(idx - 1);
                        if (cx < width - 1) neighbors.push(idx + 1);
                        if (cy > 0) neighbors.push(idx - width);
                        if (cy < height - 1) neighbors.push(idx + width);
                        for (const nIdx of neighbors) {
                            if (visited[nIdx]) continue;
                            if (data[nIdx * 4 + 3] < 30) {
                                visited[nIdx] = 1;
                                stack.push(nIdx);
                            }
                        }
                    }
                    // Expand by 3px
                    const expanded = new Uint8Array(visited);
                    for (let pass = 0; pass < 3; pass++) {
                        const src = new Uint8Array(expanded);
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const idx = y * width + x;
                                if (src[idx]) continue;
                                if ((x > 0 && src[idx - 1]) || (x < width - 1 && src[idx + 1]) ||
                                    (y > 0 && src[idx - width]) || (y < height - 1 && src[idx + width])) {
                                    expanded[idx] = 1;
                                }
                            }
                        }
                    }
                    return { mask: expanded, width, height, originX: frame._originX || 0, originY: frame._originY || 0 };
                }
                
                const stepTolerance = 32;
                const visited = new Uint8Array(width * height);
                const startIdx = startX + startY * width;
                const stack = [startIdx];
                visited[startIdx] = 1;
                
                while (stack.length > 0) {
                    const idx = stack.pop();
                    const cx = idx % width;
                    const cy = (idx - cx) / width;
                    const cPos = idx * 4;
                    const cR = data[cPos], cG = data[cPos + 1], cB = data[cPos + 2], cA = data[cPos + 3];
                    
                    const neighbors = [];
                    if (cx > 0) neighbors.push(idx - 1);
                    if (cx < width - 1) neighbors.push(idx + 1);
                    if (cy > 0) neighbors.push(idx - width);
                    if (cy < height - 1) neighbors.push(idx + width);
                    
                    for (const nIdx of neighbors) {
                        if (visited[nIdx]) continue;
                        const nPos = nIdx * 4;
                        const nA = data[nPos + 3];
                        if (nA < 30 && cA < 30) { visited[nIdx] = 1; stack.push(nIdx); continue; }
                        if (nA < 30 || cA < 30) continue;
                        if (Math.abs(data[nPos] - cR) <= stepTolerance &&
                            Math.abs(data[nPos + 1] - cG) <= stepTolerance &&
                            Math.abs(data[nPos + 2] - cB) <= stepTolerance &&
                            Math.abs(nA - cA) <= stepTolerance) {
                            visited[nIdx] = 1;
                            stack.push(nIdx);
                        }
                    }
                }
                
                // Expand by 3px
                const expanded = new Uint8Array(visited);
                for (let pass = 0; pass < 3; pass++) {
                    const src = new Uint8Array(expanded);
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            if (src[idx]) continue;
                            if ((x > 0 && src[idx - 1]) || (x < width - 1 && src[idx + 1]) ||
                                (y > 0 && src[idx - width]) || (y < height - 1 && src[idx + width])) {
                                expanded[idx] = 1;
                            }
                        }
                    }
                }
                
                return { mask: expanded, width, height, originX: frame._originX || 0, originY: frame._originY || 0 };
            }
            
            // Render a live gradient preview into the cached mask region on the display canvas
            _renderGradientMaskPreview(startLocal, endLocal) {
                const mc = this._gradientMaskCache;
                if (!mc) return;
                
                // Only render on the exact frame where the mask was computed
                if (mc.frameIndex !== this.currentFrameIndex || 
                    mc.layerId !== this.currentLayerId) return;
                
                // Build a temporary canvas with the gradient masked to the fill region
                const tmp = document.createElement('canvas');
                tmp.width = mc.width;
                tmp.height = mc.height;
                const tCtx = tmp.getContext('2d');
                
                // Draw gradient onto temp canvas
                let grad;
                if (this.gradientType === 'radial') {
                    const radius = Math.max(1, Math.hypot(endLocal.x - startLocal.x, endLocal.y - startLocal.y));
                    grad = tCtx.createRadialGradient(startLocal.x, startLocal.y, 0, startLocal.x, startLocal.y, radius);
                } else {
                    grad = tCtx.createLinearGradient(startLocal.x, startLocal.y, endLocal.x, endLocal.y);
                }
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, this.colorB);
                tCtx.fillStyle = grad;
                tCtx.fillRect(0, 0, mc.width, mc.height);
                
                // Mask: zero out alpha outside the fill region
                const imgData = tCtx.getImageData(0, 0, mc.width, mc.height);
                const d = imgData.data;
                for (let i = 0; i < mc.width * mc.height; i++) {
                    if (!mc.mask[i]) {
                        d[i * 4 + 3] = 0;
                    }
                    // Full opacity inside mask â€” no more 85% reduction
                }
                tCtx.putImageData(imgData, 0, 0);
                
                // Draw onto the main display canvas at the frame's position
                const drawX = mc.originX - this.viewportX;
                const drawY = mc.originY - this.viewportY;
                this.ctx.drawImage(tmp, drawX, drawY);
            }
            gradientFill(startX, startY, gradDef) {
                // Flush any pending async saveState from a previous brush stroke
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    if (this._pendingSnapshot) {
                        this._pushUndo(this._pendingSnapshot);
                        this._pendingSnapshot = null;
                    } else {
                        this.saveState();
                    }
                }
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const width = frame.width;
                const height = frame.height;
                
                const imageData = frameCtx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;
                
                const startPos = (startY * width + startX) * 4;
                const targetR = data[startPos];
                const targetG = data[startPos + 1];
                const targetB = data[startPos + 2];
                const targetA = data[startPos + 3];
                
                this.saveState();
                
                const stepTolerance = 32; // per-neighbor step tolerance (captures smooth gradients)
                
                // === PASS 1: Neighbor-walk flood fill â†’ build region mask ===
                // Unlike solid fill, we compare each pixel to its NEIGHBOR, not the start pixel.
                // This naturally follows gradients since each step is a small color change.
                const visited = new Uint8Array(width * height);
                
                const startIdx = startX + startY * width;
                const stack = [startIdx];
                visited[startIdx] = 1;
                let filledCount = 1;
                
                while (stack.length > 0) {
                    const idx = stack.pop();
                    const cx = idx % width;
                    const cy = (idx - cx) / width;
                    const cPos = idx * 4;
                    const cR = data[cPos], cG = data[cPos + 1], cB = data[cPos + 2], cA = data[cPos + 3];
                    
                    const neighbors = [];
                    if (cx > 0) neighbors.push(idx - 1);
                    if (cx < width - 1) neighbors.push(idx + 1);
                    if (cy > 0) neighbors.push(idx - width);
                    if (cy < height - 1) neighbors.push(idx + width);
                    
                    for (const nIdx of neighbors) {
                        if (visited[nIdx]) continue;
                        const nPos = nIdx * 4;
                        const nA = data[nPos + 3];
                        
                        // Both transparent â€” include (interior transparent)
                        if (nA < 30 && cA < 30) {
                            visited[nIdx] = 1;
                            filledCount++;
                            stack.push(nIdx);
                            continue;
                        }
                        // One transparent = edge boundary
                        if (nA < 30 || cA < 30) continue;
                        
                        // Compare neighbor to current pixel (not start pixel)
                        if (Math.abs(data[nPos] - cR) <= stepTolerance &&
                            Math.abs(data[nPos + 1] - cG) <= stepTolerance &&
                            Math.abs(data[nPos + 2] - cB) <= stepTolerance &&
                            Math.abs(nA - cA) <= stepTolerance) {
                            visited[nIdx] = 1;
                            filledCount++;
                            stack.push(nIdx);
                        }
                    }
                }
                
                if (filledCount === 0) return;
                
                // === PASS 2: Expand fill mask by 3px ===
                const expanded = new Uint8Array(visited);
                for (let pass = 0; pass < 3; pass++) {
                    const src = new Uint8Array(expanded);
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            if (src[idx]) continue;
                            if ((x > 0 && src[idx - 1]) ||
                                (x < width - 1 && src[idx + 1]) ||
                                (y > 0 && src[idx - width]) ||
                                (y < height - 1 && src[idx + width])) {
                                expanded[idx] = 1;
                            }
                        }
                    }
                }
                
                // === PASS 3a: Strip old fill from the region ===
                // Pixels inside the neighbor-walk region are fill â€” clear them.
                // Pixels in the expanded fringe but NOT visited are edge-bleed â€”
                // preserve anything that looks like linework (high contrast from its neighbors).
                for (let i = 0; i < width * height; i++) {
                    if (!expanded[i]) continue;
                    const pos = i * 4;
                    const a = data[pos + 3];
                    if (a === 0) continue;
                    
                    if (visited[i]) {
                        // Inside the walked region â†’ clear it for new gradient
                        data[pos + 3] = 0;
                    } else {
                        // Edge fringe â€” check if this pixel is close to a visited neighbor
                        // If so, it's fill bleed â†’ strip. If not, it's linework â†’ keep.
                        const px = i % width;
                        const py = (i - px) / width;
                        let nearestVisitedDiff = 999;
                        const offsets = [
                            px > 0 ? i - 1 : -1,
                            px < width - 1 ? i + 1 : -1,
                            py > 0 ? i - width : -1,
                            py < height - 1 ? i + width : -1,
                        ];
                        for (const ni of offsets) {
                            if (ni < 0 || !visited[ni]) continue;
                            const np = ni * 4;
                            if (data[np + 3] === 0) continue; // already cleared
                            const d = Math.max(
                                Math.abs(data[pos] - data[np]),
                                Math.abs(data[pos + 1] - data[np + 1]),
                                Math.abs(data[pos + 2] - data[np + 2])
                            );
                            nearestVisitedDiff = Math.min(nearestVisitedDiff, d);
                        }
                        if (nearestVisitedDiff < 60) {
                            // Close to fill color â†’ strip with soft fade
                            const fade = nearestVisitedDiff / 60;
                            data[pos + 3] = Math.round(a * fade);
                        }
                        // Otherwise keep as-is (linework)
                    }
                }
                
                // === PASS 3b: Paint gradient into fill region ===
                // Create full-canvas gradient, then mask to the expanded region
                const fillLayer = document.createElement('canvas');
                fillLayer.width = width;
                fillLayer.height = height;
                const fillLayerCtx = fillLayer.getContext('2d');
                
                // Build the CanvasGradient
                let canvasGrad;
                if (gradDef.type === 'radial') {
                    const cx = gradDef.x0;
                    const cy = gradDef.y0;
                    const radius = Math.hypot(gradDef.x1 - gradDef.x0, gradDef.y1 - gradDef.y0);
                    canvasGrad = fillLayerCtx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(1, radius));
                } else {
                    canvasGrad = fillLayerCtx.createLinearGradient(gradDef.x0, gradDef.y0, gradDef.x1, gradDef.y1);
                }
                canvasGrad.addColorStop(0, gradDef.colorA);
                canvasGrad.addColorStop(1, gradDef.colorB);
                
                // Fill entire canvas with gradient
                fillLayerCtx.fillStyle = canvasGrad;
                fillLayerCtx.fillRect(0, 0, width, height);
                
                // Mask: zero alpha outside expanded region
                const gradImgData = fillLayerCtx.getImageData(0, 0, width, height);
                const gd = gradImgData.data;
                for (let i = 0; i < width * height; i++) {
                    if (!expanded[i]) {
                        gd[i * 4 + 3] = 0;
                    }
                }
                fillLayerCtx.putImageData(gradImgData, 0, 0);
                
                // Put the stripped original into a temp canvas
                const strippedCanvas = document.createElement('canvas');
                strippedCanvas.width = width;
                strippedCanvas.height = height;
                const strippedCtx = strippedCanvas.getContext('2d');
                strippedCtx.putImageData(imageData, 0, 0);
                
                // Composite: gradient fill on bottom, stripped original on top
                frameCtx.clearRect(0, 0, width, height);
                frameCtx.drawImage(fillLayer, 0, 0);
                frameCtx.drawImage(strippedCanvas, 0, 0);
                
                // Store the gradient def so it can be replayed
                this.gradientDef = { ...gradDef };
                this._syncGradientUI();
                
                this._dirtyThumb(frame);
                this._invalidateCompositeCache();
                this.render();
            }
            
            // Eyedropper â€” sample composited pixel color from the display canvas
            _pickColor(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const px = Math.floor((e.clientX - rect.left) * scaleX);
                const py = Math.floor((e.clientY - rect.top) * scaleY);
                
                // Sample from the main display canvas which has all layers composited
                const pixel = this.ctx.getImageData(px, py, 1, 1).data;
                const r = pixel[0], g = pixel[1], b = pixel[2], a = pixel[3];
                
                if (a === 0) return; // Don't pick transparent
                
                const hex = '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
                this.color = hex;
                document.getElementById('colorPicker').value = hex;
                
                // Now try to detect a gradient in the connected region
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (frame) {
                    // Convert screen to frame-local coords
                    const worldX = px + this.viewportX;
                    const worldY = py + this.viewportY;
                    const local = this.worldToLocal(worldX, worldY, frame);
                    const lx = Math.floor(local.x);
                    const ly = Math.floor(local.y);
                    
                    const detected = this._detectGradient(frame, lx, ly);
                    if (detected) {
                        // Set both colors and store gradient def
                        this.color = detected.colorA;
                        this.colorB = detected.colorB;
                        this.gradientType = detected.type;
                        this.gradientDef = detected;
                        document.getElementById('colorPicker').value = detected.colorA;
                        document.getElementById('colorPickerB').value = detected.colorB;
                        document.querySelectorAll('.grad-type-btn').forEach(b => {
                            b.classList.toggle('active', b.dataset.gradtype === detected.type);
                        });
                        
                        // Sync all gradient UI state
                        this._syncGradientUI();
                        
                        // Flash the gradient swatch to confirm gradient pick
                        const swatch = document.getElementById('gradientSwatch');
                        swatch.style.transition = 'box-shadow 0.15s';
                        swatch.style.boxShadow = '0 0 0 3px rgba(106,173,255,0.7), 0 0 12px rgba(106,173,255,0.4)';
                        setTimeout(() => {
                            swatch.style.boxShadow = '';
                            setTimeout(() => { swatch.style.transition = ''; }, 200);
                        }, 500);
                        return;
                    }
                }
                
                // No gradient detected â€” clear any stored gradient, show solid color feedback
                this.gradientDef = null;
                this._syncGradientUI();
                
                // Brief visual flash on the color picker to confirm the pick
                const cp = document.getElementById('colorPicker');
                cp.style.transition = 'box-shadow 0.15s';
                cp.style.boxShadow = `0 0 0 3px ${hex}, 0 0 12px ${hex}80`;
                setTimeout(() => {
                    cp.style.boxShadow = '';
                    setTimeout(() => { cp.style.transition = ''; }, 200);
                }, 300);
            }
            
            // Detect if a region contains a gradient. Returns a gradientDef or null.
            _detectGradient(frame, startX, startY) {
                const frameCtx = frame.getContext('2d');
                const width = frame.width;
                const height = frame.height;
                
                if (startX < 0 || startX >= width || startY < 0 || startY >= height) return null;
                
                const imageData = frameCtx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                const startPos = (startY * width + startX) * 4;
                const targetR = data[startPos];
                const targetG = data[startPos + 1];
                const targetB = data[startPos + 2];
                const targetA = data[startPos + 3];
                
                if (targetA < 30) return null;
                
                // Relaxed flood fill to find the gradient region (higher tolerance)
                const tolerance = 120;
                const visited = new Uint8Array(width * height);
                
                const colorMatch = (idx) => {
                    const pos = idx * 4;
                    const a = data[pos + 3];
                    if (a < 30) return false; // Don't include transparent pixels
                    return Math.abs(data[pos] - targetR) <= tolerance &&
                           Math.abs(data[pos + 1] - targetG) <= tolerance &&
                           Math.abs(data[pos + 2] - targetB) <= tolerance &&
                           Math.abs(a - targetA) <= tolerance;
                };
                
                const stack = [startX + startY * width];
                let minX = startX, maxX = startX, minY = startY, maxY = startY;
                let count = 0;
                
                while (stack.length > 0) {
                    let idx = stack.pop();
                    let x = idx % width;
                    const y = (idx - x) / width;
                    
                    while (x > 0 && !visited[idx - 1] && colorMatch(idx - 1)) { x--; idx--; }
                    
                    let spanAbove = false, spanBelow = false;
                    
                    while (x < width && !visited[idx] && colorMatch(idx)) {
                        visited[idx] = 1;
                        count++;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        
                        if (y > 0) {
                            const aboveIdx = idx - width;
                            if (!visited[aboveIdx] && colorMatch(aboveIdx)) {
                                if (!spanAbove) { stack.push(aboveIdx); spanAbove = true; }
                            } else { spanAbove = false; }
                        }
                        if (y < height - 1) {
                            const belowIdx = idx + width;
                            if (!visited[belowIdx] && colorMatch(belowIdx)) {
                                if (!spanBelow) { stack.push(belowIdx); spanBelow = true; }
                            } else { spanBelow = false; }
                        }
                        x++; idx++;
                    }
                }
                
                // Too small a region â€” no gradient
                if (count < 50) return null;
                
                const regionW = maxX - minX;
                const regionH = maxY - minY;
                if (regionW < 4 && regionH < 4) return null;
                
                // Sample colors along multiple axes through the region center
                const cx = Math.floor((minX + maxX) / 2);
                const cy = Math.floor((minY + maxY) / 2);
                
                // Helper: sample average color at a point (3x3 area)
                const sampleColor = (sx, sy) => {
                    let rr = 0, gg = 0, bb = 0, n = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const xx = sx + dx, yy = sy + dy;
                            if (xx < 0 || xx >= width || yy < 0 || yy >= height) continue;
                            const idx = yy * width + xx;
                            if (!visited[idx]) continue;
                            const pos = idx * 4;
                            if (data[pos + 3] < 30) continue;
                            rr += data[pos]; gg += data[pos + 1]; bb += data[pos + 2]; n++;
                        }
                    }
                    if (n === 0) return null;
                    return { r: Math.round(rr / n), g: Math.round(gg / n), b: Math.round(bb / n) };
                };
                
                // Sample along an axis: returns { variance, startColor, endColor, x0, y0, x1, y1 }
                const sampleAxis = (x0, y0, x1, y1) => {
                    const steps = 10;
                    const colors = [];
                    let firstColor = null, lastColor = null;
                    let firstX = x0, firstY = y0, lastX = x1, lastY = y1;
                    
                    for (let s = 0; s <= steps; s++) {
                        const t = s / steps;
                        const sx = Math.floor(x0 + (x1 - x0) * t);
                        const sy = Math.floor(y0 + (y1 - y0) * t);
                        const c = sampleColor(sx, sy);
                        if (c) {
                            colors.push(c);
                            if (!firstColor) { firstColor = c; firstX = sx; firstY = sy; }
                            lastColor = c; lastX = sx; lastY = sy;
                        }
                    }
                    
                    if (colors.length < 3 || !firstColor || !lastColor) {
                        return { variance: 0, startColor: null, endColor: null };
                    }
                    
                    // Calculate color variance along the axis
                    const avgR = colors.reduce((s, c) => s + c.r, 0) / colors.length;
                    const avgG = colors.reduce((s, c) => s + c.g, 0) / colors.length;
                    const avgB = colors.reduce((s, c) => s + c.b, 0) / colors.length;
                    const variance = colors.reduce((s, c) => {
                        return s + (c.r - avgR) ** 2 + (c.g - avgG) ** 2 + (c.b - avgB) ** 2;
                    }, 0) / colors.length;
                    
                    return {
                        variance,
                        startColor: firstColor,
                        endColor: lastColor,
                        x0: firstX, y0: firstY,
                        x1: lastX, y1: lastY,
                    };
                };
                
                // Test multiple axes through the region
                const pad = 3; // Slight inset so we sample inside region edges
                const axes = [
                    // Horizontal
                    sampleAxis(minX + pad, cy, maxX - pad, cy),
                    // Vertical
                    sampleAxis(cx, minY + pad, cx, maxY - pad),
                    // Diagonal TL â†’ BR
                    sampleAxis(minX + pad, minY + pad, maxX - pad, maxY - pad),
                    // Diagonal TR â†’ BL
                    sampleAxis(maxX - pad, minY + pad, minX + pad, maxY - pad),
                ];
                
                // Also check for radial: center vs edges
                const centerColor = sampleColor(cx, cy);
                let radialVariance = 0;
                let edgeColors = [];
                if (centerColor) {
                    const edgePoints = [
                        sampleColor(minX + pad, cy),
                        sampleColor(maxX - pad, cy),
                        sampleColor(cx, minY + pad),
                        sampleColor(cx, maxY - pad),
                    ].filter(Boolean);
                    
                    if (edgePoints.length >= 2) {
                        // Check if edges are similar to each other but different from center
                        const edgeAvgR = edgePoints.reduce((s, c) => s + c.r, 0) / edgePoints.length;
                        const edgeAvgG = edgePoints.reduce((s, c) => s + c.g, 0) / edgePoints.length;
                        const edgeAvgB = edgePoints.reduce((s, c) => s + c.b, 0) / edgePoints.length;
                        
                        const centerEdgeDiff = Math.sqrt(
                            (centerColor.r - edgeAvgR) ** 2 +
                            (centerColor.g - edgeAvgG) ** 2 +
                            (centerColor.b - edgeAvgB) ** 2
                        );
                        
                        // Edge consistency: low variance among edges = likely radial
                        const edgeVariance = edgePoints.reduce((s, c) => {
                            return s + (c.r - edgeAvgR) ** 2 + (c.g - edgeAvgG) ** 2 + (c.b - edgeAvgB) ** 2;
                        }, 0) / edgePoints.length;
                        
                        if (edgeVariance < 400 && centerEdgeDiff > 25) {
                            radialVariance = centerEdgeDiff * centerEdgeDiff;
                            edgeColors = edgePoints;
                        }
                    }
                }
                
                // Find axis with highest variance
                let bestAxis = axes[0];
                for (const ax of axes) {
                    if (ax.variance > bestAxis.variance) bestAxis = ax;
                }
                
                // Minimum variance threshold to consider it a gradient
                const minVariance = 150;
                
                // Check radial vs linear
                if (radialVariance > bestAxis.variance && radialVariance > minVariance && centerColor) {
                    // Radial gradient detected
                    const edgeAvg = {
                        r: Math.round(edgeColors.reduce((s, c) => s + c.r, 0) / edgeColors.length),
                        g: Math.round(edgeColors.reduce((s, c) => s + c.g, 0) / edgeColors.length),
                        b: Math.round(edgeColors.reduce((s, c) => s + c.b, 0) / edgeColors.length),
                    };
                    const radius = Math.max(regionW, regionH) / 2;
                    const cA = '#' + [centerColor.r, centerColor.g, centerColor.b].map(v => v.toString(16).padStart(2, '0')).join('');
                    const cB = '#' + [edgeAvg.r, edgeAvg.g, edgeAvg.b].map(v => v.toString(16).padStart(2, '0')).join('');
                    
                    return {
                        type: 'radial',
                        colorA: cA,
                        colorB: cB,
                        x0: cx, y0: cy,
                        x1: cx + radius, y1: cy,
                    };
                }
                
                if (bestAxis.variance > minVariance && bestAxis.startColor && bestAxis.endColor) {
                    // Linear gradient detected
                    const sc = bestAxis.startColor;
                    const ec = bestAxis.endColor;
                    const cA = '#' + [sc.r, sc.g, sc.b].map(v => v.toString(16).padStart(2, '0')).join('');
                    const cB = '#' + [ec.r, ec.g, ec.b].map(v => v.toString(16).padStart(2, '0')).join('');
                    
                    return {
                        type: 'linear',
                        colorA: cA,
                        colorB: cB,
                        x0: bestAxis.x0, y0: bestAxis.y0,
                        x1: bestAxis.x1, y1: bestAxis.y1,
                    };
                }
                
                return null; // No gradient detected
            }
            
            // Flood Fill (Paint Bucket) Algorithm
            floodFill(startX, startY) {
                // Flush any pending async saveState from a previous brush stroke
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    // Push the pre-captured snapshot if available, otherwise take a new one
                    if (this._pendingSnapshot) {
                        this._pushUndo(this._pendingSnapshot);
                        this._pendingSnapshot = null;
                    } else {
                        this.saveState();
                    }
                }
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const width = frame.width;
                const height = frame.height;
                
                const imageData = frameCtx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;
                
                const startPos = (startY * width + startX) * 4;
                const targetR = data[startPos];
                const targetG = data[startPos + 1];
                const targetB = data[startPos + 2];
                const targetA = data[startPos + 3];
                
                const fillColor = this.hexToRgb(this.color);
                
                if (targetR === fillColor.r && targetG === fillColor.g && 
                    targetB === fillColor.b && targetA === 255) {
                    return;
                }
                
                this.saveState();
                
                const tolerance = 50;
                
                // === PASS 1: Scanline flood fill â†’ build region mask ===
                const visited = new Uint8Array(width * height);
                
                const colorMatch = (idx) => {
                    const pos = idx * 4;
                    const a = data[pos + 3];
                    if (a < 30) return true;
                    return Math.abs(data[pos] - targetR) <= tolerance &&
                           Math.abs(data[pos + 1] - targetG) <= tolerance &&
                           Math.abs(data[pos + 2] - targetB) <= tolerance &&
                           Math.abs(a - targetA) <= tolerance;
                };
                
                const stack = [startX + startY * width];
                let filledCount = 0;
                
                while (stack.length > 0) {
                    let idx = stack.pop();
                    let x = idx % width;
                    const y = (idx - x) / width;
                    
                    while (x > 0 && !visited[idx - 1] && colorMatch(idx - 1)) { x--; idx--; }
                    
                    let spanAbove = false, spanBelow = false;
                    
                    while (x < width && !visited[idx] && colorMatch(idx)) {
                        visited[idx] = 1;
                        filledCount++;
                        
                        if (y > 0) {
                            const aboveIdx = idx - width;
                            if (!visited[aboveIdx] && colorMatch(aboveIdx)) {
                                if (!spanAbove) { stack.push(aboveIdx); spanAbove = true; }
                            } else { spanAbove = false; }
                        }
                        if (y < height - 1) {
                            const belowIdx = idx + width;
                            if (!visited[belowIdx] && colorMatch(belowIdx)) {
                                if (!spanBelow) { stack.push(belowIdx); spanBelow = true; }
                            } else { spanBelow = false; }
                        }
                        x++; idx++;
                    }
                }
                
                if (filledCount === 0) return;
                
                // === PASS 2: Expand fill mask by 3px for fill-under-linework bleed ===
                const expanded = new Uint8Array(visited);
                for (let pass = 0; pass < 3; pass++) {
                    const src = new Uint8Array(expanded);
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            if (src[idx]) continue;
                            if ((x > 0 && src[idx - 1]) ||
                                (x < width - 1 && src[idx + 1]) ||
                                (y > 0 && src[idx - width]) ||
                                (y < height - 1 && src[idx + width])) {
                                expanded[idx] = 1;
                            }
                        }
                    }
                }
                
                // === PASS 3a: Strip old fill color from the region ===
                // For re-fill support: pixels matching the target (previous fill) get
                // their alpha zeroed so the new fill shows through them.
                // Linework of ANY color is preserved because it won't match the target.
                for (let i = 0; i < width * height; i++) {
                    if (!expanded[i]) continue;
                    const pos = i * 4;
                    const a = data[pos + 3];
                    if (a === 0) continue;
                    
                    // Distance from target â€” includes alpha so transparent-target
                    // doesn't accidentally match opaque content
                    const diff = Math.max(
                        Math.abs(data[pos] - targetR),
                        Math.abs(data[pos + 1] - targetG),
                        Math.abs(data[pos + 2] - targetB),
                        Math.abs(a - targetA)
                    );
                    
                    if (diff <= tolerance) {
                        // Matches old fill â†’ make transparent for new fill
                        data[pos + 3] = 0;
                    } else if (diff < tolerance * 2) {
                        // Transition zone â†’ smooth fade
                        const t = (diff - tolerance) / tolerance;
                        data[pos + 3] = Math.round(a * t);
                    }
                }
                
                // === PASS 3b: Paint fill behind remaining content ===
                // Uses canvas compositing so the browser handles AA blending natively.
                // Fill layer goes down first, then the stripped original on top.
                const fillLayer = document.createElement('canvas');
                fillLayer.width = width;
                fillLayer.height = height;
                const fillLayerCtx = fillLayer.getContext('2d');
                const fillImgData = fillLayerCtx.createImageData(width, height);
                const fd = fillImgData.data;
                
                for (let i = 0; i < width * height; i++) {
                    if (expanded[i]) {
                        const pos = i * 4;
                        fd[pos]     = fillColor.r;
                        fd[pos + 1] = fillColor.g;
                        fd[pos + 2] = fillColor.b;
                        fd[pos + 3] = 255;
                    }
                }
                fillLayerCtx.putImageData(fillImgData, 0, 0);
                
                // Put the stripped original into a temp canvas
                const strippedCanvas = document.createElement('canvas');
                strippedCanvas.width = width;
                strippedCanvas.height = height;
                const strippedCtx = strippedCanvas.getContext('2d');
                strippedCtx.putImageData(imageData, 0, 0);
                
                // Composite: fill on bottom, stripped original on top
                frameCtx.clearRect(0, 0, width, height);
                frameCtx.drawImage(fillLayer, 0, 0);
                frameCtx.drawImage(strippedCanvas, 0, 0);
                
                this._dirtyThumb(frame);
                this._invalidateCompositeCache();
                this.render();
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 0, g: 0, b: 0};
            }
            
            play(modeOverride) {
                if (this.isPlaying) return;
                
                // Fully dismiss any active free transform / selection
                if (this.selection) {
                    this.applySelection();
                    this.selection = null;
                    this.transformHandles = [];
                    this.selectionUndoStack = [];
                    this.selectionRedoStack = [];
                }
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                this.hideTransformHandles();
                this.isTransforming = false;
                this.isRotating = false;
                this.activeHandle = null;
                // Switch to lasso
                const transformTools = ['transform', 'scale', 'rotate', 'skew', 'distort'];
                if (transformTools.includes(this.tool)) {
                    this.selectTool('lasso');
                }
                
                if (this.frameSelectMode) this.exitFrameSelectMode();
                else this.selectedFrames.clear();
                
                // Save viewport and pasteboard state, reset to camera view for playback
                this._savedViewport = {
                    x: this.viewportX, y: this.viewportY,
                    pasteboard: this.pasteboardVisible,
                    scrollLeft: this.canvasContainer.scrollLeft,
                    scrollTop: this.canvasContainer.scrollTop
                };
                if (this.pasteboardVisible) {
                    // Temporarily disable pasteboard for clean playback
                    this.pasteboardVisible = false;
                    this.canvas.width = this.projectWidth;
                    this.canvas.height = this.projectHeight;
                    this.selectionCanvas.width = this.projectWidth;
                    this.selectionCanvas.height = this.projectHeight;
                    this.onionCanvas.width = this.projectWidth;
                    this.onionCanvas.height = this.projectHeight;
                    this.gridCanvas.width = this.projectWidth;
                    this.gridCanvas.height = this.projectHeight;
                    this.zoomLevel = null;
                    this.applyZoom();
                    // Reset viewport to camera origin (pasteboard offset was for editing)
                    this.viewportX = 0;
                    this.viewportY = 0;
                    // Center scroll for clean playback view
                    this.canvasContainer.scrollLeft = 0;
                    this.canvasContainer.scrollTop = 0;
                }
                // When pasteboard is not active, keep current viewport â€” it IS the camera view
                
                this.isPlaying = true;
                
                // Clear any gradient edit state
                this._gradientEdit = null;
                this._gradientDrag = null;
                this._gradientMaskCache = null;
                
                // Hide onion canvas during playback (not needed, saves compositing)
                this.onionCanvas.style.display = 'none';
                
                const mode = modeOverride || this.playbackMode;
                this._activePlayMode = mode;
                
                const layer = this.getCurrentLayer();
                const layerOffset = layer.startFrame || 0;
                let frameIndex, maxFrames;
                
                if (mode === 'timeline') {
                    // Full timeline: iterate over drawing layer positions only
                    maxFrames = this.getDrawingTimelineLength();
                    frameIndex = 0;
                    this._playbackTimelinePos = 0;
                    const localIdx = 0 - layerOffset;
                    this.currentFrameIndex = Math.max(0, Math.min(layer.frames.length - 1, localIdx >= 0 ? localIdx : 0));
                    // Audio window: timeline position 0 to maxFrames
                    this._playbackStartPos = 0;
                    this._playbackEndPos = maxFrames;
                } else {
                    // Active layer only
                    maxFrames = layer.frames.length;
                    frameIndex = 0;
                    this.currentFrameIndex = 0;
                    // Audio window: layer's timeline span
                    this._playbackStartPos = layerOffset;
                    this._playbackEndPos = layerOffset + maxFrames;
                }
                
                // Store playback duration so audio knows when to stop
                this._playbackMaxFrames = maxFrames;
                this._playbackDuration = maxFrames / this.fps;
                
                let lastFrameTime = performance.now(); // legacy â€” kept for compatibility
                const frameDelay = 1000 / this.fps;
                this._playStartTime = performance.now();
                
                // Start audio playback (must be after currentFrameIndex is set to start position)
                
                // Start audio playback
                this.startAudioPlayback();
                
                // Track the last rendered frame to avoid redundant draws
                let lastRenderedFrame = -1;
                
                const playbackLoop = (currentTime) => {
                    if (!this.isPlaying) return;
                    
                    // Derive frame index from elapsed time â€” stays synced with audio
                    const elapsed = currentTime - this._playStartTime;
                    const totalElapsedFrames = Math.floor(elapsed / frameDelay);
                    frameIndex = totalElapsedFrames % maxFrames;
                    
                    // Only render if frame actually changed
                    if (frameIndex !== lastRenderedFrame) {
                        lastRenderedFrame = frameIndex;
                        
                        if (mode === 'timeline') {
                            this._playbackTimelinePos = frameIndex;
                            const localIdx = frameIndex - layerOffset;
                            if (localIdx >= 0 && localIdx < layer.frames.length) {
                                this.currentFrameIndex = localIdx;
                            }
                            this.currentFrameIndex = Math.max(0, Math.min(layer.frames.length - 1, this.currentFrameIndex));
                        } else {
                            this.currentFrameIndex = frameIndex;
                        }
                        
                        // Detect loop â€” restart audio aligned to loop boundary
                        const currentLoop = Math.floor(totalElapsedFrames / maxFrames);
                        if (currentLoop > this._lastPlayLoop && this.audioTracks.length > 0) {
                            this.stopAudioPlayback();
                            // Reset timing so elapsed counts from this loop's start
                            this._playStartTime = currentTime - (elapsed % (maxFrames * frameDelay));
                            this._lastPlayLoop = 0; // reset so next loop is detected from new start time
                            this.startAudioPlayback();
                        }
                        
                        this.renderCanvasOnly();
                        this.updatePlayheadPosition();
                        this.updateAudioPlayhead(this.getPlayheadPosition(), maxFrames);
                    }
                    
                    this.playbackAnimationFrame = requestAnimationFrame(playbackLoop);
                };
                
                this._lastPlayLoop = 0;
                this.playbackAnimationFrame = requestAnimationFrame(playbackLoop);
            }
            
            stop() {
                this.isPlaying = false;
                this._activePlayMode = null;
                this._playbackTimelinePos = undefined;
                this._lastPlayLoop = undefined;
                this._playbackStartPos = undefined;
                this._playbackEndPos = undefined;
                this._playbackDuration = undefined;
                this._playbackMaxFrames = undefined;
                if (this.playbackInterval) {
                    clearInterval(this.playbackInterval);
                    this.playbackInterval = null;
                }
                if (this.playbackAnimationFrame) {
                    cancelAnimationFrame(this.playbackAnimationFrame);
                    this.playbackAnimationFrame = null;
                }
                this.stopAudioPlayback();
                this.hideAudioPlayhead();
                
                // Restore onion canvas visibility
                this.onionCanvas.style.display = '';
                
                // Restore viewport and pasteboard from before playback
                if (this._savedViewport) {
                    if (this._savedViewport.pasteboard && !this.pasteboardVisible) {
                        this.pasteboardVisible = true;
                        this.updatePasteboard(); // This sets viewport too
                        // Override viewport to saved pan position
                        this.viewportX = this._savedViewport.x;
                        this.viewportY = this._savedViewport.y;
                    } else {
                        this.viewportX = this._savedViewport.x;
                        this.viewportY = this._savedViewport.y;
                    }
                    // Restore scroll position
                    this.canvasContainer.scrollLeft = this._savedViewport.scrollLeft || 0;
                    this.canvasContainer.scrollTop = this._savedViewport.scrollTop || 0;
                    this._savedViewport = null;
                }
                
                this.render(); // Full render to restore timeline + onion skin
            }
            
            // === Audio System ===
            
            getAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Resume if suspended (iOS requires user gesture)
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                return this.audioContext;
            }
            
            async importAudio(file) {
                try {
                    const ctx = this.getAudioContext();
                    const arrayBuffer = await file.arrayBuffer();
                    const base64 = await this._arrayBufferToBase64(arrayBuffer);
                    const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
                    const waveformPeaks = this._generateWaveformPeaks(audioBuffer, 2000);
                    
                    const track = {
                        id: ++this._audioTrackIdCounter,
                        name: file.name,
                        audioBuffer: audioBuffer,
                        base64: base64,
                        mimeType: file.type || 'audio/mpeg',
                        volume: 1.0,
                        muted: false,
                        startFrame: 0,
                        waveformPeaks: waveformPeaks
                    };
                    
                    this.audioTracks.push(track);
                    this.renderAudioTracks();
                    this.renderLayers();
                } catch (err) {
                    console.error('Audio import failed:', err);
                    alert('Could not import audio: ' + err.message);
                }
            }
            
            _arrayBufferToBase64(buffer) {
                return new Promise((resolve) => {
                    const blob = new Blob([buffer]);
                    const reader = new FileReader();
                    reader.onload = () => {
                        resolve(reader.result.split(',')[1]);
                    };
                    reader.readAsDataURL(blob);
                });
            }
            
            _base64ToArrayBuffer(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes.buffer;
            }
            
            _generateWaveformPeaks(audioBuffer, numPeaks) {
                const channel = audioBuffer.getChannelData(0);
                const samplesPerPeak = Math.floor(channel.length / numPeaks);
                const peaks = [];
                for (let i = 0; i < numPeaks; i++) {
                    let max = 0;
                    const start = i * samplesPerPeak;
                    const end = Math.min(start + samplesPerPeak, channel.length);
                    for (let j = start; j < end; j++) {
                        const abs = Math.abs(channel[j]);
                        if (abs > max) max = abs;
                    }
                    peaks.push(max);
                }
                return peaks;
            }
            
            removeAudioTrack(trackId) {
                this.stopAudioPlayback();
                this.audioTracks = this.audioTracks.filter(t => t.id !== trackId);
                this.renderAudioTracks();
            }
            
            removeAudio() {
                // Legacy compat: remove all tracks
                this.stopAudioPlayback();
                this.audioTracks = [];
                this.renderAudioTracks();
            }
            
            // Build the entire audio tracks UI
            renderAudioTracks() {
                const container = document.getElementById('audioTracksContainer');
                container.innerHTML = '';
                
                if (this.audioTracks.length === 0) return;
                
                const layersSection = document.getElementById('layersSection');
                const labelWidth = layersSection ? layersSection.offsetWidth : 180;
                
                const audioIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="12" height="12" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 4v6M5 2.5v9M7 4.5v5M9 3v8M11 5v4"/></svg>';
                const speakerIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="10" height="10" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M2 5h2l3-3v10L4 9H2a1 1 0 01-1-1V6a1 1 0 011-1z"/><path d="M10 4.5c.7.7 1 1.6 1 2.5s-.3 1.8-1 2.5"/></svg>';
                const mutedIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="10" height="10" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M2 5h2l3-3v10L4 9H2a1 1 0 01-1-1V6a1 1 0 011-1z"/><line x1="10" y1="4" x2="14" y2="10"/><line x1="14" y1="4" x2="10" y2="10"/></svg>';
                
                const colors = [
                    { bg: '#1a1a2e', accent: 'rgba(100, 120, 220, 0.6)', headerColor: '#8888cc' },
                    { bg: '#1a2e1a', accent: 'rgba(100, 220, 120, 0.6)', headerColor: '#88cc88' },
                    { bg: '#2e1a1a', accent: 'rgba(220, 100, 120, 0.6)', headerColor: '#cc8888' },
                    { bg: '#2e2e1a', accent: 'rgba(220, 200, 100, 0.6)', headerColor: '#cccc88' },
                ];
                
                this.audioTracks.forEach((track, idx) => {
                    const c = colors[idx % colors.length];
                    
                    const row = document.createElement('div');
                    row.className = 'audio-timeline';
                    
                    // Label side
                    const label = document.createElement('div');
                    label.className = 'audio-timeline-label';
                    label.style.width = labelWidth + 'px';
                    label.style.background = c.bg;
                    
                    const header = document.createElement('div');
                    header.className = 'audio-track-header';
                    header.style.color = c.headerColor;
                    let name = track.name;
                    if (name.length > 18) name = name.substring(0, 15) + 'â€¦';
                    header.innerHTML = audioIcon + `<span class="audio-track-name">${name}</span>`;
                    label.appendChild(header);
                    
                    const controls = document.createElement('div');
                    controls.className = 'audio-controls';
                    
                    // Volume down
                    const volDown = document.createElement('button');
                    volDown.textContent = 'âˆ’';
                    volDown.title = 'Decrease volume';
                    volDown.addEventListener('click', () => {
                        track.volume = Math.max(0, track.volume - 0.1);
                        volDisplay.textContent = Math.round(track.volume * 100) + '%';
                    });
                    controls.appendChild(volDown);
                    
                    const volDisplay = document.createElement('span');
                    volDisplay.className = 'audio-vol-display';
                    volDisplay.textContent = Math.round(track.volume * 100) + '%';
                    controls.appendChild(volDisplay);
                    
                    // Volume up
                    const volUp = document.createElement('button');
                    volUp.textContent = '+';
                    volUp.title = 'Increase volume';
                    volUp.addEventListener('click', () => {
                        track.volume = Math.min(1.5, track.volume + 0.1);
                        volDisplay.textContent = Math.round(track.volume * 100) + '%';
                    });
                    controls.appendChild(volUp);
                    
                    // Mute
                    const muteBtn = document.createElement('button');
                    muteBtn.className = 'audio-mute-btn' + (track.muted ? ' muted' : '');
                    muteBtn.title = 'Mute/Unmute';
                    muteBtn.innerHTML = track.muted ? mutedIcon : speakerIcon;
                    muteBtn.addEventListener('click', () => {
                        track.muted = !track.muted;
                        muteBtn.classList.toggle('muted', track.muted);
                        muteBtn.innerHTML = track.muted ? mutedIcon : speakerIcon;
                        waveCanvas.style.opacity = track.muted ? '0.3' : '1';
                    });
                    controls.appendChild(muteBtn);
                    
                    // Remove
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'audio-remove-btn';
                    removeBtn.title = 'Remove track';
                    removeBtn.innerHTML = 'âœ•';
                    removeBtn.addEventListener('click', () => {
                        this.removeAudioTrack(track.id);
                    });
                    controls.appendChild(removeBtn);
                    
                    label.appendChild(controls);
                    row.appendChild(label);
                    
                    // Waveform side
                    const waveWrap = document.createElement('div');
                    waveWrap.className = 'audio-timeline-waveform';
                    waveWrap.style.background = c.bg;
                    
                    const waveCanvas = document.createElement('canvas');
                    waveCanvas.className = 'audio-waveform-canvas';
                    waveCanvas.dataset.trackId = track.id;
                    if (track.muted) waveCanvas.style.opacity = '0.3';
                    waveWrap.appendChild(waveCanvas);
                    
                    const playhead = document.createElement('div');
                    playhead.className = 'audio-playhead';
                    playhead.dataset.trackId = track.id;
                    waveWrap.appendChild(playhead);
                    
                    row.appendChild(waveWrap);
                    container.appendChild(row);
                    
                    // Render waveform for this track
                    this._renderTrackWaveform(track, waveCanvas, waveWrap, c.accent);
                    
                    // Drag-to-slide audio track on timeline
                    const trackForDrag = track;
                    const waveWrapRef = waveWrap;
                    const colorRef = c.accent;
                    waveCanvas.style.cursor = 'grab';
                    waveCanvas.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        waveCanvas.style.cursor = 'grabbing';
                        const startX = e.clientX;
                        const startOffset = trackForDrag.startFrame || 0;
                        const { cellW } = this.getTimelineMetrics();
                        
                        const onMove = (ev) => {
                            const dx = ev.clientX - startX;
                            const frameDelta = Math.round(dx / cellW);
                            trackForDrag.startFrame = Math.max(0, startOffset + frameDelta);
                            this._renderTrackWaveform(trackForDrag, waveCanvas, waveWrapRef, colorRef);
                        };
                        const onUp = () => {
                            waveCanvas.style.cursor = 'grab';
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.removeEventListener('pointercancel', onUp);
                        };
                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        document.addEventListener('pointercancel', onUp);
                    });
                });
            }
            
            _renderTrackWaveform(track, canvas, container, color) {
                const peaks = track.waveformPeaks;
                
                const numFrames = this._maxFrameCount || this.getTimelineLength();
                const { cellW: frameCellWidth, padding } = this.getTimelineMetrics();
                const framesWidth = padding + numFrames * frameCellWidth + 40;
                
                const animDuration = numFrames / this.fps;
                const audioDuration = track.audioBuffer.duration;
                const totalWidth = Math.max(framesWidth, (framesWidth / animDuration) * ((track.startFrame || 0) / this.fps + audioDuration));
                
                const height = container.clientHeight || 52;
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = totalWidth * dpr;
                canvas.height = height * dpr;
                canvas.style.width = totalWidth + 'px';
                canvas.style.height = height + 'px';
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, totalWidth, height);
                
                // Grid lines
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= numFrames; i++) {
                    const x = padding + i * frameCellWidth;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
                }
                
                // Waveform â€” offset by startFrame
                const trackOffsetPx = (track.startFrame || 0) * frameCellWidth;
                const wavePixelsPerSec = framesWidth / animDuration;
                const waveWidth = audioDuration * wavePixelsPerSec;
                const mid = height / 2;
                const amp = (height / 2) - 4;
                
                ctx.fillStyle = color;
                ctx.beginPath();
                const peaksPerPixel = peaks.length / waveWidth;
                for (let x = 0; x < waveWidth; x++) {
                    const peakIdx = Math.floor(x * peaksPerPixel);
                    const peak = peaks[Math.min(peakIdx, peaks.length - 1)];
                    const barH = peak * amp;
                    ctx.rect(padding + trackOffsetPx + x, mid - barH, 1, barH * 2);
                }
                ctx.fill();
                
                // Centerline
                ctx.strokeStyle = color.replace('0.6', '0.3');
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding + trackOffsetPx, mid);
                ctx.lineTo(padding + trackOffsetPx + waveWidth, mid);
                ctx.stroke();
            }
            
            syncAudioLabelWidth() {
                const layersSection = document.getElementById('layersSection');
                if (!layersSection) return;
                const w = layersSection.offsetWidth + 'px';
                document.querySelectorAll('.audio-timeline-label').forEach(el => {
                    el.style.width = w;
                });
            }
            
            renderAudioWaveform() {
                // Re-render all track waveforms
                if (this.audioTracks.length === 0) return;
                this.renderAudioTracks();
            }
            
            showAudioTimeline() {
                // No-op: tracks are shown by renderAudioTracks
            }
            
            hideAudioTimeline() {
                document.getElementById('audioTracksContainer').innerHTML = '';
            }
            
            updateAudioUI() {
                // Per-track volume is handled inline; nothing global needed
            }
            
            startAudioPlayback() {
                if (this.audioTracks.length === 0) return;
                const ctx = this.getAudioContext();
                
                this._audioSourceNodes = [];
                
                // The animation plays between these timeline positions
                const animStart = this._playbackStartPos || 0;
                const animEnd = this._playbackEndPos || Infinity;
                const animStartTime = animStart / this.fps;
                const animEndTime = animEnd / this.fps;
                const animDuration = animEndTime - animStartTime;
                
                // Current playhead in timeline frames
                const playheadPos = this.getPlayheadPosition();
                // How far into the animation we are (in seconds)
                const animElapsed = (playheadPos - animStart) / this.fps;
                const animRemaining = animDuration - animElapsed;
                
                if (animRemaining <= 0) return;
                
                for (const track of this.audioTracks) {
                    if (track.muted) continue;
                    
                    const trackOffset = (track.startFrame || 0);
                    const trackStartTime = trackOffset / this.fps;
                    const trackEndTime = trackStartTime + track.audioBuffer.duration;
                    
                    // Current playhead time in absolute timeline seconds
                    const nowTime = playheadPos / this.fps;
                    
                    // Where in the audio buffer should we start?
                    const audioOffset = Math.max(0, nowTime - trackStartTime);
                    
                    // Is the track's audio relevant at all within the remaining animation?
                    if (audioOffset >= track.audioBuffer.duration) continue;
                    if (trackStartTime >= animEndTime) continue;
                    
                    const source = ctx.createBufferSource();
                    source.buffer = track.audioBuffer;
                    const gain = ctx.createGain();
                    gain.gain.value = track.volume;
                    source.connect(gain);
                    gain.connect(ctx.destination);
                    
                    if (nowTime >= trackStartTime) {
                        // Playhead is within or past track start â€” play immediately from offset
                        const audioRemaining = track.audioBuffer.duration - audioOffset;
                        const playDuration = Math.min(audioRemaining, animRemaining);
                        source.start(0, audioOffset, playDuration);
                    } else {
                        // Track starts later â€” schedule delayed start
                        const delay = trackStartTime - nowTime;
                        if (delay >= animRemaining) continue; // starts after animation ends
                        const playDuration = Math.min(track.audioBuffer.duration, animRemaining - delay);
                        source.start(ctx.currentTime + delay, 0, playDuration);
                    }
                    
                    this._audioSourceNodes.push({ trackId: track.id, source, gain });
                }
            }
            
            stopAudioPlayback() {
                for (const node of this._audioSourceNodes) {
                    try { node.source.stop(); } catch (e) {}
                    node.source.disconnect();
                    node.gain.disconnect();
                }
                this._audioSourceNodes = [];
            }
            
            updateAudioPlayhead(frameIndex, totalFrames) {
                if (this.audioTracks.length === 0) return;
                const { cellW: frameCellWidth, padding } = this.getTimelineMetrics();
                const x = padding + frameIndex * frameCellWidth + frameCellWidth / 2;
                
                document.querySelectorAll('.audio-playhead').forEach(ph => {
                    const container = ph.parentElement;
                    ph.style.display = 'block';
                    ph.style.left = (x - container.scrollLeft) + 'px';
                });
            }
            
            hideAudioPlayhead() {
                document.querySelectorAll('.audio-playhead').forEach(ph => {
                    ph.style.display = 'none';
                });
            }
            
            scrubAudio(timelinePos) {
                this.stopScrubAudio();
                
                if (this.audioTracks.length === 0) return;
                const ctx = this.getAudioContext();
                const snippetDuration = 0.08;
                
                this._scrubNodes = [];
                
                for (const track of this.audioTracks) {
                    if (track.muted) continue;
                    const trackOffset = (track.startFrame || 0);
                    const timeOffset = (timelinePos - trackOffset) / this.fps;
                    if (timeOffset < 0 || timeOffset >= track.audioBuffer.duration) continue;
                    
                    const source = ctx.createBufferSource();
                    source.buffer = track.audioBuffer;
                    
                    const gain = ctx.createGain();
                    gain.gain.value = track.volume;
                    gain.gain.setValueAtTime(track.volume, ctx.currentTime + snippetDuration * 0.7);
                    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + snippetDuration);
                    
                    source.connect(gain);
                    gain.connect(ctx.destination);
                    source.start(0, timeOffset, snippetDuration);
                    
                    this._scrubNodes.push({ source, gain });
                }
            }
            
            stopScrubAudio() {
                if (this._scrubSource) {
                    try { this._scrubSource.stop(); } catch (e) {}
                    this._scrubSource.disconnect();
                    this._scrubSource = null;
                }
                if (this._scrubGain) {
                    this._scrubGain.disconnect();
                    this._scrubGain = null;
                }
                if (this._scrubNodes) {
                    for (const n of this._scrubNodes) {
                        try { n.source.stop(); } catch (e) {}
                        n.source.disconnect();
                        n.gain.disconnect();
                    }
                    this._scrubNodes = [];
                }
            }
            
            _invalidateCompositeCache() {
                this._compositeCacheDirty = true;
                this._compositeCacheVer++;
            }
            
            _getCompositeCacheKey() {
                // Build a lightweight key from all state that affects non-active layer compositing
                const layerSigs = this.layers.map(l => 
                    `${l.id}:${l.visible}:${l.opacity}:${l.startFrame || 0}:${l.frames.length}`
                ).join('|');
                return `${this._compositeCacheVer},${this.currentLayerId},${this.currentFrameIndex},${this.getPlayheadPosition()},${this.canvas.width},${this.canvas.height},${this.viewportX},${this.viewportY},${layerSigs}`;
            }
            
            _rebuildCompositeCache(playheadPos) {
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Resize cache canvases if needed
                if (this._belowCache.width !== w || this._belowCache.height !== h) {
                    this._belowCache.width = w;
                    this._belowCache.height = h;
                    this._aboveCache.width = w;
                    this._aboveCache.height = h;
                }
                
                this._belowCtx.clearRect(0, 0, w, h);
                this._aboveCtx.clearRect(0, 0, w, h);
                
                const activeIdx = this.layers.findIndex(l => l.id === this.currentLayerId);
                
                // Composite layers below active
                for (let i = 0; i < activeIdx; i++) {
                    this.drawLayerWithTransform(this._belowCtx, this.layers[i], playheadPos);
                }
                
                // Composite layers above active
                for (let i = activeIdx + 1; i < this.layers.length; i++) {
                    this.drawLayerWithTransform(this._aboveCtx, this.layers[i], playheadPos);
                }
                
                this._compositeCacheDirty = false;
                this._compositeCacheKey = this._getCompositeCacheKey();
            }
            
            _drawWithCompositeCache(ctx, playheadPos) {
                // Check if cache is still valid
                const currentKey = this._getCompositeCacheKey();
                if (this._compositeCacheDirty || this._compositeCacheKey !== currentKey) {
                    this._rebuildCompositeCache(playheadPos);
                }
                
                // Draw: below layers (cached) â†’ active layer (live) â†’ above layers (cached)
                ctx.drawImage(this._belowCache, 0, 0);
                
                const activeLayer = this.getCurrentLayer();
                this.drawLayerWithTransform(ctx, activeLayer, playheadPos);
                
                ctx.drawImage(this._aboveCache, 0, 0);
            }
            
            render() {
                // Cancel gradient edit/drag if we navigated away from its frame
                if (this._gradientEdit && 
                    (this._gradientEdit.frameIndex !== this.currentFrameIndex ||
                     this._gradientEdit.layerId !== this.currentLayerId)) {
                    this._gradientEdit = null;
                    this._gradientMaskCache = null;
                }
                if (this._gradientDrag && !this.isDrawing) {
                    this._gradientDrag = null;
                    this._gradientMaskCache = null;
                }
                
                // Position onion canvas (skip during playback â€” it's hidden)
                if (!this.isPlaying) {
                    this.positionOnionCanvas();
                }
                
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw onion skin â€” skip during playback (canvas is hidden)
                if (this.onionSkinEnabled && !this.isPlaying) {
                    this.onionCtx.clearRect(0, 0, this.onionCanvas.width, this.onionCanvas.height);
                    const layer = this.getCurrentLayer();
                    
                    // Draw previous frames (tinted with prevColor)
                    for (let offset = 1; offset <= this.onionFramesBefore; offset++) {
                        const frameIdx = this.currentFrameIndex - offset;
                        if (frameIdx >= 0) {
                            const prevFrame = layer.frames[frameIdx];
                            if (prevFrame && layer.visible) {
                                // Fade opacity for frames further away
                                const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesBefore, 1));
                                this.drawOnionFrame(prevFrame, this.onionPrevColor, fadeOpacity);
                            }
                        }
                    }
                    
                    // Draw next frames (tinted with nextColor)
                    for (let offset = 1; offset <= this.onionFramesAfter; offset++) {
                        const frameIdx = this.currentFrameIndex + offset;
                        if (frameIdx < layer.frames.length) {
                            const nextFrame = layer.frames[frameIdx];
                            if (nextFrame && layer.visible) {
                                // Fade opacity for frames further away
                                const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesAfter, 1));
                                this.drawOnionFrame(nextFrame, this.onionNextColor, fadeOpacity);
                            }
                        }
                    }
                } else if (!this.isPlaying) {
                    // Onion skin disabled â€” clear stale content
                    this.onionCtx.clearRect(0, 0, this.onionCanvas.width, this.onionCanvas.height);
                }
                
                // Draw all visible layers for current frame ON THE MAIN CANVAS
                const playheadPos = this.getPlayheadPosition();
                if (this.layers.length > 2 && !this.isPlaying) {
                    // Use composite cache â€” only redraws active layer each frame
                    this._drawWithCompositeCache(this.ctx, playheadPos);
                } else {
                    // Few layers or playing back â€” direct compositing is faster
                    for (const layer of this.layers) {
                        this.drawLayerWithTransform(this.ctx, layer, playheadPos);
                    }
                }
                
                // Draw anchor point indicator
                this.drawAnchorIndicator(this.ctx);
                
                // Draw pasteboard overlay (darkens area outside project bounds)
                this.drawPasteboardOverlay(this.ctx);
                
                // Draw viewport boundary guide when panned away from home
                // (skip when pasteboard is visible â€” overlay already shows the boundary)
                if (!this.pasteboardVisible && (this.viewportX !== 0 || this.viewportY !== 0)) {
                    this.ctx.save();
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([6, 4]);
                    this.ctx.strokeRect(-this.viewportX, -this.viewportY, this.projectWidth, this.projectHeight);
                    this.ctx.restore();
                }
                
                // Draw selection if it exists (with rotation, skew, distort)
                if (this.selection) {
                    this._drawSelectionPreview(this.ctx);
                }
                
                // Draw gradient edit overlay if active
                if (this._gradientEdit && !this.isPlaying) {
                    this._drawGradientEditPreview();
                }
                
                // Only rebuild timeline DOM when structure changed; otherwise lightweight update
                // Skip entirely during active drawing â€” canvas is the focus, timeline unchanged
                // Force rebuild if properties panel is open (slider values need updating)
                if (this.isDrawing) {
                    // Defer timeline update until stroke ends
                } else if (this._timelineDirty || (this._openTransformLayers && this._openTransformLayers.size > 0)) {
                    this._scheduleRenderTimeline();
                } else {
                    this._updateTimelineActive();
                }
            }
            
            toggleGrid() {
                this.gridVisible = !this.gridVisible;
                this.gridCanvas.style.display = this.gridVisible ? 'block' : 'none';
                const label = document.getElementById('gridToggleLabel');
                if (label) label.textContent = this.gridVisible ? 'Hide Grid' : 'Show Grid';
                if (this.gridVisible) this.drawGrid();
            }
            
            drawGrid() {
                if (!this.gridVisible) return;
                const gc = this.gridCanvas;
                const ctx = this.gridCtx;
                
                // Grid covers only the project area
                const W = this.projectWidth;
                const H = this.projectHeight;
                // Offset for pasteboard mode
                const ox = this.pasteboardVisible ? -this.viewportX : 0;
                const oy = this.pasteboardVisible ? -this.viewportY : 0;
                
                ctx.clearRect(0, 0, gc.width, gc.height);
                ctx.save();
                ctx.translate(ox, oy);
                // Clip to project bounds
                ctx.beginPath();
                ctx.rect(0, 0, W, H);
                ctx.clip();
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                
                // Offset diamond tessellation: 8 rows, ~5 columns
                const rows = 8;
                const cols = Math.round((W / H) * rows / 1.6) || 5;
                const rowH = H / rows;
                const colW = W / cols;
                
                // Horizontal lines
                for (let r = 0; r <= rows; r++) {
                    ctx.beginPath();
                    ctx.moveTo(0, r * rowH);
                    ctx.lineTo(W, r * rowH);
                    ctx.stroke();
                }
                
                // Vertical lines
                for (let c = 0; c <= cols; c++) {
                    ctx.beginPath();
                    ctx.moveTo(c * colW, 0);
                    ctx.lineTo(c * colW, H);
                    ctx.stroke();
                }
                
                // Offset diagonals â€” alternating even/odd rows
                // Even rows: peaks at vertical intersections (c * colW)
                // Odd rows: peaks at midpoints ((c + 0.5) * colW)
                for (let r = 0; r < rows; r++) {
                    const y0 = r * rowH;
                    const y1 = (r + 1) * rowH;
                    
                    if (r % 2 === 0) {
                        // From vertical intersections down to midpoints
                        for (let c = 0; c <= cols; c++) {
                            const x0 = c * colW;
                            // Down-right
                            const xr = x0 + colW / 2;
                            if (xr <= W + 1) {
                                ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(xr, y1); ctx.stroke();
                            }
                            // Down-left
                            const xl = x0 - colW / 2;
                            if (xl >= -1) {
                                ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(xl, y1); ctx.stroke();
                            }
                        }
                    } else {
                        // From midpoints down to vertical intersections
                        for (let c = -1; c <= cols; c++) {
                            const x0 = c * colW + colW / 2;
                            if (x0 < -colW || x0 > W + colW) continue;
                            // Down-right
                            const xr = x0 + colW / 2;
                            if (xr >= -1 && xr <= W + 1) {
                                ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(xr, y1); ctx.stroke();
                            }
                            // Down-left
                            const xl = x0 - colW / 2;
                            if (xl >= -1 && xl <= W + 1) {
                                ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(xl, y1); ctx.stroke();
                            }
                        }
                    }
                }
                
                ctx.restore();
            }
            
            renderCanvasOnly() {
                // Cancel gradient edit if frame changed
                if (this._gradientEdit && 
                    (this._gradientEdit.frameIndex !== this.currentFrameIndex ||
                     this._gradientEdit.layerId !== this.currentLayerId)) {
                    this._gradientEdit = null;
                    this._gradientMaskCache = null;
                }
                
                // Lightweight: redraws canvas composite without rebuilding timeline DOM
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.onionSkinEnabled && !this.isPlaying) {
                    this.onionCtx.clearRect(0, 0, this.onionCanvas.width, this.onionCanvas.height);
                    this.positionOnionCanvas();
                    const curLayer = this.getCurrentLayer();
                    for (let offset = 1; offset <= this.onionFramesBefore; offset++) {
                        const frameIdx = this.currentFrameIndex - offset;
                        if (frameIdx >= 0 && curLayer.frames[frameIdx] && curLayer.visible) {
                            const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesBefore, 1));
                            this.drawOnionFrame(curLayer.frames[frameIdx], this.onionPrevColor, fadeOpacity);
                        }
                    }
                    for (let offset = 1; offset <= this.onionFramesAfter; offset++) {
                        const frameIdx = this.currentFrameIndex + offset;
                        if (frameIdx < curLayer.frames.length && curLayer.frames[frameIdx] && curLayer.visible) {
                            const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesAfter, 1));
                            this.drawOnionFrame(curLayer.frames[frameIdx], this.onionNextColor, fadeOpacity);
                        }
                    }
                } else if (!this.isPlaying) {
                    // Onion skin disabled â€” clear stale content
                    this.onionCtx.clearRect(0, 0, this.onionCanvas.width, this.onionCanvas.height);
                }
                
                const playheadPos = this.getPlayheadPosition();
                if (this.layers.length > 2 && !this.isPlaying) {
                    this._drawWithCompositeCache(this.ctx, playheadPos);
                } else {
                    for (const layer of this.layers) {
                        this.drawLayerWithTransform(this.ctx, layer, playheadPos);
                    }
                }
                this.drawAnchorIndicator(this.ctx);
                this.drawPasteboardOverlay(this.ctx);
                
                if (this.selection && !this.isPlaying) {
                    this._drawSelectionPreview(this.ctx);
                }
                
                // Draw gradient edit overlay if active
                if (this._gradientEdit && !this.isPlaying) {
                    this._drawGradientEditPreview();
                }
            }
            
            renderLayers() {
                // Shim â€” renderTimeline builds both labels and frames
                this._timelineDirty = true;
                this._invalidateCompositeCache();
                this.renderTimeline();
            }
            
            // Mark timeline for full DOM rebuild on next render()
            _markTimelineDirty() {
                this._timelineDirty = true;
                this._invalidateCompositeCache();
            }
            
            // Lightweight timeline update: swap active frame highlight + update playhead
            // Avoids full DOM rebuild â€” used when only the current frame index changed
            _updateTimelineActive() {
                const container = document.getElementById('framesContainer');
                if (!container) return;
                
                const playheadPos = this.getPlayheadPosition();
                
                // Remove active class from previously tracked element
                if (this._activeFrameEl) {
                    this._activeFrameEl.classList.remove('active');
                }
                // Remove active from previous hold block
                if (this._activeHoldBlock) {
                    this._activeHoldBlock.classList.remove('has-active');
                    const oldPh = this._activeHoldBlock.querySelector('.hold-block-playhead');
                    if (oldPh) oldPh.remove();
                    const oldSource = this._activeHoldBlock.querySelector('.hold-block-source');
                    if (oldSource) oldSource.classList.remove('source-active');
                    this._activeHoldBlock = null;
                }
                
                // Check if active frame is inside a hold block
                const layer = this.getCurrentLayer();
                const offset = layer.startFrame || 0;
                const { segments, frameMap } = this.getHoldSegments(layer);
                const seg = frameMap.get(this.currentFrameIndex);
                
                if (seg) {
                    // Active frame is within a hold block â€” find the block element
                    const holdBlockEl = container.querySelector(
                        `.hold-block[data-layer-id="${this.currentLayerId}"][data-hold-start="${seg.startIndex}"]`
                    );
                    if (holdBlockEl) {
                        holdBlockEl.classList.add('has-active');
                        this._activeHoldBlock = holdBlockEl;
                        
                        // Position playhead within the block
                        const bar = holdBlockEl.querySelector('.hold-block-bar');
                        if (bar) {
                            // Remove old playhead
                            const oldPh = bar.querySelector('.hold-block-playhead');
                            if (oldPh) oldPh.remove();
                            
                            const { cellW, frameW } = this.getTimelineMetrics();
                            const ph = document.createElement('div');
                            ph.className = 'hold-block-playhead';
                            ph.style.left = ((this.currentFrameIndex - seg.startIndex) * cellW) + 'px';
                            ph.style.width = frameW + 'px';
                            bar.appendChild(ph);
                        }
                        
                        // Update source indicator
                        const sourceEl = holdBlockEl.querySelector('.hold-block-source');
                        if (sourceEl) {
                            // Toggle source-active when playhead is on the first frame
                            if (this.currentFrameIndex === seg.startIndex) {
                                sourceEl.classList.add('source-active');
                            } else {
                                sourceEl.classList.remove('source-active');
                            }
                            
                            const frame = layer.frames[seg.startIndex];
                            const hasContent = frame && this._frameHasContent(frame);
                            const existingInd = sourceEl.querySelector('.frame-indicator');
                            if (hasContent && !existingInd) {
                                const ind = document.createElement('div');
                                ind.className = 'frame-indicator circle';
                                ind.style.background = '#5b8def';
                                sourceEl.appendChild(ind);
                            } else if (!hasContent && existingInd) {
                                existingInd.remove();
                            } else if (hasContent && existingInd) {
                                existingInd.style.background = '#5b8def';
                            }
                        }
                    }
                    this._activeFrameEl = null;
                } else {
                    // Regular frame â€” find and activate
                    const newActive = container.querySelector(
                        `.frame[data-layer-id="${this.currentLayerId}"][data-timeline-pos="${playheadPos}"]`
                    );
                    if (newActive) {
                        newActive.classList.add('active');
                        this._activeFrameEl = newActive;
                        
                        // Refresh indicator for active frame
                        const frame = layer.frames[this.currentFrameIndex];
                        const thumbEl = newActive.querySelector('.frame-thumb');
                        if (thumbEl && frame) {
                            const existingIndicator = thumbEl.querySelector('.frame-indicator');
                            const hasContent = this._frameHasContent(frame);
                            if (hasContent && !existingIndicator) {
                                const ind = document.createElement('div');
                                ind.className = 'frame-indicator circle';
                                thumbEl.appendChild(ind);
                            } else if (!hasContent && existingIndicator) {
                                existingIndicator.remove();
                            } else if (hasContent && existingIndicator) {
                                existingIndicator.className = 'frame-indicator circle';
                            }
                        } else if (thumbEl && !frame) {
                            const existingIndicator = thumbEl.querySelector('.frame-indicator');
                            if (existingIndicator) existingIndicator.remove();
                        }
                    } else {
                        this._activeFrameEl = null;
                    }
                }
                
                // Update playhead position
                this.updatePlayheadPosition();
                
                // Selection diffing â€” only toggle classes on changed frames
                const container2 = document.getElementById('framesContainer');
                if (container2) {
                    const prev = this._prevSelectedFrames;
                    const curr = this.selectedFrames;
                    // Find deselected frames
                    for (const i of prev) {
                        if (!curr.has(i)) {
                            const el = container2.querySelector(
                                `.frame[data-frame-index="${i}"][data-layer-id="${this.currentLayerId}"],` +
                                `.hold-block[data-layer-id="${this.currentLayerId}"][data-hold-start="${i}"]`
                            );
                            if (el) el.classList.remove('selected');
                        }
                    }
                    // Find newly selected frames
                    for (const i of curr) {
                        if (!prev.has(i)) {
                            const el = container2.querySelector(
                                `.frame[data-frame-index="${i}"][data-layer-id="${this.currentLayerId}"],` +
                                `.hold-block[data-layer-id="${this.currentLayerId}"][data-hold-start="${i}"]`
                            );
                            if (el) el.classList.add('selected');
                        }
                    }
                }
                
                // Update tracking state
                this._prevPlayhead = this.currentFrameIndex;
                this._prevSelectedFrames = new Set(this.selectedFrames);
            }
            
            _reorderLayer(dragId, targetId, position) {
                // The UI is reversed: top of list = top layer = end of array
                const dragIdx = this.layers.findIndex(l => l.id === dragId);
                const targetIdx = this.layers.findIndex(l => l.id === targetId);
                if (dragIdx === -1 || targetIdx === -1 || dragIdx === targetIdx) return;
                
                this.saveFullState();
                
                const [draggedLayer] = this.layers.splice(dragIdx, 1);
                
                // Recalculate target index after removal
                let newIdx = this.layers.findIndex(l => l.id === targetId);
                
                // UI is reversed: "before" in UI (above) = higher in stack = higher array index
                if (position === 'before') {
                    newIdx += 1; // Insert after in array = above in UI
                }
                
                this.layers.splice(newIdx, 0, draggedLayer);
                this.render();
            }
            
            renderTimeline() {
                // Cancel any pending debounced render
                if (this._rtRaf) { cancelAnimationFrame(this._rtRaf); this._rtRaf = null; }
                
                // Fast path: if only playhead/selection changed, skip full DOM rebuild
                if (!this._timelineDirty && this._prevLayerId === this.currentLayerId) {
                    this._updateTimelineActive();
                    return;
                }
                
                this._renderTimelineImpl();
            }
            
            // Debounced version â€” used from render() to coalesce rapid calls
            _scheduleRenderTimeline() {
                if (this._rtRaf) return; // already scheduled
                this._rtRaf = requestAnimationFrame(() => {
                    this._rtRaf = null;
                    this._renderTimelineImpl();
                });
            }
            
            _renderTimelineImpl() {
                this._timelineDirty = false; // Clear flag â€” we're doing a full rebuild
                this._activeFrameEl = null; // Old DOM elements destroyed
                this._activeHoldBlock = null; // Old hold block DOM destroyed
                this._prevPlayhead = this.currentFrameIndex;
                this._prevLayerId = this.currentLayerId;
                this._prevSelectedFrames = new Set(this.selectedFrames);
                
                // Invalidate holdGroups caches
                for (const layer of this.layers) {
                    layer._holdGroupsCache = null;
                    layer._holdSegmentsCache = null;
                }
                
                const container = document.getElementById('framesContainer');
                const layersList = document.getElementById('layersList');
                
                // Preserve scroll position across DOM rebuild
                const framesSection = document.getElementById('timelineFramesSection');
                const savedScrollLeft = framesSection ? framesSection.scrollLeft : 0;
                
                container.innerHTML = '';
                layersList.innerHTML = '';
                
                // Use DocumentFragments to batch DOM insertions (avoids reflow per append)
                const containerFrag = document.createDocumentFragment();
                const labelsFrag = document.createDocumentFragment();
                
                // Re-append the drop indicator if it exists
                if (this._dropIndicator) {
                    this._dropIndicator.style.display = 'none';
                }
                
                // Find max timeline length across all layers + audio (for ruler width)
                this._maxFrameCount = this.getTimelineLength();
                
                // Build each layer row (reversed: top layer = top of list)
                const reversedLayers = [...this.layers].reverse();
                
                reversedLayers.forEach((layer) => {
                    const isActive = layer.id === this.currentLayerId && !this.audioLayerSelected;
                    const rowCls = isActive ? 'active-row' : 'inactive-row';
                    
                    // === LEFT LABEL ===
                    const label = document.createElement('div');
                    label.className = 'tl-label ' + rowCls;
                    label.dataset.layerId = layer.id;
                    label.style.position = 'relative';
                    
                    const dragHandle = document.createElement('span');
                    dragHandle.className = 'layer-drag-handle';
                    dragHandle.innerHTML = '<svg width="8" height="12" viewBox="0 0 10 14" fill="currentColor"><circle cx="3" cy="2" r="1.3"/><circle cx="7" cy="2" r="1.3"/><circle cx="3" cy="7" r="1.3"/><circle cx="7" cy="7" r="1.3"/><circle cx="3" cy="12" r="1.3"/><circle cx="7" cy="12" r="1.3"/></svg>';
                    
                    // Disclosure twirl triangle
                    const isOpen = this._openTransformLayers.has(layer.id);
                    const twirl = document.createElement('span');
                    twirl.className = 'tl-label-twirl' + (isOpen ? ' open' : '');
                    twirl.textContent = 'â–¶';
                    twirl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (this._openTransformLayers.has(layer.id)) {
                            this._openTransformLayers.delete(layer.id);
                            if (this._curveEditorActive && this._curveEditorLayerId === layer.id) {
                                this.closeCurveEditor();
                                return;
                            }
                        } else {
                            this._openTransformLayers.add(layer.id);
                        }
                        this._timelineDirty = true;
                        this.renderTimeline();
                    });
                    
                    const vis = document.createElement('span');
                    vis.className = 'layer-visibility';
                    vis.innerHTML = layer.visible
                        ? '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>'
                        : '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>';
                    vis.addEventListener('click', (e) => {
                        e.stopPropagation();
                        layer.visible = !layer.visible;
                        this._invalidateCompositeCache();
                        this._timelineDirty = true;
                        this.render();
                    });
                    
                    const name = document.createElement('span');
                    name.className = 'layer-name';
                    name.textContent = layer.name;
                    
                    // Click on name: first click selects layer, rapid second click renames
                    name.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (e.target.closest('.layer-name-input')) return;
                        
                        // If this layer is already selected, start rename on second quick click
                        if (this.currentLayerId === layer.id && this._layerNameClickId === layer.id && 
                            Date.now() - this._layerNameClickTime < 500) {
                            this._layerNameClickId = null;
                            // Start inline rename
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.value = layer.name;
                            input.className = 'layer-name-input';
                            input.style.cssText = 'background:#2b2d31;color:#ddd;border:none;outline:none;font:inherit;padding:0 4px;width:100%;box-sizing:border-box;border-radius:6px;box-shadow:inset 2px 2px 4px rgba(0,0,0,0.35),inset -1px -1px 3px rgba(255,255,255,0.03);';
                            
                            const commit = () => {
                                const newName = input.value.trim();
                                if (newName && newName !== layer.name) {
                                    layer.name = newName;
                                }
                                this._timelineDirty = true;
                                this.renderTimeline();
                            };
                            
                            input.addEventListener('blur', commit);
                            input.addEventListener('keydown', (ke) => {
                                ke.stopPropagation();
                                if (ke.key === 'Enter') { input.blur(); }
                                else if (ke.key === 'Escape') { input.value = layer.name; input.blur(); }
                            });
                            
                            name.textContent = '';
                            name.appendChild(input);
                            input.focus();
                            input.select();
                            return;
                        }
                        
                        // Record click for double-click detection
                        this._layerNameClickId = layer.id;
                        this._layerNameClickTime = Date.now();
                        
                        // Select the layer
                        if (this.currentLayerId !== layer.id) {
                            this.commitSelection();
                            this.currentLayerId = layer.id;
                            this.audioLayerSelected = false;
                            this._timelineDirty = true;
                            this.initializeFrame();
                            this.render();
                        }
                    });
                    
                    const topRow = document.createElement('div');
                    topRow.className = 'tl-label-row';
                    topRow.appendChild(twirl);
                    topRow.appendChild(dragHandle);
                    topRow.appendChild(vis);
                    topRow.appendChild(name);
                    
                    // Inline parent dropdown (compact, right-aligned before quick-key button)
                    const parSelect = document.createElement('select');
                    parSelect.className = 'parent-select-inline';
                    parSelect.title = 'Parent layer';
                    const noneOpt = document.createElement('option');
                    noneOpt.value = '';
                    noneOpt.textContent = 'â€”';
                    parSelect.appendChild(noneOpt);
                    for (const otherLayer of this.layers) {
                        if (otherLayer.id === layer.id) continue;
                        if (this._wouldCreateCycle(layer.id, otherLayer.id)) continue;
                        const opt = document.createElement('option');
                        opt.value = otherLayer.id;
                        opt.textContent = otherLayer.name;
                        if (layer.parentId === otherLayer.id) opt.selected = true;
                        parSelect.appendChild(opt);
                    }
                    if (layer.parentId != null) parSelect.classList.add('has-parent');
                    parSelect.addEventListener('change', (e) => {
                        e.stopPropagation();
                        this.saveFullState();
                        const val = parSelect.value;
                        layer.parentId = val ? parseInt(val) : null;
                        this.render();
                    });
                    parSelect.addEventListener('keydown', (e) => e.stopPropagation());
                    parSelect.addEventListener('click', (e) => e.stopPropagation());
                    topRow.appendChild(parSelect);
                    
                    // Quick keyframe button (right-aligned)
                    const hasKeyHereQuick = this.hasTransformKeyframeAt(layer, this.currentFrameIndex);
                    const quickKeyBtn = document.createElement('button');
                    quickKeyBtn.className = 'quick-key-btn' + (hasKeyHereQuick ? ' has-key' : '');
                    quickKeyBtn.title = hasKeyHereQuick ? 'Remove keyframe at current frame' : 'Add keyframe at current frame';
                    quickKeyBtn.innerHTML = '<svg viewBox="0 0 10 10" width="12" height="12"><polygon points="5,0 10,5 5,10 0,5" fill="currentColor"/></svg>';
                    quickKeyBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.saveFullState();
                        if (hasKeyHereQuick) {
                            this.removeTransformKeyframe(layer, this.currentFrameIndex);
                        } else {
                            const tf = this.getLayerTransformAtFrame(layer, this.currentFrameIndex);
                            this.setTransformKeyframe(layer, this.currentFrameIndex, {
                                x: tf.x, y: tf.y,
                                anchorX: tf.anchorX, anchorY: tf.anchorY,
                                scaleX: tf.scaleX, scaleY: tf.scaleY,
                                rotation: tf.rotation, opacity: tf.opacity
                            });
                        }
                        this.render();
                    });
                    topRow.appendChild(quickKeyBtn);
                    
                    label.appendChild(topRow);
                    
                    // === PROPERTY PANEL DROPDOWN (AE-style scrub sliders) ===
                    if (isOpen) {
                        const props = document.createElement('div');
                        props.className = 'tl-props open';
                        
                        const tf = this.getLayerTransformAtFrame(layer, this.currentFrameIndex);
                        const hasKeyHere = this.hasTransformKeyframeAt(layer, this.currentFrameIndex);
                        const inputs = {};
                        
                        // Diamond SVG template
                        const diamondSVG = '<svg viewBox="0 0 10 10"><polygon class="diamond-fill" points="5,0 10,5 5,10 0,5"/></svg>';
                        
                        // Create a scrub slider element
                        const makeScrub = (key, value, min, max, step, unit, sensitivity) => {
                            const wrap = document.createElement('div');
                            wrap.className = 'scrub-slider';
                            
                            const fill = document.createElement('div');
                            fill.className = 'scrub-fill';
                            
                            const valDisplay = document.createElement('div');
                            valDisplay.className = 'scrub-value';
                            
                            const editInput = document.createElement('input');
                            editInput.type = 'number';
                            editInput.className = 'scrub-input';
                            editInput.step = step;
                            
                            let currentVal = value;
                            inputs[key] = { getValue: () => currentVal, el: wrap };
                            
                            const updateDisplay = () => {
                                const displayVal = Math.abs(step) < 1 ? currentVal.toFixed(1) : Math.round(currentVal);
                                valDisplay.innerHTML = `${displayVal}<span class="scrub-unit">${unit}</span>`;
                                // Fill bar: map value to 0-100% of slider width
                                if (min != null && max != null) {
                                    const pct = Math.max(0, Math.min(100, ((currentVal - min) / (max - min)) * 100));
                                    fill.style.width = pct + '%';
                                } else {
                                    // Unbounded: no fill bar
                                    fill.style.width = '0%';
                                }
                            };
                            
                            const commitValue = (newVal) => {
                                currentVal = Math.round(newVal / step) * step;
                                if (min != null) currentVal = Math.max(min, currentVal);
                                if (max != null) currentVal = Math.min(max, currentVal);
                                updateDisplay();
                                
                                if (hasKeyHere) {
                                    const p = this._readPropInputs(inputs);
                                    this.setTransformKeyframe(layer, this.currentFrameIndex, p);
                                    this.renderCanvasOnly();
                                } else if (key === 'opacity') {
                                    layer.opacity = Math.max(0, Math.min(1, currentVal / 100));
                                    this._invalidateCompositeCache();
                                    this.renderCanvasOnly();
                                }
                            };
                            
                            // Drag to scrub
                            let dragStartX = 0, dragStartVal = 0, isDragging = false;
                            
                            wrap.addEventListener('pointerdown', (e) => {
                                if (editInput.style.display === 'block') return;
                                e.stopPropagation();
                                e.preventDefault();
                                isDragging = true;
                                dragStartX = e.clientX;
                                dragStartVal = currentVal;
                                wrap.classList.add('dragging');
                                wrap.setPointerCapture(e.pointerId);
                                if (key === 'anchorX' || key === 'anchorY') {
                                    this._showAnchorIndicator = true;
                                    this.renderCanvasOnly();
                                }
                            });
                            
                            wrap.addEventListener('pointermove', (e) => {
                                if (!isDragging) return;
                                const dx = e.clientX - dragStartX;
                                const newVal = dragStartVal + dx * (sensitivity || step);
                                commitValue(newVal);
                            });
                            
                            wrap.addEventListener('pointerup', (e) => {
                                if (!isDragging) return;
                                isDragging = false;
                                wrap.classList.remove('dragging');
                                if (key === 'anchorX' || key === 'anchorY') {
                                    this._showAnchorIndicator = false;
                                    this.renderCanvasOnly();
                                }
                            });
                            
                            // Double-click to type
                            wrap.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                editInput.style.display = 'block';
                                editInput.value = Math.abs(step) < 1 ? currentVal.toFixed(1) : Math.round(currentVal);
                                editInput.focus();
                                editInput.select();
                                if (key === 'anchorX' || key === 'anchorY') {
                                    this._showAnchorIndicator = true;
                                    this.renderCanvasOnly();
                                }
                            });
                            
                            editInput.addEventListener('keydown', (e) => {
                                e.stopPropagation();
                                if (e.key === 'Enter') { editInput.blur(); }
                                if (e.key === 'Escape') {
                                    editInput.style.display = 'none';
                                    if (key === 'anchorX' || key === 'anchorY') {
                                        this._showAnchorIndicator = false;
                                        this.renderCanvasOnly();
                                    }
                                }
                            });
                            
                            editInput.addEventListener('blur', () => {
                                editInput.style.display = 'none';
                                const v = parseFloat(editInput.value);
                                if (!isNaN(v)) commitValue(v);
                                if (key === 'anchorX' || key === 'anchorY') {
                                    this._showAnchorIndicator = false;
                                    this.renderCanvasOnly();
                                }
                            });
                            
                            editInput.addEventListener('pointerdown', (e) => e.stopPropagation());
                            
                            wrap.appendChild(fill);
                            wrap.appendChild(valDisplay);
                            wrap.appendChild(editInput);
                            updateDisplay();
                            return wrap;
                        };
                        
                        // Position row (paired X, Y)
                        const posRow = document.createElement('div');
                        posRow.className = 'tl-prop';
                        const posDia = document.createElement('span');
                        posDia.className = 'tl-prop-diamond' + (hasKeyHere ? ' has-key' : '');
                        posDia.innerHTML = diamondSVG;
                        posDia.addEventListener('click', (e) => { e.stopPropagation(); if (!hasKeyHere) { this.saveFullState(); this.setTransformKeyframe(layer, this.currentFrameIndex, this._readPropInputs(inputs)); this.render(); }});
                        posRow.appendChild(posDia);
                        const posLbl = document.createElement('span');
                        posLbl.className = 'tl-prop-name';
                        posLbl.textContent = 'Position';
                        posRow.appendChild(posLbl);
                        const posPair = document.createElement('div');
                        posPair.className = 'tl-prop-pair-wrap';
                        const pxWrap = document.createElement('div');
                        pxWrap.className = 'scrub-pair';
                        const pxLbl = document.createElement('span');
                        pxLbl.className = 'pair-lbl';
                        pxLbl.textContent = 'X';
                        pxWrap.appendChild(pxLbl);
                        pxWrap.appendChild(makeScrub('x', Math.round(tf.x), -2000, 2000, 1, 'px', 1));
                        posPair.appendChild(pxWrap);
                        const pyWrap = document.createElement('div');
                        pyWrap.className = 'scrub-pair';
                        const pyLbl = document.createElement('span');
                        pyLbl.className = 'pair-lbl';
                        pyLbl.textContent = 'Y';
                        pyWrap.appendChild(pyLbl);
                        pyWrap.appendChild(makeScrub('y', Math.round(tf.y), -2000, 2000, 1, 'px', 1));
                        posPair.appendChild(pyWrap);
                        posRow.appendChild(posPair);
                        props.appendChild(posRow);
                        
                        // Anchor Point row (paired X, Y)
                        const ancRow = document.createElement('div');
                        ancRow.className = 'tl-prop';
                        const ancDia = document.createElement('span');
                        ancDia.className = 'tl-prop-diamond' + (hasKeyHere ? ' has-key' : '');
                        ancDia.innerHTML = diamondSVG;
                        ancDia.addEventListener('click', (e) => { e.stopPropagation(); if (!hasKeyHere) { this.saveFullState(); this.setTransformKeyframe(layer, this.currentFrameIndex, this._readPropInputs(inputs)); this.render(); }});
                        ancRow.appendChild(ancDia);
                        const ancLbl = document.createElement('span');
                        ancLbl.className = 'tl-prop-name';
                        ancLbl.textContent = 'Anchor';
                        ancRow.appendChild(ancLbl);
                        const ancPair = document.createElement('div');
                        ancPair.className = 'tl-prop-pair-wrap';
                        const axWrap = document.createElement('div');
                        axWrap.className = 'scrub-pair';
                        const axLbl = document.createElement('span');
                        axLbl.className = 'pair-lbl';
                        axLbl.textContent = 'X';
                        axWrap.appendChild(axLbl);
                        axWrap.appendChild(makeScrub('anchorX', Math.round(tf.anchorX), -2000, 2000, 1, 'px', 1));
                        ancPair.appendChild(axWrap);
                        const ayWrap = document.createElement('div');
                        ayWrap.className = 'scrub-pair';
                        const ayLbl = document.createElement('span');
                        ayLbl.className = 'pair-lbl';
                        ayLbl.textContent = 'Y';
                        ayWrap.appendChild(ayLbl);
                        ayWrap.appendChild(makeScrub('anchorY', Math.round(tf.anchorY), -2000, 2000, 1, 'px', 1));
                        ancPair.appendChild(ayWrap);
                        ancRow.appendChild(ancPair);
                        props.appendChild(ancRow);
                        
                        // Scale row (paired X, Y)
                        const scRow = document.createElement('div');
                        scRow.className = 'tl-prop';
                        const scDia = document.createElement('span');
                        scDia.className = 'tl-prop-diamond' + (hasKeyHere ? ' has-key' : '');
                        scDia.innerHTML = diamondSVG;
                        scDia.addEventListener('click', (e) => { e.stopPropagation(); if (!hasKeyHere) { this.saveFullState(); this.setTransformKeyframe(layer, this.currentFrameIndex, this._readPropInputs(inputs)); this.render(); }});
                        scRow.appendChild(scDia);
                        const scLbl = document.createElement('span');
                        scLbl.className = 'tl-prop-name';
                        scLbl.textContent = 'Scale';
                        scRow.appendChild(scLbl);
                        const scPair = document.createElement('div');
                        scPair.className = 'tl-prop-pair-wrap';
                        const sxWrap = document.createElement('div');
                        sxWrap.className = 'scrub-pair';
                        const sxLbl = document.createElement('span');
                        sxLbl.className = 'pair-lbl';
                        sxLbl.textContent = 'X';
                        sxWrap.appendChild(sxLbl);
                        sxWrap.appendChild(makeScrub('scaleX', Math.round(tf.scaleX * 100), 1, 500, 1, '%', 0.5));
                        scPair.appendChild(sxWrap);
                        const syWrap = document.createElement('div');
                        syWrap.className = 'scrub-pair';
                        const syLbl = document.createElement('span');
                        syLbl.className = 'pair-lbl';
                        syLbl.textContent = 'Y';
                        syWrap.appendChild(syLbl);
                        syWrap.appendChild(makeScrub('scaleY', Math.round(tf.scaleY * 100), 1, 500, 1, '%', 0.5));
                        scPair.appendChild(syWrap);
                        scRow.appendChild(scPair);
                        props.appendChild(scRow);
                        
                        // Rotation row (single)
                        const rotRow = document.createElement('div');
                        rotRow.className = 'tl-prop';
                        const rotDia = document.createElement('span');
                        rotDia.className = 'tl-prop-diamond' + (hasKeyHere ? ' has-key' : '');
                        rotDia.innerHTML = diamondSVG;
                        rotDia.addEventListener('click', (e) => { e.stopPropagation(); if (!hasKeyHere) { this.saveFullState(); this.setTransformKeyframe(layer, this.currentFrameIndex, this._readPropInputs(inputs)); this.render(); }});
                        rotRow.appendChild(rotDia);
                        const rotLbl = document.createElement('span');
                        rotLbl.className = 'tl-prop-name';
                        rotLbl.textContent = 'Rotation';
                        rotRow.appendChild(rotLbl);
                        rotRow.appendChild(makeScrub('rotation', Math.round(tf.rotation * 10) / 10, null, null, 1, 'Â°', 0.5));
                        props.appendChild(rotRow);
                        
                        // Opacity row (single)
                        const opRow = document.createElement('div');
                        opRow.className = 'tl-prop';
                        const opDia = document.createElement('span');
                        opDia.className = 'tl-prop-diamond' + (hasKeyHere ? ' has-key' : '');
                        opDia.innerHTML = diamondSVG;
                        opDia.addEventListener('click', (e) => { e.stopPropagation(); if (!hasKeyHere) { this.saveFullState(); this.setTransformKeyframe(layer, this.currentFrameIndex, this._readPropInputs(inputs)); this.render(); }});
                        opRow.appendChild(opDia);
                        const opLbl = document.createElement('span');
                        opLbl.className = 'tl-prop-name';
                        opLbl.textContent = 'Opacity';
                        opRow.appendChild(opLbl);
                        opRow.appendChild(makeScrub('opacity', Math.round(tf.opacity * 100), 0, 100, 1, '%', 0.5));
                        props.appendChild(opRow);
                        
                        // Keyframe actions
                        const actRow = document.createElement('div');
                        actRow.className = 'tl-key-actions';
                        
                        const setBtn = document.createElement('button');
                        setBtn.className = 'act-set';
                        setBtn.textContent = 'â—† Set Key';
                        setBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.saveFullState();
                            const p = this._readPropInputs(inputs);
                            this.setTransformKeyframe(layer, this.currentFrameIndex, p);
                            this.render();
                        });
                        
                        const delBtn = document.createElement('button');
                        delBtn.className = 'act-del';
                        delBtn.textContent = 'âœ• Remove Key';
                        delBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.saveFullState();
                            this.removeTransformKeyframe(layer, this.currentFrameIndex);
                            this.render();
                        });
                        
                        actRow.appendChild(setBtn);
                        actRow.appendChild(delBtn);
                        
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'act-copy';
                        copyBtn.textContent = 'âŽ˜ Copy';
                        copyBtn.disabled = !hasKeyHere;
                        copyBtn.title = hasKeyHere ? 'Copy keyframe values' : 'No keyframe to copy at this frame';
                        copyBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const kf = (layer.transformKeyframes || []).find(k => k.frame === this.currentFrameIndex);
                            if (kf) {
                                this._copiedKeyframe = {
                                    x: kf.x, y: kf.y,
                                    anchorX: kf.anchorX || 0, anchorY: kf.anchorY || 0,
                                    scaleX: kf.scaleX, scaleY: kf.scaleY,
                                    rotation: kf.rotation,
                                    opacity: kf.opacity != null ? kf.opacity : 1,
                                    easeX1: kf.easeX1, easeY1: kf.easeY1,
                                    easeX2: kf.easeX2, easeY2: kf.easeY2
                                };
                                // Flash feedback
                                copyBtn.textContent = 'âœ“ Copied';
                                setTimeout(() => { copyBtn.textContent = 'âŽ˜ Copy'; }, 800);
                                // Enable paste button
                                if (pasteBtn) { pasteBtn.disabled = false; pasteBtn.title = 'Paste keyframe values'; }
                            }
                        });
                        actRow.appendChild(copyBtn);
                        
                        const pasteBtn = document.createElement('button');
                        pasteBtn.className = 'act-paste';
                        pasteBtn.textContent = 'âŽ— Paste';
                        pasteBtn.disabled = !this._copiedKeyframe;
                        pasteBtn.title = this._copiedKeyframe ? 'Paste keyframe values at current frame' : 'No keyframe copied yet';
                        pasteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (!this._copiedKeyframe) return;
                            this.saveFullState();
                            this.setTransformKeyframe(layer, this.currentFrameIndex, { ...this._copiedKeyframe });
                            this.render();
                        });
                        actRow.appendChild(pasteBtn);
                        
                        const curveBtn = document.createElement('button');
                        curveBtn.className = 'act-curve' + (this._curveEditorActive && this._curveEditorLayerId === layer.id ? ' active' : '');
                        curveBtn.textContent = 'âŒ‡ Curves';
                        curveBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.toggleCurveEditor(layer);
                        });
                        actRow.appendChild(curveBtn);
                        
                        props.appendChild(actRow);
                        
                        label.appendChild(props);
                    }
                    
                    // Click label to select layer
                    label.addEventListener('click', (e) => {
                        if (this._layerDragDidMove) return;
                        if (e.target.closest('.layer-visibility')) return;
                        if (e.target.closest('.layer-drag-handle')) return;
                        if (e.target.closest('.tl-label-twirl')) return;
                        if (e.target.closest('.tl-props')) return;
                        if (e.target.closest('.layer-name-input')) return;
                        if (e.target.closest('.layer-name')) return; // Handled by name click
                        if (e.target.closest('.parent-select-inline')) return;
                        if (e.target.closest('.quick-key-btn')) return;
                        this.commitSelection();
                        this.currentLayerId = layer.id;
                        this.audioLayerSelected = false;
                        this.initializeFrame();
                        this.render();
                    });
                    
                    // Layer drag reorder
                    dragHandle.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this._layerDragId = layer.id;
                        this._layerDragDidMove = false;
                        this._layerDragStartY = e.clientY;
                        label.classList.add('dragging');
                        
                        const onMove = (me) => {
                            if (this._layerDragId === null) return;
                            if (Math.abs(me.clientY - this._layerDragStartY) > 3) this._layerDragDidMove = true;
                            if (!this._layerDragDidMove) return;
                            
                            const items = layersList.querySelectorAll('.tl-label');
                            items.forEach(item => item.classList.remove('drop-before', 'drop-after'));
                            
                            for (const item of items) {
                                if (item.dataset.layerId == this._layerDragId) continue;
                                const rect = item.getBoundingClientRect();
                                if (me.clientY >= rect.top && me.clientY <= rect.bottom) {
                                    const mid = rect.top + rect.height / 2;
                                    if (me.clientY < mid) {
                                        item.classList.add('drop-before');
                                        this._layerDropTarget = parseInt(item.dataset.layerId);
                                        this._layerDropPos = 'before';
                                    } else {
                                        item.classList.add('drop-after');
                                        this._layerDropTarget = parseInt(item.dataset.layerId);
                                        this._layerDropPos = 'after';
                                    }
                                    break;
                                }
                            }
                        };
                        
                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.removeEventListener('pointercancel', onUp);
                            label.classList.remove('dragging');
                            layersList.querySelectorAll('.tl-label').forEach(item => {
                                item.classList.remove('drop-before', 'drop-after');
                            });
                            if (this._layerDragDidMove && this._layerDropTarget != null) {
                                this._reorderLayer(this._layerDragId, this._layerDropTarget, this._layerDropPos);
                            }
                            this._layerDragId = null;
                            this._layerDropTarget = null;
                            this._layerDropPos = null;
                            setTimeout(() => { this._layerDragDidMove = false; }, 0);
                        };
                        
                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        document.addEventListener('pointercancel', onUp);
                    });
                    
                    labelsFrag.appendChild(label);
                    
                    // === RIGHT FRAME ROW ===
                    const row = document.createElement('div');
                    row.className = 'layer-frames-row ' + rowCls;
                    row.dataset.layerId = layer.id;
                    
                    // Build hold frame set for this layer with per-group colors
                    const holdGroups = this.getHoldGroups(layer);
                    const holdFrameSet = new Set();
                    const holdColorMap = new Map(); // frameIndex -> { color, isSource }
                    const holdPalette = [
                        '#6ea8fe', '#f7a072', '#7ee8a2', '#d4a0f5',
                        '#f06292', '#ffe066', '#4dd0e1', '#ffab91',
                    ];
                    let groupIdx = 0;
                    for (const [canvas, indices] of holdGroups) {
                        // Use persistent color if available, else assign by encounter order
                        const color = canvas._holdColor || holdPalette[groupIdx % holdPalette.length];
                        groupIdx++;
                        // Find the source (earliest index)
                        const sorted = [...indices].sort((a, b) => a - b);
                        const sourceIdx = sorted[0];
                        for (const idx of sorted) {
                            holdFrameSet.add(idx);
                            holdColorMap.set(idx, { color, isSource: idx === sourceIdx });
                        }
                    }
                    
                    // Build contiguous hold segments for block rendering
                    const holdSegData = this.getHoldSegments(layer);
                    
                    const offset = layer.startFrame || 0;
                    const playheadPos = this.getPlayheadPosition();
                    const layerLocalMax = Math.max(layer.frames.length, isActive ? this.currentFrameIndex + 1 : 0);
                    
                    // Spacer for offset
                    if (offset > 0) {
                        const spacer = document.createElement('div');
                        spacer.className = 'frame-offset-spacer';
                        const { cellW } = this.getTimelineMetrics();
                        spacer.style.width = (offset * cellW) + 'px';
                        spacer.style.flexShrink = '0';
                        spacer.style.position = 'relative';
                        row.appendChild(spacer);
                    }
                    
                    // Frame block wrapper (for drag-to-slide)
                    const blockWrap = document.createElement('div');
                    blockWrap.className = 'frame-block';
                    blockWrap.dataset.layerId = layer.id;
                    
                    // Pre-build keyframe Set for O(1) lookup
                    const keyframeSet = new Set((layer.transformKeyframes || []).map(kf => kf.frame));
                    
                    // Virtualization: use absolute positioning, only create visible frames
                    const { cellW, frameW, gap } = this.getTimelineMetrics();
                    blockWrap.style.display = 'block';
                    blockWrap.style.position = 'relative';
                    blockWrap.style.minWidth = (layerLocalMax * cellW) + 'px';
                    blockWrap.style.height = (frameW + 20) + 'px';
                    
                    // Store metadata for scroll-based re-rendering
                    blockWrap._virt = {
                        layer, layerLocalMax, offset, holdFrameSet, holdColorMap,
                        holdSegData,
                        isActive, playheadPos, keyframeSet, cellW, frameW, gap,
                        renderedRange: null
                    };
                    
                    // Slide handle on left edge
                    const slideHandle = document.createElement('div');
                    slideHandle.className = 'slide-handle';
                    blockWrap.appendChild(slideHandle);
                    
                    // Slide drag interaction â€” use document listeners since renderTimeline destroys elements
                    const layerForSlide = layer;
                    const spacerForSlide = (offset > 0) ? row.querySelector('.frame-offset-spacer') : null;
                    slideHandle.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const startX = e.clientX;
                        const startOffset = layerForSlide.startFrame || 0;
                        const { cellW } = this.getTimelineMetrics();
                        blockWrap.classList.add('sliding');
                        this._blockSliding = true;
                        
                        // Create or reuse a spacer for visual feedback
                        let liveSpacer = spacerForSlide;
                        if (!liveSpacer) {
                            liveSpacer = document.createElement('div');
                            liveSpacer.className = 'frame-offset-spacer';
                            liveSpacer.style.flexShrink = '0';
                            liveSpacer.style.position = 'relative';
                            liveSpacer.style.width = '0px';
                            row.insertBefore(liveSpacer, blockWrap);
                        }
                        
                        const onMove = (ev) => {
                            const dx = ev.clientX - startX;
                            const frameDelta = Math.round(dx / cellW);
                            const newOffset = Math.max(0, startOffset + frameDelta);
                            layerForSlide.startFrame = newOffset;
                            liveSpacer.style.width = (newOffset * cellW) + 'px';
                        };
                        const onUp = () => {
                            this._blockSliding = false;
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.removeEventListener('pointercancel', onUp);
                            this._timelineDirty = true;
                            this.renderTimeline();
                        };
                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        document.addEventListener('pointercancel', onUp);
                    });
                    
                    // Populate only visible frames (virtualized)
                    this._populateBlockFrames(blockWrap);
                    
                    row.appendChild(blockWrap);
                    
                    // Add frame button (only on active layer)
                    if (isActive) {
                        const addFrameDiv = document.createElement('div');
                        addFrameDiv.className = 'add-frame';
                        addFrameDiv.textContent = '+';
                        addFrameDiv.title = 'Add new frame';
                        addFrameDiv.addEventListener('click', () => this.insertFrameAfterCurrent());
                        row.appendChild(addFrameDiv);
                    }
                    
                    // Append drop indicator to active layer row
                    if (isActive && this._dropIndicator) {
                        row.style.position = 'relative';
                        row.appendChild(this._dropIndicator);
                    }
                    
                    containerFrag.appendChild(row);
                });
                
                // Flush fragments to DOM in one batch (minimizes reflow)
                layersList.appendChild(labelsFrag);
                container.appendChild(containerFrag);
                
                // Restore scroll position preserved before rebuild
                if (framesSection && savedScrollLeft > 0) {
                    framesSection.scrollLeft = savedScrollLeft;
                }
                
                // Re-populate all virtualized blocks with correct scroll position
                // (initial _populateBlockFrames ran before scrollLeft was restored)
                this._updateVisibleFrames();
                
                // Set up document-level drag handlers (only once)
                if (!this._frameDragBound) {
                    this._frameDragBound = true;
                    
                    this._dragGhost = document.createElement('div');
                    this._dragGhost.className = 'frame-drag-ghost';
                    this._dragGhost.style.display = 'none';
                    document.body.appendChild(this._dragGhost);
                    
                    this._dropIndicator = document.createElement('div');
                    this._dropIndicator.className = 'frame-drop-indicator';
                    this._dropIndicator.style.display = 'none';
                    
                    document.addEventListener('pointermove', (e) => {
                        // Handle hold block drag
                        if (this._holdBlockDragState) {
                            const state = this._holdBlockDragState;
                            const dx = e.clientX - state.startX;
                            const dy = e.clientY - state.startY;
                            
                            if (!state.started && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                                state.started = true;
                                state.element.classList.add('dragging');
                                const ghost = this._dragGhost;
                                ghost.innerHTML = '';
                                const gm = this.getTimelineMetrics();
                                const ghostW = Math.min(state.holdLength * gm.cellW, gm.frameW * 3);
                                ghost.style.width = ghostW + 'px';
                                ghost.style.height = gm.frameW + 'px';
                                ghost.style.background = '#2b2d31';
                                ghost.style.position = 'relative';
                                ghost.style.display = 'block';
                            }
                            
                            if (state.started) {
                                e.preventDefault();
                                this._dragGhost.style.left = e.clientX + 'px';
                                this._dragGhost.style.top = e.clientY + 'px';
                                
                                // Show drop indicator
                                const activeRow = container.querySelector('.layer-frames-row.active-row');
                                if (activeRow) {
                                    const allElements = activeRow.querySelectorAll('.frame, .hold-block');
                                    const containerRect = activeRow.getBoundingClientRect();
                                    let bestInsert = null;
                                    let bestDist = Infinity;
                                    
                                    for (const el of allElements) {
                                        const rect = el.getBoundingClientRect();
                                        const idx = parseInt(el.dataset.frameIndex);
                                        const leftDist = Math.abs(e.clientX - rect.left);
                                        if (leftDist < bestDist) {
                                            bestDist = leftDist;
                                            bestInsert = { idx, side: 'left', x: rect.left - containerRect.left };
                                        }
                                        const rightDist = Math.abs(e.clientX - rect.right);
                                        if (rightDist < bestDist) {
                                            bestDist = rightDist;
                                            const endIdx = el.classList.contains('hold-block') 
                                                ? idx + parseInt(el.dataset.holdLength) - 1 : idx;
                                            bestInsert = { idx: endIdx, side: 'right', x: rect.right - containerRect.left };
                                        }
                                    }
                                    
                                    if (bestInsert) {
                                        const insertIdx = bestInsert.side === 'right' ? bestInsert.idx + 1 : bestInsert.idx;
                                        const holdEnd = state.holdStart + state.holdLength;
                                        // Don't show indicator if dropping in same spot
                                        if (insertIdx >= state.holdStart && insertIdx <= holdEnd) {
                                            this._dropIndicator.style.display = 'none';
                                            state.insertIdx = undefined;
                                        } else {
                                            this._dropIndicator.style.display = 'block';
                                            this._dropIndicator.style.left = (bestInsert.x - 1) + 'px';
                                            state.insertIdx = insertIdx;
                                        }
                                    }
                                }
                            }
                            return;
                        }
                        
                        if (!this._frameDragState) return;
                        const state = this._frameDragState;
                        const dx = e.clientX - state.startX;
                        const dy = e.clientY - state.startY;
                        
                        if (!state.started && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                            state.started = true;
                            state.element.classList.add('dragging');
                            const ghost = this._dragGhost;
                            ghost.innerHTML = '';
                            const gm = this.getTimelineMetrics();
                            
                            if (state.multi) {
                                // Multi-drag ghost: show stacked frames with count badge
                                const count = state.indices.length;
                                const ghostW = Math.min(count, 3) * gm.cellW + 4;
                                ghost.style.width = Math.max(ghostW, gm.frameW) + 'px';
                                ghost.style.height = gm.frameW + 'px';
                                ghost.style.background = '#2b2d31';
                                ghost.style.position = 'relative';
                                const badge = document.createElement('div');
                                badge.className = 'drag-count-badge';
                                badge.textContent = count;
                                ghost.appendChild(badge);
                            } else {
                                ghost.style.width = gm.frameW + 'px';
                                ghost.style.height = gm.frameW + 'px';
                                ghost.style.background = '#2b2d31';
                                ghost.style.position = 'relative';
                                const indicator = state.element.querySelector('.frame-indicator');
                                if (indicator) {
                                    ghost.appendChild(indicator.cloneNode(true));
                                }
                            }
                            ghost.style.display = 'block';
                        }
                        
                        if (!state.started) return;
                        e.preventDefault();
                        
                        this._dragGhost.style.left = e.clientX + 'px';
                        this._dragGhost.style.top = e.clientY + 'px';
                        
                        // Find active layer row for drop indicator
                        const activeRow = container.querySelector('.layer-frames-row.active-row');
                        if (!activeRow) return;
                        const frames = activeRow.querySelectorAll('.frame, .hold-block');
                        const containerRect = activeRow.getBoundingClientRect();
                        let bestInsert = null;
                        let bestDist = Infinity;
                        
                        for (const frame of frames) {
                            const rect = frame.getBoundingClientRect();
                            const idx = parseInt(frame.dataset.frameIndex);
                            const leftDist = Math.abs(e.clientX - rect.left);
                            if (leftDist < bestDist) {
                                bestDist = leftDist;
                                bestInsert = { idx, side: 'left', x: rect.left - containerRect.left };
                            }
                            const rightDist = Math.abs(e.clientX - rect.right);
                            if (rightDist < bestDist) {
                                bestDist = rightDist;
                                const endIdx = frame.classList.contains('hold-block')
                                    ? idx + parseInt(frame.dataset.holdLength) - 1 : idx;
                                bestInsert = { idx: endIdx, side: 'right', x: rect.right - containerRect.left };
                            }
                        }
                        
                        if (bestInsert) {
                            const insertIdx = bestInsert.side === 'right' ? bestInsert.idx + 1 : bestInsert.idx;
                            
                            // Check if drop is a no-op (within the dragged range)
                            let isNoOp = false;
                            if (state.multi) {
                                const sorted = state.indices;
                                const min = sorted[0];
                                const max = sorted[sorted.length - 1];
                                // If indices are contiguous, suppress indicator within range
                                if (max - min + 1 === sorted.length) {
                                    isNoOp = insertIdx >= min && insertIdx <= max + 1;
                                }
                            } else {
                                isNoOp = insertIdx === state.index || insertIdx === state.index + 1;
                            }
                            
                            if (isNoOp) {
                                this._dropIndicator.style.display = 'none';
                                state.insertIdx = undefined;
                            } else {
                                this._dropIndicator.style.display = 'block';
                                this._dropIndicator.style.left = (bestInsert.x - 1) + 'px';
                                state.insertIdx = insertIdx;
                            }
                        }
                    });
                    
                    document.addEventListener('pointerup', (e) => {
                        // Handle hold block drag finalize
                        if (this._holdBlockDragState) {
                            const state = this._holdBlockDragState;
                            state.element.classList.remove('dragging');
                            this._dragGhost.style.display = 'none';
                            this._dropIndicator.style.display = 'none';
                            
                            if (state.started && state.insertIdx !== undefined) {
                                this._moveHoldBlock(state.holdStart, state.holdLength, state.insertIdx);
                            }
                            
                            this._holdBlockDragState = null;
                            return;
                        }
                        
                        if (!this._frameDragState) return;
                        const state = this._frameDragState;
                        state.element.classList.remove('dragging');
                        this._dragGhost.style.display = 'none';
                        this._dropIndicator.style.display = 'none';
                        
                        if (state.started && state.insertIdx !== undefined) {
                            if (state.multi) {
                                this._moveMultiFrames(state.indices, state.insertIdx);
                            } else {
                                const target = state.insertIdx > state.index ? state.insertIdx - 1 : state.insertIdx;
                                if (target !== state.index) {
                                    this.reorderFrames(state.index, target);
                                }
                            }
                        } else if (!state.started) {
                            if (!state.multi) {
                                this.commitSelection();
                                this.currentFrameIndex = state.index;
                                this.initializeFrame();
                                this.render();
                                this.scrubAudio(this.getPlayheadPosition());
                            }
                            // Multi no-drag click: keep selection, do nothing extra
                        }
                        
                        this._frameDragState = null;
                    });
                    
                    // === DELEGATED FRAME EVENT HANDLERS (set up once) ===
                    // Instead of per-frame listeners, one listener on the container handles all frames
                    container.addEventListener('pointerdown', (e) => {
                        // Handle single frame extend handle drag
                        const extendHandle = e.target.closest('.frame-extend-handle');
                        if (extendHandle) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._startFrameExtend(extendHandle, e);
                            return;
                        }
                        
                        // Handle hold block resize handle drag
                        const resizeHandle = e.target.closest('.hold-block-handle');
                        if (resizeHandle) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._startHoldResize(resizeHandle, e);
                            return;
                        }
                        
                        // Check for hold-block or frame click
                        const holdBlock = e.target.closest('.hold-block');
                        const frameDiv = holdBlock || e.target.closest('.frame');
                        if (!frameDiv) {
                            // Clicked empty timeline area â€” clear selection
                            if (this.selectedFrames.size > 0) {
                                this.selectedFrames.clear();
                                this._timelineDirty = true;
                                this._scheduleRenderTimeline();
                            }
                            return;
                        }
                        if (e.button && e.button !== 0) return;
                        e.preventDefault();
                        
                        let frameIdx;
                        const layerId = parseInt(frameDiv.dataset.layerId, 10);
                        let timelinePos;
                        
                        if (holdBlock) {
                            // Calculate which frame within the hold block was clicked
                            const holdStart = parseInt(holdBlock.dataset.holdStart, 10);
                            const holdLength = parseInt(holdBlock.dataset.holdLength, 10);
                            const blockRect = holdBlock.getBoundingClientRect();
                            const { cellW } = this.getTimelineMetrics();
                            const relX = e.clientX - blockRect.left;
                            frameIdx = holdStart + Math.min(Math.floor(relX / cellW), holdLength - 1);
                            const offset = this.layers.find(l => l.id === layerId)?.startFrame || 0;
                            timelinePos = offset + frameIdx;
                        } else {
                            frameIdx = parseInt(frameDiv.dataset.frameIndex, 10);
                            timelinePos = parseInt(frameDiv.dataset.timelinePos, 10);
                        }
                        
                        // === Selection mode: tap toggles frames ===
                        if (this.frameSelectMode && layerId === this.currentLayerId) {
                            if (holdBlock) {
                                // Toggle entire hold block
                                const holdStart = parseInt(holdBlock.dataset.holdStart, 10);
                                const holdLength = parseInt(holdBlock.dataset.holdLength, 10);
                                const allSelected = Array.from({length: holdLength}, (_, k) => holdStart + k)
                                    .every(fi => this.selectedFrames.has(fi));
                                for (let fi = holdStart; fi < holdStart + holdLength; fi++) {
                                    if (allSelected) this.selectedFrames.delete(fi);
                                    else this.selectedFrames.add(fi);
                                }
                            } else {
                                if (this.selectedFrames.has(frameIdx)) {
                                    this.selectedFrames.delete(frameIdx);
                                } else {
                                    this.selectedFrames.add(frameIdx);
                                }
                            }
                            this._updateSelectBanner();
                            this._timelineDirty = true;
                            this.renderTimeline();
                            return;
                        }
                        
                        // If clicking a non-active layer, switch to it
                        if (layerId !== this.currentLayerId) {
                            if (this.selection) { this._dismissTransform(); }
                            else { this.commitSelection(); }
                            this.currentLayerId = layerId;
                            this.audioLayerSelected = false;
                            this.selectedFrames.clear();
                            this._timelineDirty = true;
                            this.currentFrameIndex = frameIdx;
                            this.initializeFrame();
                            this.render();
                            this.scrubAudio(timelinePos);
                            // Force synchronous timeline rebuild (RAF may miss it)
                            this.renderTimeline();
                            return;
                        }
                        
                        // Shift+click: range select
                        if (e.shiftKey) {
                            let selFrom = frameIdx;
                            let selTo = frameIdx;
                            
                            // If shift-clicking a hold block, expand to include entire block
                            if (holdBlock) {
                                const holdStart = parseInt(holdBlock.dataset.holdStart, 10);
                                const holdLength = parseInt(holdBlock.dataset.holdLength, 10);
                                selFrom = holdStart;
                                selTo = holdStart + holdLength - 1;
                            }
                            
                            const from = Math.min(this.currentFrameIndex, selFrom);
                            const to = Math.max(this.currentFrameIndex, selTo);
                            this.selectedFrames.clear();
                            for (let si = from; si <= to; si++) {
                                this.selectedFrames.add(si);
                            }
                            this._timelineDirty = true;
                            this.renderTimeline();
                            return;
                        }
                        
                        // If clicking a frame that's already in a multi-selection, start multi-drag
                        if (this.selectedFrames.size > 1 && this.selectedFrames.has(frameIdx)) {
                            this._frameDragState = {
                                index: frameIdx,
                                startX: e.clientX,
                                startY: e.clientY,
                                started: false,
                                element: frameDiv,
                                layerId: layerId,
                                multi: true,
                                indices: [...this.selectedFrames].sort((a, b) => a - b)
                            };
                            return;
                        }
                        
                        // Clicking a hold block: auto-select entire hold group
                        if (holdBlock) {
                            const holdStart = parseInt(holdBlock.dataset.holdStart, 10);
                            const holdLength = parseInt(holdBlock.dataset.holdLength, 10);
                            this.selectedFrames.clear();
                            for (let i = holdStart; i < holdStart + holdLength; i++) {
                                this.selectedFrames.add(i);
                            }
                            if (this.selection) { this._dismissTransform(); }
                            this.currentFrameIndex = frameIdx;
                            this.initializeFrame();
                            this.render();
                            this.scrubAudio(this.getPlayheadPosition());
                            this._timelineDirty = true;
                            this.renderTimeline();
                            // Re-query element after rebuild (old reference is destroyed)
                            const freshEl = container.querySelector(
                                `.hold-block[data-hold-start="${holdStart}"][data-layer-id="${layerId}"]`
                            ) || holdBlock;
                            // Set up multi-drag for the hold group
                            this._frameDragState = {
                                index: holdStart,
                                startX: e.clientX,
                                startY: e.clientY,
                                started: false,
                                element: freshEl,
                                layerId: layerId,
                                multi: true,
                                indices: [...this.selectedFrames].sort((a, b) => a - b)
                            };
                            return;
                        }
                        
                        // Regular click on non-selected frame: clear multi-select
                        if (this.selectedFrames.size > 0) {
                            this.selectedFrames.clear();
                            this._timelineDirty = true;
                        }
                        
                        // --- Long-press detection for touch ---
                        const lpStartX = e.clientX;
                        const lpStartY = e.clientY;
                        
                        if (this._longPressTimer) {
                            clearTimeout(this._longPressTimer);
                            this._longPressTimer = null;
                        }
                        
                        this._longPressTimer = setTimeout(() => {
                            this._longPressTimer = null;
                            this.currentFrameIndex = frameIdx;
                            this.enterFrameSelectMode(frameIdx);
                        }, 400);
                        
                        const lpMoveCancel = (ev) => {
                            if (Math.abs(ev.clientX - lpStartX) > 8 || Math.abs(ev.clientY - lpStartY) > 8) {
                                if (this._longPressTimer) {
                                    clearTimeout(this._longPressTimer);
                                    this._longPressTimer = null;
                                }
                                document.removeEventListener('pointermove', lpMoveCancel);
                            }
                        };
                        const lpUpCancel = () => {
                            if (this._longPressTimer) {
                                clearTimeout(this._longPressTimer);
                                this._longPressTimer = null;
                            }
                            document.removeEventListener('pointermove', lpMoveCancel);
                            document.removeEventListener('pointerup', lpUpCancel);
                            document.removeEventListener('pointercancel', lpUpCancel);
                        };
                        document.addEventListener('pointermove', lpMoveCancel);
                        document.addEventListener('pointerup', lpUpCancel);
                        document.addEventListener('pointercancel', lpUpCancel);
                        
                        // Active layer: navigate to local frame
                        if (frameIdx !== this.currentFrameIndex) {
                            if (this.selection) {
                                this._dismissTransform();
                            }
                            this.currentFrameIndex = frameIdx;
                            this.initializeFrame();
                            this.render();
                            this.scrubAudio(this.getPlayheadPosition());
                            // If timeline was dirtied (e.g. selection cleared), rebuild now
                            if (this._timelineDirty) {
                                this.renderTimeline();
                            }
                            return;
                        }
                        
                        // Same frame: support drag reorder
                        this._frameDragState = {
                            index: frameIdx,
                            startX: e.clientX,
                            startY: e.clientY,
                            started: false,
                            element: frameDiv,
                            layerId: layerId
                        };
                    });
                    
                    // Delegated context menu handler
                    container.addEventListener('contextmenu', (e) => {
                        const holdBlock = e.target.closest('.hold-block');
                        const frameDiv = holdBlock || e.target.closest('.frame');
                        if (!frameDiv) return;
                        e.preventDefault();
                        e.stopPropagation();
                        
                        let frameIdx;
                        const layerId = parseInt(frameDiv.dataset.layerId, 10);
                        
                        if (holdBlock) {
                            const holdStart = parseInt(holdBlock.dataset.holdStart, 10);
                            const holdLength = parseInt(holdBlock.dataset.holdLength, 10);
                            const blockRect = holdBlock.getBoundingClientRect();
                            const { cellW } = this.getTimelineMetrics();
                            const relX = e.clientX - blockRect.left;
                            frameIdx = holdStart + Math.min(Math.floor(relX / cellW), holdLength - 1);
                        } else {
                            frameIdx = parseInt(frameDiv.dataset.frameIndex, 10);
                        }
                        const layerRef = this.layers.find(l => l.id === layerId);
                        if (!layerRef) return;
                        
                        if (layerId !== this.currentLayerId) {
                            if (this.selection) { this._dismissTransform(); }
                            else { this.commitSelection(); }
                            this.currentLayerId = layerId;
                            this.audioLayerSelected = false;
                            this.currentFrameIndex = frameIdx;
                            this.initializeFrame();
                        }
                        this.contextMenuFrameIndex = frameIdx;
                        
                        const ctxMenu = document.getElementById('frameContextMenu');
                        const pasteItem = document.getElementById('ctxPasteFrame');
                        if (this.copiedFrame || this.copiedFrames.length > 0) {
                            pasteItem.classList.remove('disabled');
                        } else {
                            pasteItem.classList.add('disabled');
                        }
                        const releaseItem = document.getElementById('ctxReleaseHold');
                        if (this.isHoldFrame(layerRef, frameIdx)) {
                            releaseItem.style.display = '';
                        } else {
                            releaseItem.style.display = 'none';
                        }
                        ctxMenu.style.left = e.clientX + 'px';
                        ctxMenu.style.top = e.clientY + 'px';
                        ctxMenu.classList.add('show');
                        const menuRect = ctxMenu.getBoundingClientRect();
                        if (menuRect.right > window.innerWidth) ctxMenu.style.left = (e.clientX - menuRect.width) + 'px';
                        if (menuRect.bottom > window.innerHeight) ctxMenu.style.top = (e.clientY - menuRect.height) + 'px';
                    });
                }
                
                // Sync audio waveforms
                if (this.audioTracks.length) {
                    this.renderAudioWaveform();
                    this.syncAudioLabelWidth();
                }
                
                // Render scrub ruler (use max frame count across all layers)
                this.renderScrubRuler();
                this.updatePlayheadPosition();
                
                // Sync vertical scroll between labels and frames
                this._syncVerticalScroll();
                
                // Sync heights between labels and frame rows
                requestAnimationFrame(() => {
                    const labels = document.querySelectorAll('#layersList .tl-label');
                    const rows = document.querySelectorAll('#framesContainer .layer-frames-row');
                    labels.forEach((lbl, i) => {
                        if (rows[i]) {
                            const h = lbl.offsetHeight;
                            rows[i].style.minHeight = h + 'px';
                            lbl.style.minHeight = h + 'px';
                        }
                    });
                });
                
                // Update curve editor if active
                if (this._curveEditorActive) {
                    this.renderCurveEditor();
                }
                
                // Set up scroll-based virtualization handler (once)
                if (!this._tlScrollBound) {
                    this._tlScrollBound = true;
                    const scrollEl = document.getElementById('timelineFramesSection');
                    let scrollRaf = null;
                    scrollEl.addEventListener('scroll', () => {
                        if (scrollRaf) return;
                        scrollRaf = requestAnimationFrame(() => {
                            scrollRaf = null;
                            this._updateVisibleFrames();
                        });
                    }, { passive: true });
                }
            }
            
            // Create a single frame element for the virtualized timeline (non-hold frames only)
            _createFrameEl(i, v) {
                const timelinePos = v.offset + i;
                const frameDiv = document.createElement('div');
                let cls = 'frame';
                if (v.isActive && timelinePos === v.playheadPos) cls += ' active';
                if (v.isActive && this.selectedFrames.has(i)) cls += ' selected';
                frameDiv.className = cls;
                frameDiv.dataset.frameIndex = i;
                frameDiv.dataset.timelinePos = timelinePos;
                frameDiv.dataset.layerId = v.layer.id;
                
                // Absolute positioning within blockWrap
                frameDiv.style.position = 'absolute';
                frameDiv.style.left = (i * v.cellW + 2) + 'px'; // +2 for blockWrap padding
                frameDiv.style.top = '0';
                
                // Thumbnail wrapper
                const thumb = document.createElement('div');
                thumb.className = 'frame-thumb';
                
                // Keyframe diamond
                if (v.keyframeSet.has(i)) {
                    const diamond = document.createElement('div');
                    diamond.className = 'keyframe-diamond';
                    diamond.style.left = 'calc(50% - 3.5px)';
                    thumb.appendChild(diamond);
                }
                
                // Content indicator
                if (v.layer.frames[i]) {
                    const frame = v.layer.frames[i];
                    const hasContent = this._frameHasContent(frame);
                    if (hasContent) {
                        const indicator = document.createElement('div');
                        indicator.className = 'frame-indicator circle';
                        thumb.appendChild(indicator);
                    }
                }
                
                frameDiv.appendChild(thumb);
                
                // Right-edge drag handle to extend into hold frame
                if (v.layer.frames[i] && v.isActive) {
                    const extHandle = document.createElement('div');
                    extHandle.className = 'frame-extend-handle';
                    extHandle.dataset.frameIndex = i;
                    extHandle.dataset.layerId = v.layer.id;
                    thumb.appendChild(extHandle);
                }
                
                const frameNumber = document.createElement('div');
                frameNumber.className = 'frame-number';
                frameNumber.textContent = timelinePos + 1;
                frameDiv.appendChild(frameNumber);
                
                return frameDiv;
            }
            
            // Create a hold block element spanning multiple contiguous held frames
            _createHoldBlockEl(seg, v) {
                const { startIndex, length, color } = seg;
                const timelinePos = v.offset + startIndex;
                const totalWidth = length * v.cellW - v.gap;
                
                const block = document.createElement('div');
                block.className = 'hold-block';
                block.dataset.frameIndex = startIndex;
                block.dataset.holdStart = startIndex;
                block.dataset.holdLength = length;
                block.dataset.timelinePos = timelinePos;
                block.dataset.layerId = v.layer.id;
                
                block.style.left = (startIndex * v.cellW + 2) + 'px';
                block.style.top = '0';
                block.style.width = totalWidth + 'px';
                
                // Check if playhead is within this block
                const playheadLocal = v.playheadPos - v.offset;
                const hasActive = v.isActive && playheadLocal >= startIndex && playheadLocal < startIndex + length;
                if (hasActive) block.classList.add('has-active');
                
                // Check if hold block is selected (any frame in range is selected)
                if (v.isActive) {
                    let anySelected = false;
                    for (let si = startIndex; si < startIndex + length; si++) {
                        if (this.selectedFrames.has(si)) { anySelected = true; break; }
                    }
                    if (anySelected) block.classList.add('selected');
                }                
                // Bar container
                const bar = document.createElement('div');
                bar.className = 'hold-block-bar';
                
                // Source cell (left side â€” full frame-thumb size)
                const source = document.createElement('div');
                const sourceIsActive = hasActive && playheadLocal === startIndex;
                source.className = 'hold-block-source' + (sourceIsActive ? ' source-active' : '');
                
                // Content indicator in source
                const frame = v.layer.frames[startIndex];
                if (frame && this._frameHasContent(frame)) {
                    const indicator = document.createElement('div');
                    indicator.className = 'frame-indicator circle';
                    if (v.isActive && hasActive) indicator.style.background = '#5b8def';
                    source.appendChild(indicator);
                }
                
                // Keyframe diamond on source
                if (v.keyframeSet.has(startIndex)) {
                    const diamond = document.createElement('div');
                    diamond.className = 'keyframe-diamond';
                    diamond.style.left = 'calc(50% - 3.5px)';
                    source.appendChild(diamond);
                }
                
                // Connecting bar inside source cell (right half, reaching to edge)
                if (length > 1) {
                    const srcConn = document.createElement('div');
                    srcConn.className = 'hold-block-source-connector';
                    srcConn.style.background = color;
                    source.appendChild(srcConn);
                }
                
                bar.appendChild(source);
                
                // Tail (extending bar for held frames)
                if (length > 1) {
                    const tail = document.createElement('div');
                    tail.className = 'hold-block-tail';
                    
                    // Connecting rectangle through center
                    const connector = document.createElement('div');
                    connector.className = 'hold-block-connector';
                    connector.style.background = color;
                    tail.appendChild(connector);
                    
                    // Tick marks at frame divisions
                    const ticks = document.createElement('div');
                    ticks.className = 'hold-block-tail-ticks';
                    for (let t = 0; t < length - 2; t++) {
                        const tick = document.createElement('div');
                        tick.className = 'hold-block-tick';
                        tick.style.width = v.cellW + 'px';
                        // Keyframe diamond on interior hold frames
                        const interiorIdx = startIndex + 1 + t;
                        if (v.keyframeSet.has(interiorIdx)) {
                            const diamond = document.createElement('div');
                            diamond.className = 'keyframe-diamond';
                            diamond.style.left = 'calc(50% - 3.5px)';
                            tick.appendChild(diamond);
                        }
                        ticks.appendChild(tick);
                    }
                    tail.appendChild(ticks);
                    
                    bar.appendChild(tail);
                    
                    // Resize handle on right edge
                    const handle = document.createElement('div');
                    handle.className = 'hold-block-handle';
                    handle.dataset.holdStart = startIndex;
                    handle.dataset.holdLength = length;
                    handle.dataset.layerId = v.layer.id;
                    bar.appendChild(handle);
                    
                    // Keyframe diamond on last frame of hold block
                    const lastIdx = startIndex + length - 1;
                    if (v.keyframeSet.has(lastIdx)) {
                        const diamond = document.createElement('div');
                        diamond.className = 'keyframe-diamond';
                        // Position at the last frame's center within the bar
                        diamond.style.left = ((lastIdx - startIndex) * v.cellW + v.frameW / 2 - 3.5) + 'px';
                        bar.appendChild(diamond);
                    }
                }
                
                // Playhead marker within block
                if (hasActive) {
                    const ph = document.createElement('div');
                    ph.className = 'hold-block-playhead';
                    const phOffset = (playheadLocal - startIndex) * v.cellW;
                    ph.style.left = phOffset + 'px';
                    ph.style.width = v.frameW + 'px';
                    bar.appendChild(ph);
                }
                
                // Selection overlays within block
                if (v.isActive && this.selectedFrames.size > 0) {
                    // Find contiguous runs of selected frames within this block
                    let runStart = null;
                    for (let fi = startIndex; fi <= startIndex + length; fi++) {
                        const isSel = fi < startIndex + length && this.selectedFrames.has(fi);
                        if (isSel && runStart === null) {
                            runStart = fi;
                        } else if (!isSel && runStart !== null) {
                            // Emit selection overlay for run [runStart, fi)
                            const sel = document.createElement('div');
                            sel.className = 'hold-block-selection';
                            sel.style.left = ((runStart - startIndex) * v.cellW) + 'px';
                            sel.style.width = ((fi - runStart) * v.cellW) + 'px';
                            bar.appendChild(sel);
                            runStart = null;
                        }
                    }
                }
                
                block.appendChild(bar);
                
                // Frame number
                const num = document.createElement('div');
                num.className = 'frame-number';
                num.textContent = `${timelinePos + 1}â€“${timelinePos + length}`;
                block.appendChild(num);
                
                return block;
            }
            
            // Populate visible frame elements in a virtualized blockWrap
            _populateBlockFrames(blockWrap) {
                const v = blockWrap._virt;
                if (!v) return;
                
                const scrollEl = document.getElementById('timelineFramesSection');
                const scrollLeft = scrollEl.scrollLeft;
                const viewportWidth = scrollEl.clientWidth || 800; // fallback before layout
                
                // Approximate blockWrap offset in scroll container
                const blockOffset = 10 + (v.offset * v.cellW) + 4; // row padding + spacer + border/padding
                
                const BUFFER = 10;
                const startIdx = Math.max(0, Math.floor((scrollLeft - blockOffset) / v.cellW) - BUFFER);
                const endIdx = Math.min(v.layerLocalMax, Math.ceil((scrollLeft - blockOffset + viewportWidth) / v.cellW) + BUFFER);
                
                // Check if range changed
                const prevRange = v.renderedRange;
                if (prevRange && prevRange[0] === startIdx && prevRange[1] === endIdx) return;
                v.renderedRange = [startIdx, endIdx];
                
                const { frameMap } = v.holdSegData;
                
                // Remove out-of-range elements (both .frame and .hold-block)
                const existing = blockWrap.querySelectorAll('.frame, .hold-block');
                for (const el of existing) {
                    const idx = parseInt(el.dataset.frameIndex);
                    if (el.classList.contains('hold-block')) {
                        const hEnd = idx + parseInt(el.dataset.holdLength);
                        // Remove if entire block is out of range
                        if (hEnd <= startIdx || idx >= endIdx) el.remove();
                    } else {
                        if (idx < startIdx || idx >= endIdx) el.remove();
                    }
                }
                
                // Collect already-rendered indices
                const rendered = new Set();
                blockWrap.querySelectorAll('.frame').forEach(el => rendered.add(parseInt(el.dataset.frameIndex)));
                // Hold blocks cover a range of indices
                blockWrap.querySelectorAll('.hold-block').forEach(el => {
                    const hs = parseInt(el.dataset.holdStart);
                    const hl = parseInt(el.dataset.holdLength);
                    for (let hi = hs; hi < hs + hl; hi++) rendered.add(hi);
                });
                
                // Create missing frame elements
                const frag = document.createDocumentFragment();
                let i = startIdx;
                while (i < endIdx) {
                    if (rendered.has(i)) { i++; continue; }
                    
                    const seg = frameMap.get(i);
                    if (seg) {
                        if (i === seg.startIndex) {
                            // Start of a hold block â€” create the full block
                            frag.appendChild(this._createHoldBlockEl(seg, v));
                            // Mark all indices in this segment as rendered
                            for (let hi = seg.startIndex; hi < seg.startIndex + seg.length; hi++) {
                                rendered.add(hi);
                            }
                            i = seg.startIndex + seg.length;
                        } else {
                            // Interior of a hold block â€” check if its start needs rendering
                            if (!rendered.has(seg.startIndex) && seg.startIndex >= startIdx - seg.length) {
                                frag.appendChild(this._createHoldBlockEl(seg, v));
                                for (let hi = seg.startIndex; hi < seg.startIndex + seg.length; hi++) {
                                    rendered.add(hi);
                                }
                            }
                            i++;
                        }
                    } else {
                        // Normal single frame
                        frag.appendChild(this._createFrameEl(i, v));
                        rendered.add(i);
                        i++;
                    }
                }
                blockWrap.appendChild(frag);
            }
            
            // Update all visible frames across all virtualized blockWraps (called on scroll)
            _updateVisibleFrames() {
                const blocks = document.querySelectorAll('.frame-block');
                for (const blockWrap of blocks) {
                    if (blockWrap._virt) this._populateBlockFrames(blockWrap);
                }
            }
            
            renderScrubRuler() {
                const rulerOuter = document.getElementById('scrubRulerInner');
                
                const numFrames = this._maxFrameCount || this.getTimelineLength();
                const { cellW, padding } = this.getTimelineMetrics();
                const totalWidth = padding + numFrames * cellW + 40;
                rulerOuter.style.width = totalWidth + 'px';
                
                // Use a canvas instead of DOM elements for performance
                let canvas = rulerOuter.querySelector('canvas');
                if (!canvas) {
                    rulerOuter.innerHTML = '';
                    canvas = document.createElement('canvas');
                    canvas.style.display = 'block';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    rulerOuter.appendChild(canvas);
                }
                
                const dpr = window.devicePixelRatio || 1;
                canvas.width = Math.ceil(totalWidth * dpr);
                canvas.height = Math.ceil(32 * dpr);
                canvas.style.width = totalWidth + 'px';
                canvas.style.height = '32px';
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, totalWidth, 32);
                
                // Adapt label frequency to zoom level
                const labelEvery = cellW < 30 ? 10 : cellW < 50 ? 5 : cellW < 70 ? 2 : 1;
                
                ctx.strokeStyle = '#555';
                ctx.fillStyle = '#888';
                ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                
                for (let i = 0; i < numFrames; i++) {
                    const x = padding + i * cellW + cellW / 2;
                    
                    // Tick line
                    ctx.beginPath();
                    ctx.moveTo(x, 22);
                    ctx.lineTo(x, 30);
                    ctx.stroke();
                    
                    // Label
                    if (i === 0 || (i + 1) % labelEvery === 0) {
                        ctx.fillText(String(i + 1), x, 16);
                    }
                }
            }
            
            getTimelineMetrics() {
                const s = this.timelineScale;
                const frameW = Math.round(80 * s);
                const gap = 5;
                const cellW = frameW + gap;
                const thumbH = Math.round(60 * s);
                const padding = 10;
                return { frameW, thumbH, gap, cellW, padding };
            }
            
            // Scroll the timeline so a specific frame index is visible
            _scrollTimelineToFrame(frameIdx) {
                // Defer to next frame to ensure timeline DOM has been rebuilt
                requestAnimationFrame(() => {
                    const framesSection = document.getElementById('timelineFramesSection');
                    if (!framesSection) return;
                    
                    const layer = this.getCurrentLayer();
                    const offset = layer.startFrame || 0;
                    const { cellW, padding } = this.getTimelineMetrics();
                    const x = padding + (offset + frameIdx) * cellW;
                    const viewW = framesSection.clientWidth;
                    const margin = cellW * 2;
                    
                    if (x + cellW > framesSection.scrollLeft + viewW - margin) {
                        framesSection.scrollLeft = x - viewW + margin + cellW;
                    } else if (x < framesSection.scrollLeft + margin) {
                        framesSection.scrollLeft = Math.max(0, x - margin);
                    }
                });
            }
            
            applyTimelineScale() {
                const { frameW } = this.getTimelineMetrics();
                document.documentElement.style.setProperty('--frame-w', frameW + 'px');
                this._timelineDirty = true;
                this.renderTimeline();
            }
            
            timelineZoomIn() {
                this.timelineScale = Math.min(3.0, this.timelineScale * 1.3);
                this.applyTimelineScale();
            }
            
            timelineZoomOut() {
                this.timelineScale = Math.max(0.2, this.timelineScale / 1.3);
                this.applyTimelineScale();
            }
            
            timelineZoomFit() {
                const numFrames = this._maxFrameCount || this.getTimelineLength();
                if (numFrames === 0) return;
                
                const framesSection = document.getElementById('timelineFramesSection');
                const availW = framesSection.clientWidth - 20; // padding
                const gap = 5;
                // Solve: numFrames * (frameW + gap) <= availW
                const frameW = Math.max(20, Math.floor((availW - gap * numFrames) / numFrames));
                this.timelineScale = frameW / 80;
                this.applyTimelineScale();
                // Scroll to start
                framesSection.scrollLeft = 0;
            }
            
            updatePlayheadPosition() {
                const playhead = document.getElementById('timelinePlayhead');
                const framesSection = document.getElementById('timelineFramesSection');
                
                const { cellW, padding } = this.getTimelineMetrics();
                const timelinePos = this.getPlayheadPosition();
                const x = padding + timelinePos * cellW + cellW / 2;
                
                // Auto-scroll timeline to keep playhead visible (only during playback)
                if (this.isPlaying) {
                    const viewW = framesSection.clientWidth;
                    const margin = viewW * 0.25;
                    if (x > framesSection.scrollLeft + viewW - margin) {
                        framesSection.scrollLeft = x - margin;
                    } else if (x < framesSection.scrollLeft + margin) {
                        framesSection.scrollLeft = Math.max(0, x - margin);
                    }
                }
                
                const visibleX = x - framesSection.scrollLeft;
                playhead.style.left = visibleX + 'px';
                playhead.classList.add('visible');
            }
            
            scrollPlayheadIntoView() {
                const framesSection = document.getElementById('timelineFramesSection');
                const { cellW, padding } = this.getTimelineMetrics();
                const timelinePos = this.getPlayheadPosition();
                const x = padding + timelinePos * cellW + cellW / 2;
                const viewW = framesSection.clientWidth;
                const margin = viewW * 0.25;
                
                if (x > framesSection.scrollLeft + viewW - margin) {
                    framesSection.scrollLeft = x - margin;
                }
                else if (x < framesSection.scrollLeft + margin) {
                    framesSection.scrollLeft = Math.max(0, x - margin);
                }
            }
            
            _syncVerticalScroll() {
                const framesSection = document.getElementById('timelineFramesSection');
                const layersList = document.getElementById('layersList');
                if (!framesSection || !layersList) return;
                
                // Remove old listeners if any
                if (this._vertScrollHandler) {
                    framesSection.removeEventListener('scroll', this._vertScrollHandler);
                    layersList.removeEventListener('scroll', this._vertScrollLabelHandler);
                }
                
                let syncing = false;
                this._vertScrollHandler = () => {
                    if (syncing) return;
                    syncing = true;
                    layersList.scrollTop = framesSection.scrollTop;
                    syncing = false;
                };
                this._vertScrollLabelHandler = () => {
                    if (syncing) return;
                    syncing = true;
                    framesSection.scrollTop = layersList.scrollTop;
                    syncing = false;
                };
                
                framesSection.addEventListener('scroll', this._vertScrollHandler);
                layersList.addEventListener('scroll', this._vertScrollLabelHandler);
            }
            
            reorderFrames(fromIndex, toIndex) {
                this.saveFullState();
                const layer = this.getCurrentLayer();
                
                // Remove the frame from its original position
                const [movedFrame] = layer.frames.splice(fromIndex, 1);
                
                // Insert it at the new position
                layer.frames.splice(toIndex, 0, movedFrame);
                
                // Update current frame index if needed
                if (this.currentFrameIndex === fromIndex) {
                    this.currentFrameIndex = toIndex;
                } else if (fromIndex < this.currentFrameIndex && toIndex >= this.currentFrameIndex) {
                    this.currentFrameIndex--;
                } else if (fromIndex > this.currentFrameIndex && toIndex <= this.currentFrameIndex) {
                    this.currentFrameIndex++;
                }
                
                this.render();
            }
            
            // === SAVE / LOAD (.fby FrameBoy format) ===
            
            async saveProject() {
                const defaultName = this._lastSaveName || 'my-animation';
                
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const originalText = fileMenuBtn.innerHTML;
                fileMenuBtn.textContent = 'Saving...';
                fileMenuBtn.disabled = true;
                
                try {
                    // Serialize all layers and frames to base64 PNG
                    // Track hold frame relationships: shared canvases get saved once with a reference
                    const layerData = [];
                    for (const layer of this.layers) {
                        const frames = [];
                        const canvasIdMap = new Map(); // canvas -> first index in this layer
                        for (let fi = 0; fi < layer.frames.length; fi++) {
                            const frame = layer.frames[fi];
                            if (frame) {
                                if (canvasIdMap.has(frame)) {
                                    // This is a hold frame â€” reference the first occurrence
                                    frames.push({ holdRef: canvasIdMap.get(frame) });
                                } else {
                                    canvasIdMap.set(frame, fi);
                                    const fData = { data: frame.toDataURL('image/png') };
                                    if (frame._originX || frame._originY) {
                                        fData.originX = frame._originX || 0;
                                        fData.originY = frame._originY || 0;
                                    }
                                    frames.push(fData);
                                }
                            } else {
                                frames.push(null);
                            }
                        }
                        layerData.push({
                            id: layer.id,
                            name: layer.name,
                            visible: layer.visible,
                            opacity: layer.opacity,
                            frames: frames,
                            transformKeyframes: layer.transformKeyframes || [],
                            startFrame: layer.startFrame || 0,
                            parentId: layer.parentId || null
                        });
                    }
                    
                    const project = {
                        format: 'FrameBoy',
                        version: 1,
                        canvasWidth: this.projectWidth,
                        canvasHeight: this.projectHeight,
                        bgColor: this.bgColor,
                        fps: this.fps,
                        currentLayerId: this.currentLayerId,
                        currentFrameIndex: this.currentFrameIndex,
                        nextLayerId: this.nextLayerId,
                        layers: layerData
                    };
                    
                    // Include audio tracks if present
                    if (this.audioTracks.length > 0) {
                        project.audioTracks = this.audioTracks.map(t => ({
                            name: t.name,
                            mimeType: t.mimeType,
                            volume: t.volume,
                            muted: t.muted,
                            base64: t.base64,
                            startFrame: t.startFrame || 0
                        }));
                        // Legacy compat: also save first track as audioTrack
                        project.audioTrack = project.audioTracks[0];
                    }
                    
                    const json = JSON.stringify(project);
                    const blob = new Blob([json], { type: 'application/json' });
                    
                    // Try native save picker (user chooses location + filename)
                    if ('showSaveFilePicker' in window) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: `${defaultName}.fby`,
                                types: [{
                                    description: 'FrameBoy Project',
                                    accept: { 'application/json': ['.fby'] }
                                }]
                            });
                            const writable = await handle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                            // Remember name user chose for next save
                            this._lastSaveName = handle.name.replace(/\.fby$/i, '');
                            
                            fileMenuBtn.textContent = 'âœ“ Saved!';
                            setTimeout(() => {
                                fileMenuBtn.innerHTML = originalText;
                                fileMenuBtn.disabled = false;
                            }, 1500);
                            return;
                        } catch (err) {
                            if (err.name === 'AbortError') {
                                // User cancelled the picker
                                fileMenuBtn.innerHTML = originalText;
                                fileMenuBtn.disabled = false;
                                return;
                            }
                            // API failed â€” fall through to prompt + download
                        }
                    }
                    
                    // Fallback: prompt for name then download (Safari, Firefox, iPad)
                    const fileName = prompt('Name your project:', defaultName);
                    if (fileName === null) {
                        fileMenuBtn.innerHTML = originalText;
                        fileMenuBtn.disabled = false;
                        return;
                    }
                    const safeName = fileName.trim().replace(/[^\w\s\-]/g, '').replace(/\s+/g, '-') || 'my-animation';
                    this._lastSaveName = safeName;
                    this.downloadBlob(blob, `${safeName}.fby`);
                    
                    fileMenuBtn.textContent = 'âœ“ Saved!';
                    setTimeout(() => {
                        fileMenuBtn.innerHTML = originalText;
                        fileMenuBtn.disabled = false;
                    }, 1500);
                } catch (err) {
                    console.error('Save failed:', err);
                    alert('Save failed: ' + err.message);
                    fileMenuBtn.innerHTML = originalText;
                    fileMenuBtn.disabled = false;
                }
            }
            
            async loadProject(file) {
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const originalText = fileMenuBtn.innerHTML;
                fileMenuBtn.textContent = 'Loading...';
                fileMenuBtn.disabled = true;
                
                try {
                    const text = await file.text();
                    const project = JSON.parse(text);
                    
                    // Extract project name from filename for re-saving
                    this._lastSaveName = file.name.replace(/\.fby$/i, '') || 'my-animation';
                    
                    // Validate format
                    if (project.format !== 'FrameBoy' || !project.layers) {
                        throw new Error('Not a valid FrameBoy project file.');
                    }
                    
                    // Commit any active selection
                    this.commitSelection();
                    this.hideTransformHandles();
                    
                    // Restore canvas dimensions
                    if (project.canvasWidth && project.canvasHeight) {
                        this.projectWidth = project.canvasWidth;
                        this.projectHeight = project.canvasHeight;
                        
                        if (this.pasteboardVisible) {
                            // Will be applied after load via updatePasteboard
                        } else {
                            this.canvas.width = project.canvasWidth;
                            this.canvas.height = project.canvasHeight;
                            this.onionCanvas.width = project.canvasWidth;
                            this.onionCanvas.height = project.canvasHeight;
                            this.selectionCanvas.width = project.canvasWidth;
                            this.selectionCanvas.height = project.canvasHeight;
                            this.gridCanvas.width = project.canvasWidth;
                            this.gridCanvas.height = project.canvasHeight;
                        }
                    }
                    
                    // Restore FPS
                    if (project.fps) {
                        this.fps = project.fps;
                        document.getElementById('fpsBadgeValue').textContent = project.fps;
                        document.getElementById('fpsCustomInput').value = project.fps;
                        document.getElementById('fpsPresets').querySelectorAll('.fps-preset').forEach(btn => {
                            btn.classList.toggle('active', parseInt(btn.dataset.fps) === project.fps);
                        });
                    }
                    
                    // Restore background color
                    if (project.bgColor) {
                        this.bgColor = project.bgColor;
                        this.canvasWrapper.style.background = this.bgColor;
                    }
                    
                    // Load layers and frames from base64
                    const loadImage = (dataUrl, originX, originY) => {
                        return new Promise((resolve, reject) => {
                            const img = new Image();
                            img.onload = () => {
                                const c = document.createElement('canvas');
                                c.width = img.naturalWidth || this.canvas.width;
                                c.height = img.naturalHeight || this.canvas.height;
                                c._originX = originX || 0;
                                c._originY = originY || 0;
                                c.getContext('2d').drawImage(img, 0, 0);
                                resolve(c);
                            };
                            img.onerror = reject;
                            img.src = dataUrl;
                        });
                    };
                    
                    const layers = [];
                    for (const layerData of project.layers) {
                        const frames = [];
                        const holdCanvasMap = new Map(); // index -> canvas for hold reference lookup
                        for (let fi = 0; fi < layerData.frames.length; fi++) {
                            const frameData = layerData.frames[fi];
                            if (frameData && typeof frameData === 'object' && frameData.holdRef !== undefined) {
                                // Hold frame: reuse the canvas from the referenced index
                                frames.push(holdCanvasMap.get(frameData.holdRef) || null);
                            } else if (frameData) {
                                // Support both old format (plain string) and new format (object with data + origin)
                                const dataUrl = (typeof frameData === 'string') ? frameData : frameData.data;
                                const originX = (typeof frameData === 'object') ? (frameData.originX || 0) : 0;
                                const originY = (typeof frameData === 'object') ? (frameData.originY || 0) : 0;
                                const canvas = await loadImage(dataUrl, originX, originY);
                                holdCanvasMap.set(fi, canvas);
                                frames.push(canvas);
                            } else {
                                frames.push(null);
                            }
                        }
                        layers.push({
                            id: layerData.id,
                            name: layerData.name || ('Layer ' + (layers.length + 1)),
                            visible: layerData.visible !== false,
                            opacity: layerData.opacity != null ? layerData.opacity : 1.0,
                            frames: frames,
                            transformKeyframes: layerData.transformKeyframes || [],
                            startFrame: layerData.startFrame || 0,
                            parentId: layerData.parentId || null
                        });
                    }
                    
                    // Apply loaded state
                    this.layers = layers;
                    this.currentLayerId = project.currentLayerId || layers[0].id;
                    this.currentFrameIndex = project.currentFrameIndex || 0;
                    this.nextLayerId = project.nextLayerId || (Math.max(...layers.map(l => l.id)) + 1);
                    
                    // Reset undo/redo
                    this.undoStack = [];
                    this.redoStack = [];
                    this.selectionUndoStack = [];
                    this.selectionRedoStack = [];
                    this.viewportX = 0;
                    this.viewportY = 0;
                    this.updateUndoRedoButtons();
                    
                    // Apply pasteboard if visible
                    if (this.pasteboardVisible) {
                        this.updatePasteboard();
                    }
                    
                    // Restore audio tracks if present
                    this.audioTracks = [];
                    this._audioTrackIdCounter = 0;
                    
                    // Support both new multi-track format and legacy single-track
                    const savedTracks = project.audioTracks || (project.audioTrack ? [project.audioTrack] : []);
                    
                    for (const saved of savedTracks) {
                        if (!saved || !saved.base64) continue;
                        try {
                            const ctx = this.getAudioContext();
                            const arrayBuffer = this._base64ToArrayBuffer(saved.base64);
                            const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                            const waveformPeaks = this._generateWaveformPeaks(audioBuffer, 2000);
                            
                            this.audioTracks.push({
                                id: ++this._audioTrackIdCounter,
                                name: saved.name || 'Audio',
                                audioBuffer: audioBuffer,
                                base64: saved.base64,
                                mimeType: saved.mimeType || 'audio/mpeg',
                                volume: saved.volume || 1.0,
                                muted: saved.muted || false,
                                startFrame: saved.startFrame || 0,
                                waveformPeaks: waveformPeaks
                            });
                        } catch (audioErr) {
                            console.warn('Could not restore audio track:', audioErr);
                        }
                    }
                    
                    if (this.audioTracks.length > 0) {
                        this.renderAudioTracks();
                    } else {
                        this.hideAudioTimeline();
                    }
                    
                    // Render
                    this._timelineDirty = true;
                    this._invalidateCompositeCache();
                    this.positionOnionCanvas();
                    this.render();
                    this.drawGrid();
                    
                    // Scroll to current frame and repopulate virtualized frames
                    // (must happen after render so timeline DOM exists)
                    this._scrollTimelineToFrame(this.currentFrameIndex);
                    requestAnimationFrame(() => this._updateVisibleFrames());
                    
                    fileMenuBtn.textContent = 'âœ“ Loaded!';
                    setTimeout(() => {
                        fileMenuBtn.innerHTML = originalText;
                        fileMenuBtn.disabled = false;
                    }, 1500);
                } catch (err) {
                    console.error('Load failed:', err);
                    alert('Load failed: ' + err.message);
                    fileMenuBtn.innerHTML = originalText;
                    fileMenuBtn.disabled = false;
                }
            }
            
            async importImageSequence(files) {
                if (!files || files.length === 0) return;
                
                // Natural sort: properly orders frame_2 before frame_10
                files.sort((a, b) => {
                    return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
                });
                
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const originalHTML = fileMenuBtn.innerHTML;
                fileMenuBtn.disabled = true;
                
                this.commitSelection();
                
                const layer = this.getCurrentLayer();
                const insertAt = this.currentFrameIndex + 1;
                const canvasW = this.canvas.width;
                const canvasH = this.canvas.height;
                
                const loadImageFile = (file) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const img = new Image();
                            img.onload = () => resolve(img);
                            img.onerror = () => reject(new Error(`Failed to load: ${file.name}`));
                            img.src = reader.result;
                        };
                        reader.onerror = () => reject(new Error(`Failed to read: ${file.name}`));
                        reader.readAsDataURL(file);
                    });
                };
                
                try {
                    const newFrames = [];
                    
                    for (let i = 0; i < files.length; i++) {
                        fileMenuBtn.textContent = `Importing ${i + 1}/${files.length}â€¦`;
                        
                        const img = await loadImageFile(files[i]);
                        
                        // Create frame canvas and draw image scaled to fit, centered
                        const frame = document.createElement('canvas');
                        frame.width = canvasW;
                        frame.height = canvasH;
                        const ctx = frame.getContext('2d');
                        
                        // Compute scale to fit image within canvas (maintain aspect ratio)
                        const scale = Math.min(canvasW / img.width, canvasH / img.height);
                        const drawW = img.width * scale;
                        const drawH = img.height * scale;
                        const offsetX = (canvasW - drawW) / 2;
                        const offsetY = (canvasH - drawH) / 2;
                        
                        ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
                        newFrames.push(frame);
                    }
                    
                    // Insert frames into current layer after current position
                    layer.frames.splice(insertAt, 0, ...newFrames);
                    
                    // Pad other layers with empty frames to keep alignment
                    for (const otherLayer of this.layers) {
                        if (otherLayer.id === layer.id) continue;
                        const empties = [];
                        for (let i = 0; i < newFrames.length; i++) {
                            empties.push(this.createEmptyFrame());
                        }
                        otherLayer.frames.splice(insertAt, 0, ...empties);
                    }
                    
                    // Navigate to first imported frame
                    this.currentFrameIndex = insertAt;
                    this.render();
                    
                    fileMenuBtn.textContent = `âœ“ ${newFrames.length} frames imported`;
                    setTimeout(() => {
                        fileMenuBtn.innerHTML = originalHTML;
                        fileMenuBtn.disabled = false;
                    }, 2000);
                } catch (err) {
                    console.error('Import failed:', err);
                    alert('Import failed: ' + err.message);
                    fileMenuBtn.innerHTML = originalHTML;
                    fileMenuBtn.disabled = false;
                }
            }
            
            // Helper to trigger a file download from a blob
            downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            async exportGif() {
                const layer = this.getCurrentLayer();
                if (layer.frames.length === 0) {
                    alert('No frames to export!');
                    return;
                }
                
                // Export as PNG frames ZIP
                this.exportFramesAsPNG();
            }
            
            async exportFramesAsPNG() {
                const exportBtn = document.getElementById('fileMenuBtn');
                
                if (!exportBtn) {
                    alert('Export button not found. Please refresh the page.');
                    return;
                }
                
                const originalText = exportBtn.innerHTML;
                
                exportBtn.textContent = 'Exporting PNGs...';
                exportBtn.disabled = true;
                
                try {
                    const maxFrames = this.getDrawingTimelineLength();
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Create a temporary canvas for compositing
                    const compositeCanvas = document.createElement('canvas');
                    compositeCanvas.width = this.projectWidth;
                    compositeCanvas.height = this.projectHeight;
                    const compositeCtx = compositeCanvas.getContext('2d');
                    
                    const _savedVpX = this.viewportX, _savedVpY = this.viewportY;
                    this.viewportX = 0; this.viewportY = 0;
                    
                    // Try JSZip first (may be available if loaded from CDN)
                    let useZip = false;
                    let zip = null;
                    try {
                        if (typeof JSZip === 'undefined') await this.loadJSZip();
                        zip = new JSZip();
                        useZip = true;
                    } catch (e) {
                        // JSZip not available â€” will download individual files
                        useZip = false;
                    }
                    
                    const zipFolder = useZip ? zip.folder('frames') : null;
                    
                    for (let i = 0; i < maxFrames; i++) {
                        // Clear to transparent for PNG
                        compositeCtx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
                        
                        for (const layer of this.layers) {
                            this.drawLayerWithTransform(compositeCtx, layer, i);
                        }
                        
                        const filename = `frame_${String(i + 1).padStart(3, '0')}.png`;
                        
                        if (useZip) {
                            const blob = await new Promise(resolve => compositeCanvas.toBlob(resolve, 'image/png'));
                            zipFolder.file(filename, blob);
                        } else {
                            // Download individually with staggered timing
                            const dataUrl = compositeCanvas.toDataURL('image/png');
                            const a = document.createElement('a');
                            a.href = dataUrl;
                            a.download = filename;
                            a.click();
                            // Small delay between downloads to not overwhelm browser
                            if (i < maxFrames - 1) await new Promise(r => setTimeout(r, 100));
                        }
                        
                        const progress = Math.round((i / maxFrames) * 100);
                        exportBtn.textContent = `Exporting PNGs... ${progress}%`;
                        
                        // Yield to UI
                        if (i % 3 === 0) await new Promise(r => setTimeout(r, 0));
                    }
                    this.viewportX = _savedVpX; this.viewportY = _savedVpY;
                    
                    if (useZip) {
                        exportBtn.textContent = 'Generating ZIP...';
                        const zipBlob = await zip.generateAsync({
                            type: 'blob', compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        }, (meta) => {
                            exportBtn.textContent = `Compressing... ${Math.round(meta.percent)}%`;
                        });
                        this.downloadBlob(zipBlob, `animation-frames-${Date.now()}.zip`);
                        exportBtn.textContent = 'âœ“ ZIP Downloaded!';
                    } else {
                        exportBtn.textContent = 'âœ“ PNGs Downloaded!';
                    }
                    
                    setTimeout(() => {
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                    }, 2000);
                    
                } catch (error) {
                    console.error('PNG export error:', error);
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    alert(`PNG export failed: ${error.message}`);
                }
            }
            
            async exportAsGif() {
                const exportBtn = document.getElementById('fileMenuBtn');
                
                if (!exportBtn) {
                    alert('Export button not found. Please refresh the page.');
                    return;
                }
                
                const originalText = exportBtn.innerHTML;
                
                try {
                    exportBtn.textContent = 'Preparing GIF...';
                    exportBtn.disabled = true;
                    
                    const maxFrames = this.getDrawingTimelineLength();
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Create temporary canvas for rendering
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.projectWidth;
                    tempCanvas.height = this.projectHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Use built-in GIF encoder
                    const encoder = new GIFEncoder(this.projectWidth, this.projectHeight);
                    const frameDelay = Math.round(1000 / this.fps);
                    
                    const _svpX2 = this.viewportX, _svpY2 = this.viewportY;
                    this.viewportX = 0; this.viewportY = 0;
                    
                    for (let i = 0; i < maxFrames; i++) {
                        // White background for GIF (no transparency support in GIF89a easily)
                        tempCtx.fillStyle = this.bgColor || '#ffffff';
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        for (const layer of this.layers) {
                            this.drawLayerWithTransform(tempCtx, layer, i);
                        }
                        
                        const imageData = tempCtx.getImageData(0, 0, this.projectWidth, this.projectHeight);
                        encoder.addFrame(imageData.data, frameDelay);
                        
                        const progress = Math.round((i / maxFrames) * 80);
                        exportBtn.textContent = `Creating GIF... ${progress}%`;
                        
                        // Yield to UI
                        if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
                    }
                    this.viewportX = _svpX2; this.viewportY = _svpY2;
                    
                    exportBtn.textContent = 'Encoding GIF... 90%';
                    await new Promise(r => setTimeout(r, 0));
                    
                    const gifData = encoder.encode();
                    const blob = new Blob([gifData], { type: 'image/gif' });
                    
                    this.downloadBlob(blob, `frameboy-animation-${Date.now()}.gif`);
                    
                    exportBtn.textContent = 'âœ“ GIF Downloaded!';
                    exportBtn.disabled = false;
                    setTimeout(() => { exportBtn.innerHTML = originalText; }, 2000);
                    
                } catch (error) {
                    console.error('GIF export error:', error);
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    alert(`Failed to create GIF: ${error.message}`);
                }
            }
            
            async exportAsMp4() {
                const exportBtn = document.getElementById('fileMenuBtn');
                const originalText = exportBtn.innerHTML;
                
                try {
                    exportBtn.textContent = 'Creating MP4...';
                    exportBtn.disabled = true;
                    
                    const maxFrames = this.getDrawingTimelineLength();
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    if (!window.MediaRecorder) {
                        throw new Error('Video recording not supported in this browser');
                    }
                    
                    // Create a temporary canvas for recording
                    const recordCanvas = document.createElement('canvas');
                    recordCanvas.width = this.projectWidth;
                    recordCanvas.height = this.projectHeight;
                    const recordCtx = recordCanvas.getContext('2d');
                    
                    // Try best available video format
                    let mimeType = 'video/webm;codecs=vp9';
                    let fileExt = 'webm';
                    
                    if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) {
                        mimeType = 'video/mp4;codecs=avc1';
                        fileExt = 'mp4';
                    } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                        mimeType = 'video/mp4';
                        fileExt = 'mp4';
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
                        mimeType = 'video/webm;codecs=h264';
                        fileExt = 'mp4';
                    }
                    
                    // Get canvas video stream
                    const videoStream = recordCanvas.captureStream(this.fps);
                    
                    // Build combined stream with audio if we have audio tracks
                    let combinedStream;
                    let exportAudioCtx = null;
                    let exportAudioSources = [];
                    const animDuration = maxFrames / this.fps;
                    
                    if (this.audioTracks.length > 0 && this.audioTracks.some(t => !t.muted)) {
                        // Create a dedicated AudioContext for export
                        exportAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        const dest = exportAudioCtx.createMediaStreamDestination();
                        
                        // Schedule all audio tracks to play through the destination
                        for (const track of this.audioTracks) {
                            if (track.muted) continue;
                            
                            const trackStartTime = (track.startFrame || 0) / this.fps;
                            
                            // Skip if track starts after animation ends
                            if (trackStartTime >= animDuration) continue;
                            
                            const source = exportAudioCtx.createBufferSource();
                            source.buffer = track.audioBuffer;
                            const gain = exportAudioCtx.createGain();
                            gain.gain.value = track.volume;
                            source.connect(gain);
                            gain.connect(dest);
                            
                            // Calculate how much audio to play
                            const audioAvailable = track.audioBuffer.duration;
                            const playDuration = Math.min(audioAvailable, animDuration - trackStartTime);
                            
                            if (trackStartTime > 0) {
                                // Delayed start
                                source.start(exportAudioCtx.currentTime + trackStartTime, 0, playDuration);
                            } else {
                                // Immediate start
                                source.start(exportAudioCtx.currentTime, 0, playDuration);
                            }
                            
                            exportAudioSources.push(source);
                        }
                        
                        // Combine video + audio tracks into one stream
                        combinedStream = new MediaStream([
                            ...videoStream.getVideoTracks(),
                            ...dest.stream.getAudioTracks()
                        ]);
                    } else {
                        combinedStream = videoStream;
                    }
                    
                    const mediaRecorder = new MediaRecorder(combinedStream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: 5000000
                    });
                    
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        // Clean up audio sources
                        for (const src of exportAudioSources) {
                            try { src.stop(); } catch(e) {}
                            try { src.disconnect(); } catch(e) {}
                        }
                        if (exportAudioCtx) {
                            try { exportAudioCtx.close(); } catch(e) {}
                        }
                        
                        const blob = new Blob(chunks, { type: mimeType.split(';')[0] });
                        this.downloadBlob(blob, `frameboy-animation-${Date.now()}.${fileExt}`);
                        
                        exportBtn.textContent = 'âœ“ Video Downloaded!';
                        exportBtn.disabled = false;
                        setTimeout(() => {
                            exportBtn.innerHTML = originalText;
                        }, 2000);
                    };
                    
                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                        for (const src of exportAudioSources) {
                            try { src.stop(); } catch(ex) {}
                        }
                        if (exportAudioCtx) {
                            try { exportAudioCtx.close(); } catch(ex) {}
                        }
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        alert('Video recording failed.');
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    
                    // Play through all frames in real-time so audio stays synced
                    const frameDelay = 1000 / this.fps;
                    let currentFrame = 0;
                    
                    const drawNextFrame = () => {
                        if (currentFrame < maxFrames) {
                            const _rvpx = this.viewportX, _rvpy = this.viewportY;
                            this.viewportX = 0; this.viewportY = 0;
                            
                            recordCtx.fillStyle = this.bgColor;
                            recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
                            
                            for (const layer of this.layers) {
                                this.drawLayerWithTransform(recordCtx, layer, currentFrame);
                            }
                            
                            this.viewportX = _rvpx; this.viewportY = _rvpy;
                            
                            const progress = Math.round((currentFrame / maxFrames) * 100);
                            exportBtn.textContent = `Recording MP4... ${progress}%`;
                            
                            currentFrame++;
                            setTimeout(drawNextFrame, frameDelay);
                        } else {
                            // Wait a moment for final audio to flush, then stop
                            setTimeout(() => {
                                mediaRecorder.stop();
                            }, frameDelay * 2);
                        }
                    };
                    
                    drawNextFrame();
                    
                } catch (error) {
                    console.error('MP4 export error:', error);
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    alert(`Video export failed: ${error.message}`);
                }
            }
            
            exportFramesIndividually() {
                const layer = this.getCurrentLayer();
                
                setTimeout(() => {
                    layer.frames.forEach((frame, index) => {
                        if (frame) {
                            setTimeout(() => {
                                frame.toBlob((blob) => {
                                    this.downloadBlob(blob, `frame_${String(index + 1).padStart(3, '0')}.png`);
                                });
                            }, index * 200);
                        }
                    });
                }, 100);
                
                alert(`Downloading ${layer.frames.length} frames as individual PNG files!`);
            }
            
            async loadJSZip() {
                return new Promise((resolve, reject) => {
                    if (typeof JSZip !== 'undefined') {
                        resolve();
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.async = true;
                    
                    const timeout = setTimeout(() => {
                        reject(new Error('JSZip library took too long to load'));
                    }, 10000);
                    
                    script.onload = () => {
                        clearTimeout(timeout);
                        setTimeout(() => {
                            if (typeof JSZip !== 'undefined') {
                                resolve();
                            } else {
                                reject(new Error('JSZip library loaded but not available'));
                            }
                        }, 100);
                    };
                    
                    script.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Failed to load JSZip library'));
                    };
                    
                    document.head.appendChild(script);
                });
            }
            
            exportSpriteSheet() {
                const layer = this.getCurrentLayer();
                const frameCount = layer.frames.length;
                
                if (frameCount === 0) return;
                
                // Create a sprite sheet with all frames in a row
                const frameWidth = this.canvas.width;
                const frameHeight = this.canvas.height;
                const spriteSheet = document.createElement('canvas');
                spriteSheet.width = frameWidth * frameCount;
                spriteSheet.height = frameHeight;
                const ctx = spriteSheet.getContext('2d');
                
                // Draw project background
                ctx.fillStyle = this.bgColor;
                ctx.fillRect(0, 0, spriteSheet.width, spriteSheet.height);
                
                // Draw each frame (accounting for frame origin in infinite canvas)
                layer.frames.forEach((frame, index) => {
                    if (frame) {
                        const offX = frame._originX || 0;
                        const offY = frame._originY || 0;
                        ctx.drawImage(frame, offX + index * frameWidth, offY);
                    }
                });
                
                // Download the sprite sheet
                spriteSheet.toBlob((blob) => {
                    this.downloadBlob(blob, 'animation_spritesheet.png');
                    alert('Sprite sheet downloaded! You can use this with CSS animations or game engines.');
                });
            }
        }
        
        // Initialize the app
        const app = new FrameBoy();
        
        // Warn before closing/navigating away to prevent losing unsaved work
        window.addEventListener('beforeunload', (e) => {
            e.preventDefault();
            e.returnValue = '';
        });
        
        // Helper: safely check e.target.closest (e.target may be a text node without .closest)
        const _cl = (el, sel) => el && typeof el.closest === 'function' ? el.closest(sel) : null;
        const _isCanvas = (el) => (el && el.tagName === 'CANVAS') || _cl(el, 'canvas') || _cl(el, '.canvas-container');
        
        // Apple Pencil tap fix:
        // iPadOS Safari sometimes delays or fails to fire click events from stylus.
        // Solution: fire click on pointerdown for pen, then suppress the delayed native click.
        const penTapState = { lastTarget: null, lastTime: 0, isManualClick: false };
        
        document.addEventListener('pointerdown', (e) => {
            if (e.pointerType !== 'pen') return;
            if (!e.target || !e.target.closest) return;
            // Explicitly exclude canvas elements
            if (e.target.tagName === 'CANVAS') return;
            if (e.target.closest('canvas')) return;
            
            const btn = e.target.closest('button, .shape-icon, .dropdown-item, .add-frame, .add-layer-btn-inline, .delete-layer-btn-inline, input[type="checkbox"]');
            if (btn && !e.target.closest('canvas')) {
                // Mark that we're about to fire a manual click
                penTapState.isManualClick = true;
                // Fire the click synchronously first (handlers run immediately)
                btn.click();
                // Clear the flag after handlers complete
                penTapState.isManualClick = false;
                // THEN mark it so the delayed native click gets suppressed
                penTapState.lastTarget = btn;
                penTapState.lastTime = Date.now();
            }
        });
        
        // Capture-phase: suppress the delayed native click Safari sends ~300ms later
        document.addEventListener('click', (e) => {
            // Don't suppress if this is our own manual click
            if (penTapState.isManualClick) return;
            
            if (!e.target || !e.target.closest) return;
            // Explicitly exclude canvas clicks
            if (e.target.tagName === 'CANVAS') return;
            if (e.target.closest('canvas')) return;
            
            if (!penTapState.lastTarget) return;
            if (Date.now() - penTapState.lastTime > 800) {
                penTapState.lastTarget = null;
                return;
            }
            const btn = e.target.closest('button, .shape-icon, .dropdown-item, .add-frame, .add-layer-btn-inline, .delete-layer-btn-inline, input[type="checkbox"]');
            if (btn === penTapState.lastTarget) {
                e.stopImmediatePropagation();
                e.preventDefault();
                penTapState.lastTarget = null;
            }
        }, true);
        
        // Mobile: close dropdown overlays when tapping outside
        document.addEventListener('pointerdown', (e) => {
            if (window.innerWidth > 768) return;
            if (!e.target || !e.target.closest) return;
            // Don't close dropdowns when interacting with canvas
            if (e.target.tagName === 'CANVAS') return;
            if (e.target.closest('canvas')) return;
            
            const isDropdown = e.target.closest('.brush-dropdown, .dropdown-menu, .onion-skin-dropdown');
            const isToggle = e.target.closest('button');
            if (!isDropdown && !isToggle) {
                document.querySelectorAll('.brush-dropdown.show, .dropdown-menu.show, .onion-skin-dropdown.show')
                    .forEach(d => d.classList.remove('show'));
            }
        });
        
        // Prevent iOS double-tap selection menu and context menu globally for canvas
        document.addEventListener('dblclick', (e) => {
            if (_isCanvas(e.target)) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, true);
        
        document.addEventListener('contextmenu', (e) => {
            if (_isCanvas(e.target)) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, true);
        
        // Prevent text selection globally when on canvas or when actively drawing
        // This stops the Export button text from being selected during fast drawing
        document.addEventListener('selectstart', (e) => {
            // Always prevent selection on canvas
            if (_isCanvas(e.target)) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return;
            }
            
            // Prevent selection globally when using brush/eraser tools (not just when drawing)
            // This stops fast strokes from accidentally selecting UI text
            if (app && (app.tool === 'brush' || app.tool === 'eraser')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return;
            }
            
            // Also prevent if we're actively drawing (backup check)
            if (app && app.isDrawing) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, true);
        
        // Prevent drag gestures from interfering with drawing
        document.addEventListener('dragstart', (e) => {
            // Prevent drag on canvas
            if (_isCanvas(e.target)) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            
            // Prevent drag globally when using brush/eraser
            if (app && (app.tool === 'brush' || app.tool === 'eraser')) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);
        
        // Prevent iOS gesture-based selection (like pinch-to-select)
        document.addEventListener('gesturestart', (e) => {
            if (_isCanvas(e.target)) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('gesturechange', (e) => {
            if (_isCanvas(e.target)) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('gestureend', (e) => {
            if (_isCanvas(e.target)) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // === PWA: Service Worker + File Handling ===
        
        // Register service worker for PWA install (enables file_handlers in manifest)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {
                // SW not available (e.g. not served over HTTPS) â€” app still works fine
            });
        }
        
        // File Handling API: when .fby is opened via OS file association (PWA only)
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(async (launchParams) => {
                if (launchParams.files && launchParams.files.length > 0) {
                    const fileHandle = launchParams.files[0];
                    const file = await fileHandle.getFile();
                    if (file.name.endsWith('.fby')) {
                        app.loadProject(file);
                    }
                }
            });
        }
        
        // === Drag-and-Drop .fby file loading ===
        
        const dropOverlay = document.getElementById('dropOverlay');
        let dragCounter = 0; // Track nested enter/leave events
        
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            // Only show overlay if dragging files (not canvas elements)
            if (e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                dropOverlay.classList.add('active');
            }
        });
        
        document.addEventListener('dragover', (e) => {
            e.preventDefault(); // Required to allow drop
            if (e.dataTransfer) {
                e.dataTransfer.dropEffect = 'copy';
            }
        });
        
        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter <= 0) {
                dragCounter = 0;
                dropOverlay.classList.remove('active');
            }
        });
        
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter = 0;
            dropOverlay.classList.remove('active');
            
            if (e.dataTransfer && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.name.endsWith('.fby')) {
                    app.loadProject(file);
                } else {
                    alert('Please drop a .fby FrameBoy project file.');
                }
            }
        });
    </script>
</body>
</html>
