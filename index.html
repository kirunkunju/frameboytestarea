<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="FrameBoy - Create frame-by-frame animations">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="FrameBoy">
    <meta name="theme-color" content="#1e1e1e">
    <link rel="manifest" href="manifest.json">
    <title>FrameBoy</title>
    <!-- Gifshot library for GIF export (more reliable than gif.js) -->
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #2a2a2a;
            color: #e0e0e0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            height: 100dvh;
        }

        html {
            width: 100%;
            height: 100%;
            height: 100dvh;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100vh;
            height: 100dvh;
            height: var(--app-height, 100dvh);
            min-height: 400px;
            max-height: 100vh;
            max-height: 100dvh;
            max-height: var(--app-height, 100dvh);
            overflow: hidden;
            -webkit-touch-callout: none;
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }


        /* Toolbar */
        .toolbar {
            background: #1e1e1e;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #3a3a3a;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            padding: 0 10px;
            border-right: 1px solid #3a3a3a;
        }

        .tool-group:last-child {
            border-right: none;
        }

        button {
            background: #3a3a3a;
            border: none;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        button svg {
            flex-shrink: 0;
            vertical-align: middle;
        }
        
        .dropdown-item svg {
            flex-shrink: 0;
            vertical-align: middle;
            opacity: 0.85;
        }

        .btn-label {
            display: inline;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
        }

        .toolbar .btn-label {
            display: none;
        }

        /* Apple Pencil / touch: instant feedback on all interactive elements */
        input, select, label, .shape-icon, .dropdown-item, .frame, .add-frame,
        .layer-item, .add-layer-btn-inline, .delete-layer-btn-inline {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        button:hover {
            background: #4a4a4a;
        }
        
        /* Instant press feedback for Apple Pencil & touch */
        button:active {
            background: #555;
            transition: none;
        }

        button.active {
            background: #0066cc;
        }
        
        .dropdown-container {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 8px 12px;
            background: #2a2a2a;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            border-radius: 0;
            font-size: 14px;
        }
        
        .dropdown-item .shortcut {
            font-size: 11px;
            color: #888;
            margin-left: auto;
        }
        
        .dropdown-divider {
            height: 1px;
            background: #444;
            margin: 4px 0;
        }
        
        .dropdown-submenu-container {
            position: relative;
        }
        
        .dropdown-submenu-container .submenu-trigger {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .submenu-arrow {
            font-size: 10px;
            color: #888;
            margin-left: 12px;
        }
        
        .dropdown-submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            min-width: 180px;
            z-index: 1001;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.5);
        }
        
        .dropdown-submenu-container:hover > .dropdown-submenu,
        .dropdown-submenu-container.touch-open > .dropdown-submenu {
            display: block;
        }
        
        .dropdown-submenu .dropdown-item:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .dropdown-submenu .dropdown-item:last-child {
            border-radius: 0 0 4px 4px;
        }
        
        .dropdown-item:hover {
            background: #3a3a3a;
        }
        
        .dropdown-item:first-child {
            border-radius: 4px 4px 0 0;
        }
        
        .dropdown-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        input[type="range"] {
            width: 100px;
        }

        label {
            font-size: 12px;
            margin-right: 5px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Main content area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Layer items (now in timeline) */
        .layers-list {
            flex: 1;
            overflow-y: auto;
        }

        .layer-item {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 6px;
            border-bottom: 1px solid #2a2a2a;
            font-size: 11px;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
        }
        
        .layer-item.dragging {
            opacity: 0.4;
        }
        
        .layer-item.drop-before::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
            z-index: 10;
        }
        
        .layer-item.drop-after::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #00cc66;
            z-index: 10;
        }
        
        .layer-drag-handle {
            cursor: grab;
            color: #666;
            font-size: 12px;
            padding: 0 4px;
            display: flex;
            align-items: center;
            flex-shrink: 0;
            touch-action: none;
        }
        
        .layer-drag-handle:active {
            cursor: grabbing;
        }
        
        .layer-header {
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            -webkit-user-select: none;
        }

        .layer-item:hover {
            background: #2a2a2a;
        }

        .layer-item.active {
            background: #0066cc;
        }

        .layer-visibility {
            cursor: pointer;
            font-size: 14px;
            user-select: none;
            -webkit-user-select: none;
        }

        .layer-name {
            flex: 1;
            font-size: 11px;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .layer-opacity-control {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            padding-left: 22px;
            padding-right: 8px;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .layer-opacity-control > span:first-child {
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .layer-opacity-control input[type="range"] {
            width: 70px;
            height: 3px;
            flex-shrink: 0;
        }
        
        .layer-opacity-value {
            min-width: 35px;
            text-align: right;
            font-size: 10px;
            user-select: none;
            -webkit-user-select: none;
            flex-shrink: 0;
        }

        /* Canvas area */
        .canvas-container {
            flex: 1;
            background: #333;
            position: relative;
            overflow: auto;
            min-height: 200px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .canvas-wrapper {
            position: relative;
            margin: auto;
            /* Centering when wrapper is smaller than container */
        }

        canvas {
            border: 1px solid #555;
            cursor: crosshair;
            display: block;
            touch-action: none;
            will-change: contents;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 4px 6px;
            border-radius: 10px;
            z-index: 20;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.35);
            pointer-events: auto;
        }
        
        .zoom-controls .pill-divider {
            width: 1px;
            height: 18px;
            background: rgba(255, 255, 255, 0.12);
            margin: 0 2px;
            flex-shrink: 0;
        }
        
        .zoom-controls button {
            padding: 4px 6px;
            font-size: 12px;
            min-width: 28px;
            min-height: 28px;
            justify-content: center;
            background: transparent;
            border-radius: 6px;
        }
        
        .zoom-controls button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .zoom-controls button:active {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .zoom-controls button.pill-active {
            background: #0066cc;
        }
        
        .zoom-controls button.pill-active:hover {
            background: #0077dd;
        }

        .magnifier-marquee {
            display: none;
            position: absolute;
            border: 1.5px dashed rgba(0, 102, 204, 0.9);
            background: rgba(0, 102, 204, 0.08);
            pointer-events: none;
            z-index: 15;
            border-radius: 2px;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.15);
        }
        
        .zoom-label {
            color: #ccc;
            font-size: 12px;
            min-width: 42px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        #mainCanvas {
            position: relative;
            z-index: 2;
        }

        #onionCanvas {
            position: absolute;
            pointer-events: none;
            z-index: 1;
            background: white;
        }
        
        #selectionCanvas {
            position: absolute;
            pointer-events: auto;
            z-index: 3;
        }
        
        .transform-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border: 2px solid #0066cc;
            border-radius: 50%;
            cursor: pointer;
            z-index: 4;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        
        .transform-handle.corner { cursor: nwse-resize; }
        .transform-handle.side-h { cursor: ew-resize; }
        .transform-handle.side-v { cursor: ns-resize; }
        .transform-handle.rotate { cursor: grab; background: #0066cc; }

        /* Timeline */
        .timeline-resize-handle {
            height: 10px;
            cursor: row-resize;
            background: transparent;
            position: relative;
            flex-shrink: 0;
            touch-action: none;
        }
        
        .timeline-resize-handle::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 4px;
            background: #4a4a4a;
            border-radius: 2px;
        }
        
        .timeline-resize-handle:hover::before,
        .timeline-resize-handle:active::before {
            background: #0066cc;
        }
        
        .timeline {
            min-height: 180px;
            max-height: 280px;
            height: 25vh;
            background: #252525;
            border-top: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .timeline-header {
            background: #1e1e1e;
            border-bottom: 1px solid #3a3a3a;
        }

        .timeline-controls {
            padding: 8px;
            display: flex;
            gap: 5px;
            align-items: center;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .playback-controls {
            display: flex;
            gap: 5px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .fps-control {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 5px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .timeline-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .timeline-layers-section {
            width: 220px;
            min-width: 160px;
            max-width: 400px;
            background: #252525;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }
        
        .layer-panel-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 10;
            background: transparent;
            transition: background 0.2s;
        }
        
        .layer-panel-resize-handle:hover {
            background: rgba(0, 102, 204, 0.3);
        }
        
        .layer-panel-resize-handle:active {
            background: rgba(0, 102, 204, 0.5);
        }
        
        .layer-panel-resize-handle::before {
            content: '';
            position: absolute;
            right: 3px;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 30px;
            background: #4a4a4a;
            border-radius: 1px;
        }
        
        .layers-header {
            padding: 8px 10px;
            background: #1e1e1e;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .layer-buttons {
            display: flex;
            gap: 4px;
        }
        
        .add-layer-btn-inline {
            padding: 2px 8px;
            font-size: 14px;
            background: #0066cc;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .add-layer-btn-inline:hover {
            background: #0077dd;
        }
        
        .delete-layer-btn-inline {
            padding: 2px 8px;
            font-size: 14px;
            background: #cc3333;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .delete-layer-btn-inline:hover {
            background: #dd4444;
        }
        
        .timeline-layers-section .layers-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }
        
        .timeline-frames-section {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            background: #2a2a2a;
        }

        .frames-container {
            display: flex;
            padding: 10px;
            gap: 5px;
            min-width: 100%;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
        }

        .frame {
            width: 80px;
            height: 80px;
            border: 2px solid #3a3a3a;
            border-radius: 4px;
            cursor: grab;
            position: relative;
            flex-shrink: 0;
            background: #2a2a2a;
            transition: border-color 0.15s, transform 0.15s, opacity 0.15s;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        
        .frame:active {
            cursor: grabbing;
        }
        
        .frame.dragging {
            opacity: 0.3;
            transform: scale(0.9);
        }

        .frames-container.is-dragging .frame:not(.dragging) {
            cursor: grabbing;
        }
        
        .frame-drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.85;
            border: 2px solid #4a9eff;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(74, 158, 255, 0.4);
            transform: translate(-50%, -50%) scale(1.05);
            background: #2a2a2a;
            overflow: hidden;
        }
        
        .frame-drop-indicator {
            position: absolute;
            width: 3px;
            height: 80px;
            background: #4a9eff;
            border-radius: 2px;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(74, 158, 255, 0.6);
            top: 10px;
        }

        .frame:hover {
            border-color: #4a4a4a;
        }

        .frame.active {
            border-color: #0066cc;
        }

        .frame canvas {
            width: 100%;
            height: 100%;
            border: none;
        }

        .frame-number {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 2px;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none;
        }

        .add-frame {
            width: 80px;
            height: 80px;
            border: 2px dashed #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #666;
            flex-shrink: 0;
        }

        .add-frame:hover {
            border-color: #4a4a4a;
            color: #888;
        }
        /* Brush cursor overlay */
        .brush-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            border: 1.5px solid rgba(0, 102, 204, 0.8);
            display: none;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
        
        .brush-cursor.round {
            border-radius: 50%;
        }
        
        .brush-cursor.square {
            border-radius: 0;
        }
        
        .brush-cursor.oval-h,
        .brush-cursor.oval-v {
            border-radius: 50%;
        }
        
        /* Brush/Eraser dropdown panel */
        .brush-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 200px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding: 10px;
        }
        
        .brush-dropdown.show {
            display: block;
        }
        
        .brush-setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .brush-setting-row:last-child {
            margin-bottom: 0;
        }
        
        .brush-setting-row label {
            margin-right: 8px;
            white-space: nowrap;
        }
        
        .brush-setting-row input[type="range"] {
            width: 80px;
        }
        
        .brush-setting-row select {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #e0e0e0;
            padding: 3px 6px;
            font-size: 12px;
        }
        
        .shape-picker {
            display: flex;
            gap: 4px;
        }
        
        .shape-icon {
            width: 30px;
            height: 30px;
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }
        
        .shape-icon:hover {
            border-color: #888;
            background: #444;
        }
        
        .shape-icon.active {
            border-color: #4a9eff;
            background: #2a4a6a;
        }
        
        .shape-icon svg {
            width: 20px;
            height: 20px;
        }
        
        .brush-setting-value {
            min-width: 28px;
            text-align: right;
            font-size: 11px;
            color: #aaa;
        }

        /* Onion skin dropdown panel */
        .onion-skin-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 220px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding: 10px;
        }
        
        .onion-skin-dropdown.show {
            display: block;
        }
        
        .onion-setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .onion-setting-row:last-child {
            margin-bottom: 0;
        }
        
        .onion-setting-row label {
            margin-right: 8px;
            white-space: nowrap;
        }
        
        .onion-setting-row input[type="range"] {
            width: 80px;
        }
        
        .onion-setting-row input[type="number"] {
            width: 45px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #e0e0e0;
            padding: 2px 4px;
            font-size: 12px;
        }
        
        .onion-setting-row input[type="color"] {
            width: 28px;
            height: 22px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }
        
        .onion-setting-value {
            min-width: 28px;
            text-align: right;
            font-size: 11px;
            color: #aaa;
        }
        
        .onion-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 8px 0;
        }

        /* Frame context menu */
        .frame-context-menu {
            display: none;
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            min-width: 160px;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            padding: 4px 0;
        }
        
        .frame-context-menu.show {
            display: block;
        }
        
        .frame-context-menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 8px 14px;
            background: none;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
        }
        
        .frame-context-menu-item:hover {
            background: #3a3a3a;
        }
        
        .frame-context-menu-item.disabled {
            color: #666;
            cursor: default;
        }
        
        .frame-context-menu-item.disabled:hover {
            background: none;
        }
        
        .frame-context-menu-item .shortcut {
            font-size: 11px;
            color: #888;
            margin-left: 16px;
        }
        
        .frame-context-menu-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 4px 0;
        }

        /* Make responsive for smaller screens */
        @media (max-width: 1024px) {
            .timeline-layers-section {
                width: 140px;
            }
            
            .frame {
                width: 60px;
                height: 60px;
            }
            
            .add-frame {
                width: 60px;
                height: 60px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                min-height: 100vh;
                min-height: 100dvh;
                min-height: var(--app-height, 100dvh);
            }
            
            /* Toolbar: 2-row wrapping layout — all buttons visible */
            .toolbar {
                flex-wrap: wrap;
                padding: 4px 6px;
                gap: 2px;
                overflow: visible;
                max-height: none;
            }
            
            .tool-group {
                padding: 0 3px;
                border-right: 1px solid #444;
                flex-shrink: 0;
                flex-wrap: nowrap;
                gap: 2px;
                align-items: center;
            }
            .tool-group:last-child { border-right: none; }
            
            /* Icon-only buttons on mobile */
            .btn-label {
                display: none;
            }
            
            button {
                padding: 7px;
                font-size: 15px;
                min-width: 38px;
                min-height: 38px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
            }
            
            /* Active press state — immediate feedback for Apple Pencil & touch */
            button:active {
                background: #0066cc;
                transform: scale(0.93);
                transition: none;
            }
            
            input[type="range"] {
                width: 50px;
                min-height: 32px;
                flex-shrink: 0;
            }
            
            input[type="color"] {
                min-width: 34px;
                min-height: 34px;
                flex-shrink: 0;
            }
            
            /* Hide labels in toolbar */
            .tool-group > label {
                display: none;
            }
            #sizeValue {
                font-size: 11px;
                min-width: 20px;
                flex-shrink: 0;
                text-align: center;
            }
            
            .size-step-btn {
                width: 22px;
                height: 22px;
                padding: 0;
                border: 1px solid #555;
                border-radius: 4px;
                background: #2a2a2a;
                color: #ccc;
                font-size: 14px;
                line-height: 1;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
            }
            .size-step-btn:hover { background: #3a3a3a; border-color: #777; }
            .size-step-btn:active { background: #444; }
            
            /* Keep dropdown containers inline */
            .dropdown-container {
                flex-shrink: 0;
            }
            
            /* Timeline compact */
            .timeline {
                min-height: 120px;
                height: 20vh;
            }
            
            .timeline-layers-section {
                width: 85px;
            }
            
            /* Timeline controls: scrollable row */
            .timeline-header {
                overflow: hidden;
            }
            .timeline-controls {
                padding: 4px 6px;
                overflow-x: auto;
                flex-wrap: nowrap;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }
            .timeline-controls::-webkit-scrollbar { display: none; }
            
            .playback-controls {
                flex-shrink: 0;
                flex-wrap: nowrap;
                gap: 2px;
            }
            
            .playback-controls button {
                padding: 5px;
                font-size: 13px;
                min-width: 34px;
                min-height: 34px;
            }
            
            .fps-control {
                flex-shrink: 0;
            }
            .fps-control label {
                display: inline;
                font-size: 10px;
            }
            .fps-control input {
                width: 40px;
            }
            
            .frame {
                width: 48px;
                height: 48px;
            }
            
            .add-frame {
                width: 48px;
                height: 48px;
            }
            
            .layer-name {
                font-size: 10px;
            }
            
            .layer-opacity-control {
                padding-left: 4px;
            }
            .layer-opacity-control input[type="range"] {
                width: 45px;
                min-height: 20px;
            }
            
            /* Layers header buttons */
            .add-layer-btn-inline,
            .delete-layer-btn-inline {
                min-width: 32px;
                min-height: 32px;
                padding: 4px;
                font-size: 14px;
            }
            
            /* Dropdowns: centered overlay on mobile */
            .dropdown-menu,
            .brush-dropdown,
            .onion-skin-dropdown {
                position: fixed;
                top: 50%;
                left: 50%;
                right: auto;
                transform: translate(-50%, -50%);
                min-width: 240px;
                max-width: calc(100vw - 32px);
                max-height: 70vh;
                overflow-y: auto;
                z-index: 2000;
            }
            
            /* Dropdown items: touch-friendly size */
            .dropdown-item {
                padding: 12px 14px;
                min-height: 44px;
            }
            
            /* Submenu: inline on mobile instead of fly-out */
            .dropdown-submenu {
                position: static !important;
                border: none !important;
                box-shadow: none !important;
                border-radius: 0 !important;
                min-width: 0 !important;
                background: #333 !important;
            }
            
            .dropdown-submenu .dropdown-item {
                padding-left: 28px;
            }
            
            /* Canvas area */
            .canvas-container {
                min-height: 140px;
            }
        }

        @media (max-width: 480px) {
            .toolbar {
                padding: 3px 4px;
                gap: 1px;
            }
            
            .toolbar button {
                padding: 5px;
                font-size: 14px;
                min-width: 34px;
                min-height: 34px;
            }
            
            .tool-group {
                gap: 1px;
                padding: 0 2px;
            }
            
            .timeline-layers-section {
                width: 70px;
            }
            
            .timeline {
                min-height: 110px;
                height: 18vh;
            }
            
            .playback-controls button {
                min-width: 30px;
                min-height: 30px;
                padding: 4px;
                font-size: 12px;
            }
            
            .frame {
                width: 38px;
                height: 38px;
            }
            
            .add-frame {
                width: 38px;
                height: 38px;
                font-size: 16px;
            }
            
            input[type="color"] {
                min-width: 30px;
                min-height: 30px;
                width: 30px;
                height: 30px;
            }
            
            input[type="range"] {
                width: 44px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .timeline {
                min-height: 80px;
                height: 20vh;
            }
            
            .toolbar {
                padding: 3px 5px;
            }
            
            button {
                padding: 4px 6px;
            }
        }

        /* File drop zone overlay */
        .drop-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 120, 255, 0.15);
            border: 3px dashed #0078ff;
            z-index: 9999;
            pointer-events: none;
            align-items: center;
            justify-content: center;
        }
        
        .drop-overlay.active {
            display: flex;
        }
        
        .drop-overlay-label {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Canvas Size Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-overlay.show {
            display: flex;
        }
        .modal-dialog {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 12px;
            width: 380px;
            max-width: 95vw;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px 12px;
            border-bottom: 1px solid #333;
        }
        .modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
        }
        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 22px;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }
        .modal-close:hover { color: #fff; }
        .modal-body {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .modal-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .modal-row > label {
            color: #aaa;
            font-size: 13px;
            min-width: 55px;
            flex-shrink: 0;
        }
        .modal-row select {
            flex: 1;
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 7px 10px;
            font-size: 13px;
        }
        .modal-size-row {
            justify-content: center;
            gap: 8px;
        }
        .modal-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }
        .modal-field label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .modal-input-wrap {
            display: flex;
            align-items: center;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 6px;
            overflow: hidden;
        }
        .modal-input-wrap input {
            flex: 1;
            background: transparent;
            color: #e0e0e0;
            border: none;
            padding: 8px 10px;
            font-size: 14px;
            width: 60px;
            outline: none;
        }
        .modal-input-wrap input:focus {
            box-shadow: inset 0 0 0 1px #0066cc;
        }
        .modal-unit {
            color: #666;
            font-size: 12px;
            padding-right: 10px;
            flex-shrink: 0;
        }
        .modal-link-btn {
            background: none;
            border: 1px solid #555;
            border-radius: 6px;
            color: #666;
            cursor: pointer;
            padding: 6px;
            margin-top: 16px;
            transition: all 0.15s;
        }
        .modal-link-btn:hover { border-color: #888; color: #aaa; }
        .modal-link-btn.linked { color: #0088ff; border-color: #0066cc; }
        .modal-info {
            font-size: 12px;
            color: #666;
            text-align: center;
            min-height: 16px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 20px 16px;
            border-top: 1px solid #333;
        }
        .modal-btn {
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .modal-btn-cancel {
            background: #333;
            color: #ccc;
        }
        .modal-btn-cancel:hover { background: #444; }
        .modal-btn-apply {
            background: #0066cc;
            color: #fff;
        }
        .modal-btn-apply:hover { background: #0077dd; }

    </style>
</head>
<body>
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-label"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 1.5h8l3 3V13a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13V3a1.5 1.5 0 011-1.5z"/><path d="M5 1.5v4h6v-4"/><path d="M5 14.5v-4h6v4"/></svg> Drop .fby file to open</div>
    </div>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <div class="dropdown-container">
                    <button id="fileMenuBtn" title="File (Save/Load/Export)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 1.5h8l3 3V13a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13V3a1.5 1.5 0 011-1.5z"/><path d="M5 1.5v4h6v-4"/><path d="M5 14.5v-4h6v4"/></svg> <span class="btn-label">File ▼</span></button>
                    <div class="dropdown-menu" id="fileMenuDropdown">
                        <button class="dropdown-item" id="canvasSizeBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1.5" y="1.5" width="13" height="13" rx="1" stroke-dasharray="2 2"/><path d="M10 6l3-3M13 6V3h-3"/><path d="M6 10l-3 3M3 10v3h3"/></svg> Canvas Size…</button>
                        <div class="dropdown-divider"></div>
                        <button class="dropdown-item" id="saveProjectBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M3 1.5h8l3 3V13a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 012 13V3a1.5 1.5 0 011-1.5z"/><path d="M5 1.5v4h6v-4"/><path d="M5 14.5v-4h6v4"/></svg> Save Project (.fby) <span class="shortcut">⌘S</span></button>
                        <button class="dropdown-item" id="loadProjectBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M2 4v9a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H8L6.5 3H3a1 1 0 00-1 1z"/></svg> Load Project (.fby) <span class="shortcut">⌘O</span></button>
                        <button class="dropdown-item" id="importSequenceBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="3" width="8" height="8" rx="1"/><rect x="4" y="1.5" width="8" height="8" rx="1"/><path d="M13 6v5M10.5 8.5h5"/></svg> Import Image Sequence…</button>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-submenu-container">
                            <button class="dropdown-item submenu-trigger"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="12" height="10" rx="1"/><path d="M8 1v5m-2-2l2 2 2-2"/></svg> Export <span class="submenu-arrow">▶</span></button>
                            <div class="dropdown-submenu">
                                <button class="dropdown-item" id="exportPngZip"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="2" width="12" height="12" rx="1"/><circle cx="6" cy="7" r="1.5"/><path d="M2 11l3-3 2 2 3-3 4 4"/></svg> PNG Frames (ZIP)</button>
                                <button class="dropdown-item" id="exportGifBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="4" y="1" width="8" height="14" rx="1"/><path d="M6 1v14M10 1v14M4 5h8M4 9h8M4 13h8"/></svg> GIF Animation</button>
                                <button class="dropdown-item" id="exportMp4Btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="3" width="14" height="10" rx="1"/><path d="M6 6.5v3.5l3.5-1.75z" fill="currentColor" stroke="none"/></svg> MP4 Video</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="tool-group">
                <div class="dropdown-container">
                    <button id="brushTool" class="active" title="Brush (B)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10.5 1.5l4 4-8 8H2.5v-4z"/><path d="M8.5 3.5l4 4"/></svg> <span class="btn-label">Brush ▼</span></button>
                    <div class="brush-dropdown" id="brushDropdown">
                        <div class="brush-setting-row">
                            <label>Pressure:</label>
                            <input type="checkbox" id="pressureEnabled" checked>
                        </div>
                        <div class="brush-setting-row">
                            <label>Shape:</label>
                            <div class="shape-picker" id="brushShapePicker">
                                <div class="shape-icon active" data-shape="round" title="Round">
                                    <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="square" title="Square">
                                    <svg viewBox="0 0 20 20"><rect x="2" y="2" width="16" height="16" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-h" title="Horizontal Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="9" ry="4" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-v" title="Vertical Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="4" ry="9" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                            </div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Diameter:</label>
                            <input type="range" id="brushDiameter" min="1" max="100" value="8">
                            <span class="brush-setting-value" id="brushDiameterValue">8</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Smoothing:</label>
                            <input type="range" id="brushSmoothing" min="0" max="100" value="50">
                            <span class="brush-setting-value" id="brushSmoothingValue">50%</span>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="eraserTool" title="Eraser (E)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 14h8"/><path d="M3.5 10l6.5-6.5 3.5 3.5-5 5H5l-1.5-1.5z"/><path d="M10 3.5l3.5 3.5"/></svg> <span class="btn-label">Eraser ▼</span></button>
                    <div class="brush-dropdown" id="eraserDropdown">
                        <div class="brush-setting-row">
                            <label>Pressure:</label>
                            <input type="checkbox" id="eraserPressureEnabled" checked>
                        </div>
                        <div class="brush-setting-row">
                            <label>Shape:</label>
                            <div class="shape-picker" id="eraserShapePicker">
                                <div class="shape-icon active" data-shape="round" title="Round">
                                    <svg viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="square" title="Square">
                                    <svg viewBox="0 0 20 20"><rect x="2" y="2" width="16" height="16" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-h" title="Horizontal Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="9" ry="4" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                                <div class="shape-icon" data-shape="oval-v" title="Vertical Oval">
                                    <svg viewBox="0 0 20 20"><ellipse cx="10" cy="10" rx="4" ry="9" fill="#ccc" stroke="#888" stroke-width="1"/></svg>
                                </div>
                            </div>
                        </div>
                        <div class="brush-setting-row">
                            <label>Diameter:</label>
                            <input type="range" id="eraserDiameter" min="1" max="100" value="8">
                            <span class="brush-setting-value" id="eraserDiameterValue">8</span>
                        </div>
                        <div class="brush-setting-row">
                            <label>Smoothing:</label>
                            <input type="range" id="eraserSmoothing" min="0" max="100" value="0">
                            <span class="brush-setting-value" id="eraserSmoothingValue">0%</span>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="shapeTool" title="Shapes"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="1.5" y="1.5" width="6" height="6" rx="0.5"/><circle cx="11" cy="11" r="3.5"/></svg> <span class="btn-label">Shapes ▼</span></button>
                    <div class="dropdown-menu" id="shapeDropdown">
                        <button class="dropdown-item" data-shape="line"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M3 13L13 3"/></svg> Line</button>
                        <button class="dropdown-item" data-shape="rect"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="10" height="8" rx="0.5"/></svg> Rectangle</button>
                        <button class="dropdown-item" data-shape="circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7.5" r="5"/></svg> Circle</button>
                        <button class="dropdown-item" data-shape="triangle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M7 2l6 11H1z"/></svg> Triangle</button>
                    </div>
                </div>
                <button id="fillTool" title="Paint Bucket (K / F)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2C8 2 3 7.5 3 10.5a5 5 0 0010 0C13 7.5 8 2 8 2z" fill="currentColor"/></svg> <span class="btn-label">Fill</span></button>
                <button id="lassoTool" title="Lasso Selection (L)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="8" cy="7" rx="6" ry="4.5"/><path d="M12.5 10c0 1.5-1 3-2 3.5s-1.5.5-1.5 1.5"/></svg> <span class="btn-label">Lasso</span></button>
                <div class="dropdown-container">
                    <button id="transformTool" title="Free Transform (V/T)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2.5" y="2.5" width="11" height="11" rx="0.5" stroke-dasharray="2 2"/><circle cx="2.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg> <span class="btn-label">Transform ▼</span></button>
                    <div class="dropdown-menu" id="transformToolDropdown">
                        <button class="dropdown-item" data-xformtool="transform"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2.5" y="2.5" width="11" height="11" rx="0.5" stroke-dasharray="2 2"/><circle cx="2.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg> Free Transform <span class="shortcut">V</span></button>
                        <button class="dropdown-item" data-xformtool="scale"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M10 2h4v4"/><path d="M14 2l-4.5 4.5"/><path d="M6 14H2v-4"/><path d="M2 14l4.5-4.5"/></svg> Scale <span class="shortcut">S</span></button>
                        <button class="dropdown-item" data-xformtool="rotate"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M13.5 8A5.5 5.5 0 112.5 5.5"/><path d="M2.5 1.5v4h4"/></svg> Rotate <span class="shortcut">R</span></button>
                    </div>
                </div>
                <div class="dropdown-container">
                    <button id="navTool" title="Magnifier (Z)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg> <span class="btn-label">Magnifier ▼</span></button>
                    <div class="dropdown-menu" id="navToolDropdown">
                        <button class="dropdown-item" data-navtool="magnifier"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg> Zoom In <span class="shortcut">Z</span></button>
                        <button class="dropdown-item" data-navtool="magnifier-out"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7" r="5"/><path d="M5 7h4"/><path d="M11 11l3.5 3.5"/></svg> Zoom Out</button>
                        <div class="dropdown-divider"></div>
                        <button class="dropdown-item" data-navtool="pan"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M5.5 8V3.5a1 1 0 012 0V7"/><path d="M7.5 7V2.5a1 1 0 012 0V7"/><path d="M9.5 7V3.5a1 1 0 012 0V7"/><path d="M11.5 5.5a1 1 0 012 0V10c0 2.5-2 4.5-4.5 4.5h-1C6 14.5 4 12.5 4 10V8.5"/><path d="M5.5 8c0 0-2-1-2.5-2s0-2 1-1.5l1.5 1"/></svg> Pan / Hand <span class="shortcut">H</span></button>
                    </div>
                </div>
            </div>
            <div class="tool-group">
                <label>Color:</label>
                <input type="color" id="colorPicker" value="#000000">
                <label>Size:</label>
                <button class="size-step-btn" id="brushSizeMinus" title="Decrease brush size ([)">−</button>
                <input type="range" id="brushSize" min="1" max="100" value="8">
                <button class="size-step-btn" id="brushSizePlus" title="Increase brush size (])">+</button>
                <span id="sizeValue">8</span>
            </div>
            <div class="tool-group">
                <button id="copyBtn" title="Copy (Ctrl+C)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="1.5" width="9" height="11" rx="1"/><path d="M2 4.5v9a1 1 0 001 1h7"/></svg> <span class="btn-label">Copy</span></button>
                <button id="pasteBtn" title="Paste (Ctrl+V)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3.5" width="10" height="11" rx="1"/><path d="M6 3.5V2.5a1 1 0 011-1h2a1 1 0 011 1v1"/></svg> <span class="btn-label">Paste</span></button>
                <button id="pasteInPlaceBtn" title="Paste in Place (Ctrl+Shift+V)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3.5" width="10" height="11" rx="1"/><path d="M6 3.5V2.5a1 1 0 011-1h2a1 1 0 011 1v1"/><path d="M8 7v4m-2-2h4"/></svg> <span class="btn-label">Paste in Place</span></button>
                <div class="dropdown-container">
                    <button id="onionSkinToggle" title="Onion Skin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M1 8s3-5 7-5 7 5 7 5-3 5-7 5S1 8 1 8z"/><circle cx="8" cy="8" r="2"/></svg> <span class="btn-label">Onion Skin ▼</span></button>
                    <div class="onion-skin-dropdown" id="onionSkinDropdown">
                        <div class="onion-setting-row">
                            <label>Enabled:</label>
                            <input type="checkbox" id="onionEnabled" checked>
                        </div>
                        <div class="onion-divider"></div>
                        <div class="onion-setting-row">
                            <label>Opacity:</label>
                            <input type="range" id="onionOpacity" min="5" max="80" value="30">
                            <span class="onion-setting-value" id="onionOpacityValue">30%</span>
                        </div>
                        <div class="onion-divider"></div>
                        <div class="onion-setting-row">
                            <label>Frames Before:</label>
                            <button class="size-step-btn" id="onionBeforeMinus" title="Decrease">−</button>
                            <input type="number" id="onionFramesBefore" min="0" max="10" value="1">
                            <button class="size-step-btn" id="onionBeforePlus" title="Increase">+</button>
                        </div>
                        <div class="onion-setting-row">
                            <label>Previous Color:</label>
                            <input type="color" id="onionPrevColor" value="#ff0000">
                        </div>
                        <div class="onion-divider"></div>
                        <div class="onion-setting-row">
                            <label>Frames After:</label>
                            <button class="size-step-btn" id="onionAfterMinus" title="Decrease">−</button>
                            <input type="number" id="onionFramesAfter" min="0" max="10" value="1">
                            <button class="size-step-btn" id="onionAfterPlus" title="Increase">+</button>
                        </div>
                        <div class="onion-setting-row">
                            <label>Next Color:</label>
                            <input type="color" id="onionNextColor" value="#00cc00">
                        </div>
                    </div>
                </div>
            </div>
            <div class="tool-group">
                <button id="undoBtn" title="Undo (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 6l-3 3 3 3"/><path d="M1 9h9a4 4 0 010 8H6"/></svg> <span class="btn-label">Undo</span></button>
                <button id="redoBtn" title="Redo (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 6l3 3-3 3"/><path d="M15 9H6a4 4 0 000 8h4"/></svg> <span class="btn-label">Redo</span></button>
            </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
            <!-- Canvas area -->
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="onionCanvas" width="960" height="540"></canvas>
                    <canvas id="mainCanvas" width="960" height="540"></canvas>
                    <canvas id="selectionCanvas" width="960" height="540"></canvas>
                    <div class="brush-cursor" id="brushCursor"></div>
                </div>
                <div class="magnifier-marquee" id="magnifierMarquee"></div>
            </div>
            <div class="zoom-controls" id="zoomControls">
                <button id="pillPanBtn" title="Pan / Hand (H)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5.5 8V3.5a1 1 0 012 0V7"/><path d="M7.5 7V2.5a1 1 0 012 0V7"/><path d="M9.5 7V3.5a1 1 0 012 0V7"/><path d="M11.5 5.5a1 1 0 012 0V10c0 2.5-2 4.5-4.5 4.5h-1C6 14.5 4 12.5 4 10V8.5"/><path d="M5.5 8c0 0-2-1-2.5-2s0-2 1-1.5l1.5 1"/></svg></button>
                <div class="pill-divider"></div>
                <button id="zoomOutBtn" title="Zoom Out (−)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M5 7h4"/><path d="M11 11l3.5 3.5"/></svg></button>
                <span id="zoomLevel" class="zoom-label">100%</span>
                <button id="zoomInBtn" title="Zoom In (+)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg></button>
                <button id="zoomFitBtn" title="Fit to Screen (0)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M2 6V2h4M10 2h4v4M14 10v4h-4M6 14H2v-4"/></svg></button>
            </div>
        </div>

        <!-- Combined Timeline & Layers Panel -->
        <div class="timeline" id="timelinePanel">
            <div class="timeline-resize-handle" id="timelineResizeHandle"></div>
            <div class="timeline-header">
                <div class="timeline-controls">
                    <div class="playback-controls">
                        <button id="playBtn" title="Play (Space)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 2.5v11l9-5.5z" fill="currentColor" stroke="none"/></svg> <span class="btn-label">Play</span></button>
                        <button id="stopBtn" title="Stop (Space)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="10" height="10" rx="1" fill="currentColor" stroke="none"/></svg> <span class="btn-label">Stop</span></button>
                        <button id="prevFrame" title="Previous Frame (,)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M10 3L5 8l5 5"/></svg></button>
                        <button id="nextFrame" title="Next Frame (.)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M6 3l5 5-5 5"/></svg></button>
                        <button id="insertFrame" title="Insert Frame (F6)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v10M3 8h10"/></svg> <span class="btn-label">Insert</span></button>
                        <button id="duplicateFrame" title="Duplicate Frame (Ctrl+D)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="1.5" y="4" width="8" height="8" rx="1"/><rect x="5.5" y="1" width="8" height="8" rx="1"/></svg> <span class="btn-label">Duplicate</span></button>
                        <button id="clearFrame" title="Clear Frame (Backspace)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="8" r="6"/><path d="M5.5 5.5l5 5M10.5 5.5l-5 5"/></svg> <span class="btn-label">Clear</span></button>
                        <button id="deleteFrame" title="Delete Frame (F7)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M2 4h12M6 4V2.5h4V4M5 4v9h6V4"/><path d="M7 7v3M9 7v3"/></svg> <span class="btn-label">Delete</span></button>
                    </div>
                    <div class="fps-control">
                        <label>FPS:</label>
                        <input type="number" id="fpsInput" min="1" max="60" value="12" style="width: 50px;">
                    </div>
                </div>
            </div>
            <div class="timeline-body">
                <div class="timeline-layers-section" id="layersSection">
                    <div class="layers-header">
                        <span>Layers</span>
                        <div class="layer-buttons">
                            <button class="add-layer-btn-inline" id="addLayerBtn" title="Add Layer">+</button>
                            <button class="add-layer-btn-inline" id="duplicateLayerBtn" title="Duplicate Layer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="4" width="7" height="7" rx="1"/><rect x="5" y="1" width="7" height="7" rx="1"/></svg></button>
                            <button class="delete-layer-btn-inline" id="deleteLayerBtn" title="Delete Layer">-</button>
                        </div>
                    </div>
                    <div class="layers-list" id="layersList"></div>
                    <div class="layer-panel-resize-handle" id="layerPanelResizeHandle"></div>
                </div>
                <div class="timeline-frames-section">
                    <div class="frames-container" id="framesContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Frame context menu -->
    <input type="file" id="loadProjectInput" accept=".fby" style="display: none;">
    <input type="file" id="importSequenceInput" accept="image/png,image/jpeg,image/gif,image/webp,image/bmp,image/tiff" multiple style="display: none;">
    <div class="frame-context-menu" id="frameContextMenu">
        <button class="frame-context-menu-item" id="ctxCopyFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="5" y="1.5" width="8" height="10" rx="1"/><path d="M2 4v8a1 1 0 001 1h6"/></svg> Copy Frame<span class="shortcut">Ctrl+C</span></button>
        <button class="frame-context-menu-item" id="ctxPasteFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="3" y="3" width="9" height="10" rx="1"/><path d="M5.5 3V2a1 1 0 011-1h2a1 1 0 011 1v1"/></svg> Paste Frame<span class="shortcut">Ctrl+V</span></button>
        <div class="frame-context-menu-divider"></div>
        <button class="frame-context-menu-item" id="ctxDuplicateFrame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="1" y="4" width="7" height="7" rx="1"/><rect x="5" y="1" width="7" height="7" rx="1"/></svg> Duplicate Frame<span class="shortcut">Ctrl+D</span></button>
    </div>

    <!-- Canvas Size Modal -->
    <div class="modal-overlay" id="canvasSizeModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>Canvas Size</h3>
                <button class="modal-close" id="canvasSizeClose">×</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label>Preset:</label>
                    <select id="canvasPreset">
                        <option value="custom">Custom</option>
                        <optgroup label="Landscape">
                            <option value="1920x1080">1920 × 1080 (Full HD)</option>
                            <option value="1280x720">1280 × 720 (HD)</option>
                            <option value="960x540">960 × 540 (Default)</option>
                            <option value="3840x2160">3840 × 2160 (4K)</option>
                            <option value="2048x1080">2048 × 1080 (DCI 2K)</option>
                            <option value="4096x2160">4096 × 2160 (DCI 4K)</option>
                        </optgroup>
                        <optgroup label="Square">
                            <option value="1080x1080">1080 × 1080 (Instagram)</option>
                            <option value="512x512">512 × 512</option>
                            <option value="1024x1024">1024 × 1024</option>
                        </optgroup>
                        <optgroup label="Portrait">
                            <option value="1080x1920">1080 × 1920 (Vertical HD)</option>
                            <option value="1080x1350">1080 × 1350 (4:5)</option>
                        </optgroup>
                    </select>
                </div>
                <div class="modal-row modal-size-row">
                    <div class="modal-field">
                        <label for="canvasWidthInput">Width</label>
                        <div class="modal-input-wrap">
                            <input type="number" id="canvasWidthInput" min="1" max="7680" value="960">
                            <span class="modal-unit">px</span>
                        </div>
                    </div>
                    <button class="modal-link-btn" id="canvasLinkBtn" title="Lock aspect ratio">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5 6V5a3 3 0 016 0v1"/><rect x="3" y="6" width="10" height="8" rx="1.5"/></svg>
                    </button>
                    <div class="modal-field">
                        <label for="canvasHeightInput">Height</label>
                        <div class="modal-input-wrap">
                            <input type="number" id="canvasHeightInput" min="1" max="7680" value="540">
                            <span class="modal-unit">px</span>
                        </div>
                    </div>
                </div>
                <div class="modal-row">
                    <label>Resize mode:</label>
                    <select id="canvasResizeMode">
                        <option value="scale">Scale content to fit</option>
                        <option value="crop-center">Crop / Expand (Center)</option>
                        <option value="crop-tl">Crop / Expand (Top-Left)</option>
                    </select>
                </div>
                <div class="modal-info" id="canvasSizeInfo"></div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-cancel" id="canvasSizeCancel">Cancel</button>
                <button class="modal-btn modal-btn-apply" id="canvasSizeApply">Apply</button>
            </div>
        </div>
    </div>

    <script>
        // FrameBoy App
        class FrameBoy {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.onionCanvas = document.getElementById('onionCanvas');
                this.onionCtx = this.onionCanvas.getContext('2d');
                this.selectionCanvas = document.getElementById('selectionCanvas');
                this.selectionCtx = this.selectionCanvas.getContext('2d');
                this.brushCursor = document.getElementById('brushCursor');
                
                this.layers = [{ id: 1, name: 'Layer 1', visible: true, opacity: 1.0, frames: [] }];
                this.currentLayerId = 1;
                this.currentFrameIndex = 0;
                this.nextLayerId = 2;
                
                this.tool = 'brush';
                this.color = '#000000';
                this.brushSize = 8;
                this.brushShape = 'round';    // 'round', 'square', 'oval-h', 'oval-v'
                this.eraserShape = 'round';
                this.brushSmoothing = 50;      // 0-100
                this.eraserSmoothing = 0;
                this.smoothPoints = [];       // Buffer for smoothing
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.onionSkinEnabled = true;
                this.onionSkinOpacity = 0.30;
                this.onionFramesBefore = 1;
                this.onionFramesAfter = 1;
                this.onionPrevColor = '#ff0000';
                this.onionNextColor = '#00cc00';
                this.isPlaying = false;
                this.fps = 12;
                this.playbackInterval = null;
                
                // Zoom state
                this.zoomLevel = null; // null = fit-to-screen mode
                this.zoomSteps = [0.125, 0.167, 0.25, 0.333, 0.5, 0.667, 1, 1.5, 2, 3, 4, 6, 8, 12, 16];
                this.canvasWrapper = document.getElementById('canvasWrapper');
                this.canvasContainer = document.getElementById('canvasContainer');
                
                this.shapeStart = null;
                
                // Panning state
                this.isPanning = false;
                this._spaceHeld = false;
                this._panStart = null;
                this._scrollStart = null;
                this._toolBeforeSpace = null;
                this._spaceDidPan = false;
                
                // Magnifier state
                this._magnifying = false;
                this._magStart = null;
                this._magAlt = false;
                this._magDidDrag = false;
                
                // Undo/Redo stacks
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistorySize = 30;
                
                // Drag and drop properties
                this.draggedFrameIndex = null;
                this.dropTargetIndex = null;
                this._layerDragId = null;
                this._layerDropTarget = null;
                this._layerDropPos = null;
                this._layerDragDidMove = false;
                this._layerDragStartY = 0;
                
                // Lasso and selection properties
                this.lassoPath = [];
                this.selection = null; // {imageData, bounds: {x, y, width, height}}
                this.isTransforming = false;
                this.isRotating = false;
                this.rotationMode = false; // Track if we're in rotation mode
                this.hoverHandle = null; // Track which handle is being hovered
                this.hoverTimer = null; // Timer for hover detection
                this.transformHandles = [];
                this.activeHandle = null;
                this.transformStart = null;
                this._activeTransformTool = 'transform'; // 'transform', 'scale', 'rotate'
                
                // Clipboard properties
                this.copiedSelection = null; // For selection copy/paste
                this.copiedFrame = null; // For frame copy/paste
                this.contextMenuFrameIndex = null; // Track which frame was right-clicked
                this.selectionUndoStack = []; // Transform-level undo within floating selection
                this.selectionRedoStack = []; // Transform-level redo within floating selection
                
                // Apple Pencil / Pointer properties
                this.currentPressure = 0.5;
                this.pointerType = 'mouse'; // 'pen', 'touch', 'mouse'
                this.pressureEnabled = true;
                this.hasStylusInput = false; // True once we detect real pen/stylus pressure (for pressure detection)
                this.strokeStateSaved = false; // Track if we've saved undo state for current stroke
                this._pendingSaveTimer = null; // Track async saveState timer
                this.activePointerId = null; // Track which pointer is currently drawing
                
                this.initializeFrame();
                this.setupEventListeners();
                this.updateUndoRedoButtons();
                this.positionOnionCanvas();
                this.render();
                
                // Set initial cursor for brush tool
                this.canvas.style.cursor = 'none';
                this.selectionCanvas.style.cursor = 'none';
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.applyZoom();
                    this.render();
                });
                
                // Mobile Safari viewport fix: track actual visible height
                // Safari's 100vh includes the area behind the URL bar
                const updateVH = () => {
                    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                    document.documentElement.style.setProperty('--app-height', vh + 'px');
                };
                updateVH();
                window.addEventListener('resize', updateVH);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', updateVH);
                }
                
                // Layer panel resize handle
                this.setupLayerPanelResize();
                this.setupTimelineResize();
            }
            
            setupLayerPanelResize() {
                const resizeHandle = document.getElementById('layerPanelResizeHandle');
                const layersSection = document.getElementById('layersSection');
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;
                
                const onPointerDown = (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = layersSection.offsetWidth;
                    e.preventDefault();
                    resizeHandle.setPointerCapture(e.pointerId);
                };
                
                const onPointerMove = (e) => {
                    if (!isResizing) return;
                    
                    const deltaX = e.clientX - startX;
                    const newWidth = Math.max(160, Math.min(400, startWidth + deltaX));
                    layersSection.style.width = newWidth + 'px';
                };
                
                const onPointerUp = (e) => {
                    if (!isResizing) return;
                    isResizing = false;
                    resizeHandle.releasePointerCapture(e.pointerId);
                };
                
                resizeHandle.addEventListener('pointerdown', onPointerDown);
                resizeHandle.addEventListener('pointermove', onPointerMove);
                resizeHandle.addEventListener('pointerup', onPointerUp);
                resizeHandle.addEventListener('pointercancel', onPointerUp);
            }
            
            setupTimelineResize() {
                const handle = document.getElementById('timelineResizeHandle');
                const timeline = document.getElementById('timelinePanel');
                let startY = 0;
                let startH = 0;
                
                handle.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    handle.setPointerCapture(e.pointerId);
                    startY = e.clientY;
                    startH = timeline.offsetHeight;
                });
                
                handle.addEventListener('pointermove', (e) => {
                    if (!handle.hasPointerCapture(e.pointerId)) return;
                    const delta = startY - e.clientY; // drag up = bigger
                    const newH = Math.max(100, Math.min(window.innerHeight * 0.7, startH + delta));
                    timeline.style.height = newH + 'px';
                    timeline.style.minHeight = newH + 'px';
                    timeline.style.maxHeight = newH + 'px';
                });
                
                const onUp = (e) => {
                    if (handle.hasPointerCapture(e.pointerId)) {
                        handle.releasePointerCapture(e.pointerId);
                        // Refresh canvas zoom after resize
                        this.applyZoom();
                        this.render();
                    }
                };
                handle.addEventListener('pointerup', onUp);
                handle.addEventListener('pointercancel', onUp);
            }
            
            positionOnionCanvas() {
                // Delegates to applyZoom which handles both sizing and positioning
                this.applyZoom();
            }
            
            getEffectiveZoom() {
                if (this.zoomLevel !== null) return this.zoomLevel;
                // Fit-to-screen: compute zoom that fits canvas in container with padding
                const container = this.canvasContainer;
                const padX = 20, padY = 20;
                const availW = container.clientWidth - padX;
                const availH = container.clientHeight - padY;
                if (availW <= 0 || availH <= 0) return 1;
                const scaleW = availW / this.canvas.width;
                const scaleH = availH / this.canvas.height;
                return Math.min(scaleW, scaleH, 1); // Don't upscale past 100% in fit mode
            }
            
            applyZoom(centerOnPoint) {
                const zoom = this.getEffectiveZoom();
                const w = Math.round(this.canvas.width * zoom);
                const h = Math.round(this.canvas.height * zoom);
                const container = this.canvasContainer;
                
                // If zoomed content is smaller than container, center it with padding
                const isFitting = w < container.clientWidth && h < container.clientHeight;
                
                // Set wrapper size
                this.canvasWrapper.style.width = w + 'px';
                this.canvasWrapper.style.height = h + 'px';
                
                if (isFitting) {
                    // Center the wrapper using padding/margin
                    const mx = Math.max(0, (container.clientWidth - w) / 2);
                    const my = Math.max(0, (container.clientHeight - h) / 2);
                    this.canvasWrapper.style.margin = my + 'px ' + mx + 'px';
                } else {
                    this.canvasWrapper.style.margin = '10px';
                }
                
                // Size all canvases to wrapper
                const canvases = [this.canvas, this.onionCanvas, this.selectionCanvas];
                for (const c of canvases) {
                    c.style.width = w + 'px';
                    c.style.height = h + 'px';
                }
                
                // Position overlay canvases at 0,0 within wrapper
                this.onionCanvas.style.left = '0px';
                this.onionCanvas.style.top = '0px';
                this.selectionCanvas.style.left = '0px';
                this.selectionCanvas.style.top = '0px';
                
                // Update zoom label
                const pct = Math.round(zoom * 100);
                document.getElementById('zoomLevel').textContent = pct + '%';
            }
            
            setZoom(level, centerOnMouse) {
                // Clamp to step range
                const min = this.zoomSteps[0];
                const max = this.zoomSteps[this.zoomSteps.length - 1];
                this.zoomLevel = Math.max(min, Math.min(max, level));
                
                const container = this.canvasContainer;
                const cw = container.clientWidth;
                const ch = container.clientHeight;
                const oldZoom = this._prevZoom || this.getEffectiveZoom();
                
                // Compute old margin mathematically
                const oldW = Math.round(this.canvas.width * oldZoom);
                const oldH = Math.round(this.canvas.height * oldZoom);
                const oldFits = oldW < cw && oldH < ch;
                const oldML = oldFits ? Math.max(0, (cw - oldW) / 2) : 10;
                const oldMT = oldFits ? Math.max(0, (ch - oldH) / 2) : 10;
                
                // Canvas-space point at viewport center
                const viewCX = container.scrollLeft + cw / 2;
                const viewCY = container.scrollTop + ch / 2;
                const canvasX = (viewCX - oldML) / oldZoom;
                const canvasY = (viewCY - oldMT) / oldZoom;
                
                // Clamp to canvas bounds so we always center sensibly
                const clampedX = Math.max(0, Math.min(this.canvas.width, canvasX));
                const clampedY = Math.max(0, Math.min(this.canvas.height, canvasY));
                
                this.applyZoom();
                
                const newZoom = this.getEffectiveZoom();
                
                // Compute new margin mathematically
                const newW = Math.round(this.canvas.width * newZoom);
                const newH = Math.round(this.canvas.height * newZoom);
                const newFits = newW < cw && newH < ch;
                const newML = newFits ? Math.max(0, (cw - newW) / 2) : 10;
                const newMT = newFits ? Math.max(0, (ch - newH) / 2) : 10;
                
                // Scroll so the same canvas point stays at viewport center
                container.scrollLeft = newML + clampedX * newZoom - cw / 2;
                container.scrollTop = newMT + clampedY * newZoom - ch / 2;
                
                this._prevZoom = newZoom;
                this.updateBrushCursor();
            }
            
            zoomIn() {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                // Find next step above current
                for (const step of this.zoomSteps) {
                    if (step > current + 0.001) {
                        this.setZoom(step);
                        return;
                    }
                }
            }
            
            zoomOut() {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                // Find next step below current
                for (let i = this.zoomSteps.length - 1; i >= 0; i--) {
                    if (this.zoomSteps[i] < current - 0.001) {
                        this.setZoom(this.zoomSteps[i]);
                        return;
                    }
                }
            }
            
            zoomFit() {
                this.zoomLevel = null; // Back to fit-to-screen
                this._prevZoom = null;
                this.applyZoom();
                // Reset scroll to top-left (centering is handled by margin)
                this.canvasContainer.scrollLeft = 0;
                this.canvasContainer.scrollTop = 0;
                this.updateBrushCursor();
            }
            
            // === MAGNIFIER TOOL ===
            
            startMagnifier(clientX, clientY, altKey) {
                this._magnifying = true;
                this._magStart = { x: clientX, y: clientY };
                this._magAlt = altKey;
                this._magDidDrag = false;
                
                const marquee = document.getElementById('magnifierMarquee');
                marquee.style.display = 'none';
            }
            
            doMagnifier(clientX, clientY) {
                if (!this._magnifying || !this._magStart) return;
                
                const dx = clientX - this._magStart.x;
                const dy = clientY - this._magStart.y;
                
                // Only start marquee if dragged more than 4px (and zoom-in mode)
                if (Math.abs(dx) < 4 && Math.abs(dy) < 4) return;
                const isZoomOut = (this.tool === 'magnifier-out') !== (this._magAlt || false);
                if (isZoomOut) return; // No marquee for zoom-out
                
                this._magDidDrag = true;
                
                const container = this.canvasContainer;
                const containerRect = container.getBoundingClientRect();
                const marquee = document.getElementById('magnifierMarquee');
                
                // Compute marquee rect in container viewport coordinates
                const sx = this._magStart.x - containerRect.left + container.scrollLeft;
                const sy = this._magStart.y - containerRect.top + container.scrollTop;
                const ex = clientX - containerRect.left + container.scrollLeft;
                const ey = clientY - containerRect.top + container.scrollTop;
                
                const left = Math.min(sx, ex);
                const top = Math.min(sy, ey);
                const width = Math.abs(ex - sx);
                const height = Math.abs(ey - sy);
                
                marquee.style.display = 'block';
                marquee.style.left = left + 'px';
                marquee.style.top = top + 'px';
                marquee.style.width = width + 'px';
                marquee.style.height = height + 'px';
            }
            
            endMagnifier(clientX, clientY) {
                if (!this._magnifying) return;
                this._magnifying = false;
                
                const marquee = document.getElementById('magnifierMarquee');
                marquee.style.display = 'none';
                
                // Determine if this is a zoom-out action
                // Alt inverts: magnifier+alt=out, magnifier-out+alt=in
                const isZoomOut = (this.tool === 'magnifier-out') !== (this._magAlt || false);
                
                if (this._magDidDrag && !isZoomOut) {
                    // Marquee zoom: fit the selected area to the viewport
                    this._zoomToMarquee(this._magStart.x, this._magStart.y, clientX, clientY);
                } else {
                    // Single click zoom in or out
                    const container = this.canvasContainer;
                    const rect = this.canvas.getBoundingClientRect();
                    const oldZoom = this.getEffectiveZoom();
                    
                    const cx = clientX || this._magStart.x;
                    const cy = clientY || this._magStart.y;
                    
                    const canvasX = (cx - rect.left) / (rect.width / this.canvas.width);
                    const canvasY = (cy - rect.top) / (rect.height / this.canvas.height);
                    
                    const containerRect = container.getBoundingClientRect();
                    const viewX = cx - containerRect.left;
                    const viewY = cy - containerRect.top;
                    
                    if (isZoomOut) {
                        this.zoomOutAt(canvasX, canvasY, viewX, viewY, oldZoom);
                    } else {
                        this.zoomInAt(canvasX, canvasY, viewX, viewY, oldZoom);
                    }
                }
                
                this._magStart = null;
                this._magDidDrag = false;
            }
            
            _zoomToMarquee(startX, startY, endX, endY) {
                const rect = this.canvas.getBoundingClientRect();
                const container = this.canvasContainer;
                const containerRect = container.getBoundingClientRect();
                const currentZoom = this.getEffectiveZoom();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                // Convert screen coords to canvas coords
                const cx1 = (startX - rect.left) * scaleX;
                const cy1 = (startY - rect.top) * scaleY;
                const cx2 = (endX - rect.left) * scaleX;
                const cy2 = (endY - rect.top) * scaleY;
                
                const selLeft = Math.max(0, Math.min(cx1, cx2));
                const selTop = Math.max(0, Math.min(cy1, cy2));
                const selRight = Math.min(this.canvas.width, Math.max(cx1, cx2));
                const selBottom = Math.min(this.canvas.height, Math.max(cy1, cy2));
                const selW = selRight - selLeft;
                const selH = selBottom - selTop;
                
                if (selW < 2 || selH < 2) return; // Too small
                
                // Compute zoom to fit marquee area in viewport
                const viewW = container.clientWidth - 20;
                const viewH = container.clientHeight - 20;
                const fitZoom = Math.min(viewW / selW, viewH / selH);
                
                // Snap to nearest zoom step (round up to ensure area fits)
                const max = this.zoomSteps[this.zoomSteps.length - 1];
                const clampedZoom = Math.min(fitZoom, max);
                
                // Find best zoom step
                let bestStep = this.zoomSteps[0];
                for (const step of this.zoomSteps) {
                    if (step <= clampedZoom + 0.001) {
                        bestStep = step;
                    }
                }
                
                this._prevZoom = currentZoom;
                
                // Center of marquee in canvas coords
                const centerX = (selLeft + selRight) / 2;
                const centerY = (selTop + selBottom) / 2;
                
                // Apply zoom centered on the marquee center
                const viewCX = container.clientWidth / 2;
                const viewCY = container.clientHeight / 2;
                
                this._applyZoomAt(bestStep, centerX, centerY, viewCX, viewCY, currentZoom);
            }
            
            magnifierZoom(e) {
                // Legacy single-click path (kept for compatibility)
                const container = this.canvasContainer;
                const rect = this.canvas.getBoundingClientRect();
                const oldZoom = this.getEffectiveZoom();
                
                const canvasX = (e.clientX - rect.left) / (rect.width / this.canvas.width);
                const canvasY = (e.clientY - rect.top) / (rect.height / this.canvas.height);
                
                const containerRect = container.getBoundingClientRect();
                const viewX = e.clientX - containerRect.left;
                const viewY = e.clientY - containerRect.top;
                
                if (e.altKey) {
                    this.zoomOutAt(canvasX, canvasY, viewX, viewY, oldZoom);
                } else {
                    this.zoomInAt(canvasX, canvasY, viewX, viewY, oldZoom);
                }
            }
            
            zoomInAt(canvasX, canvasY, viewX, viewY, oldZoom) {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                let nextStep = null;
                for (const step of this.zoomSteps) {
                    if (step > current + 0.001) {
                        nextStep = step;
                        break;
                    }
                }
                if (nextStep === null) return; // Already at max
                this._applyZoomAt(nextStep, canvasX, canvasY, viewX, viewY, oldZoom);
            }
            
            zoomOutAt(canvasX, canvasY, viewX, viewY, oldZoom) {
                const current = this.getEffectiveZoom();
                this._prevZoom = current;
                let nextStep = null;
                for (let i = this.zoomSteps.length - 1; i >= 0; i--) {
                    if (this.zoomSteps[i] < current - 0.001) {
                        nextStep = this.zoomSteps[i];
                        break;
                    }
                }
                if (nextStep === null) return; // Already at min
                this._applyZoomAt(nextStep, canvasX, canvasY, viewX, viewY, oldZoom);
            }
            
            _applyZoomAt(newZoomLevel, canvasX, canvasY, viewX, viewY, oldZoom) {
                const container = this.canvasContainer;
                const min = this.zoomSteps[0];
                const max = this.zoomSteps[this.zoomSteps.length - 1];
                this.zoomLevel = Math.max(min, Math.min(max, newZoomLevel));
                
                this.applyZoom();
                
                const newZoom = this.getEffectiveZoom();
                
                // Compute where the same canvas point now sits in scrollable space
                // Account for wrapper margin (centering)
                const wrapper = this.canvasWrapper;
                const style = window.getComputedStyle(wrapper);
                const marginLeft = parseFloat(style.marginLeft) || 0;
                const marginTop = parseFloat(style.marginTop) || 0;
                
                const pointInScrollX = marginLeft + canvasX * newZoom;
                const pointInScrollY = marginTop + canvasY * newZoom;
                
                // Scroll so that point is back under the cursor
                container.scrollLeft = pointInScrollX - viewX;
                container.scrollTop = pointInScrollY - viewY;
                
                this._prevZoom = newZoom;
                this.updateBrushCursor();
            }
            
            // === PANNING ===
            
            startPan(clientX, clientY) {
                this.isPanning = true;
                this._panStart = { x: clientX, y: clientY };
                this._scrollStart = {
                    left: this.canvasContainer.scrollLeft,
                    top: this.canvasContainer.scrollTop
                };
                this.canvas.style.cursor = 'grabbing';
                this.selectionCanvas.style.cursor = 'grabbing';
            }
            
            doPan(clientX, clientY) {
                if (!this.isPanning || !this._panStart) return;
                const dx = clientX - this._panStart.x;
                const dy = clientY - this._panStart.y;
                this.canvasContainer.scrollLeft = this._scrollStart.left - dx;
                this.canvasContainer.scrollTop = this._scrollStart.top - dy;
            }
            
            stopPan() {
                this.isPanning = false;
                this._panStart = null;
                this._scrollStart = null;
                // Restore cursor
                if (this.tool === 'pan' || this._spaceHeld) {
                    this.canvas.style.cursor = 'grab';
                    this.selectionCanvas.style.cursor = 'grab';
                } else {
                    // Re-apply current tool cursor
                    this.selectTool(this.tool);
                }
            }
            
            _isPanActive() {
                return this.tool === 'pan' || this._spaceHeld;
            }
            
            initializeFrame() {
                const layer = this.getCurrentLayer();
                if (!layer.frames[this.currentFrameIndex]) {
                    layer.frames[this.currentFrameIndex] = this.createEmptyFrame();
                }
            }
            
            createEmptyFrame() {
                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = this.canvas.width;
                frameCanvas.height = this.canvas.height;
                return frameCanvas;
            }
            
            resizeCanvas(newW, newH, mode) {
                const oldW = this.canvas.width;
                const oldH = this.canvas.height;
                if (newW === oldW && newH === oldH) return;
                
                this.commitSelection();
                this.hideTransformHandles();
                
                // Resize every frame in every layer
                for (const layer of this.layers) {
                    for (let i = 0; i < layer.frames.length; i++) {
                        const oldFrame = layer.frames[i];
                        if (!oldFrame) continue;
                        
                        const newFrame = document.createElement('canvas');
                        newFrame.width = newW;
                        newFrame.height = newH;
                        const ctx = newFrame.getContext('2d');
                        
                        if (mode === 'scale') {
                            // Scale content to fill new size
                            ctx.drawImage(oldFrame, 0, 0, newW, newH);
                        } else if (mode === 'crop-center') {
                            // Place old content centered
                            const ox = Math.round((newW - oldW) / 2);
                            const oy = Math.round((newH - oldH) / 2);
                            ctx.drawImage(oldFrame, ox, oy);
                        } else {
                            // crop-tl: anchor top-left
                            ctx.drawImage(oldFrame, 0, 0);
                        }
                        
                        layer.frames[i] = newFrame;
                    }
                }
                
                // Resize the main canvases
                this.canvas.width = newW;
                this.canvas.height = newH;
                this.onionCanvas.width = newW;
                this.onionCanvas.height = newH;
                this.selectionCanvas.width = newW;
                this.selectionCanvas.height = newH;
                
                // Reset zoom to fit new canvas
                this.zoomLevel = null;
                this._prevZoom = null;
                this.applyZoom();
                this.canvasContainer.scrollLeft = 0;
                this.canvasContainer.scrollTop = 0;
                
                // Reset undo (frames have changed structure)
                this.undoStack = [];
                this.redoStack = [];
                this.selectionUndoStack = [];
                this.selectionRedoStack = [];
                this.updateUndoRedoButtons();
                
                this.positionOnionCanvas();
                this.render();
            }
            
            getCurrentLayer() {
                return this.layers.find(l => l.id === this.currentLayerId);
            }
            
            setupEventListeners() {
                // === DUAL EVENT SYSTEM ===
                // Desktop: Pointer events → e.pressure (Wacom, Surface Pen)
                // iPad:    Touch events → touch.force (Apple Pencil, fast!)
                // Touch preventDefault() on iPad blocks pointer events, preventing duplicates.
                
                const setupCanvasEvents = (canvasEl) => {
                    
                    // --- POINTER EVENTS (Desktop: Wacom, Surface Pen, Mouse) ---
                    // On iPad these get blocked by touch preventDefault()
                    
                    canvasEl.addEventListener('pointerdown', (e) => {
                        // Middle mouse button always pans
                        if (e.button === 1) {
                            e.preventDefault();
                            this.startPan(e.clientX, e.clientY);
                            return;
                        }
                        // Pan tool or space held — pan instead of draw
                        if (this._isPanActive()) {
                            e.preventDefault();
                            this.startPan(e.clientX, e.clientY);
                            this._spaceDidPan = true;
                            return;
                        }
                        // Magnifier tool — start marquee or click zoom
                        if (this.tool === 'magnifier' || this.tool === 'magnifier-out') {
                            e.preventDefault();
                            this.startMagnifier(e.clientX, e.clientY, e.altKey);
                            return;
                        }
                        this.pointerType = e.pointerType;
                        if (e.pointerType === 'pen') {
                            this.hasStylusInput = true;
                            this.currentPressure = e.pressure > 0 ? e.pressure : 0.5;
                        } else if (e.pointerType === 'mouse') {
                            this.currentPressure = 0.5;
                        }
                        this.startDrawing(e);
                    });
                    
                    canvasEl.addEventListener('pointermove', (e) => {
                        if (this.isPanning) {
                            e.preventDefault();
                            this.doPan(e.clientX, e.clientY);
                            return;
                        }
                        if (this._magnifying) {
                            e.preventDefault();
                            this.doMagnifier(e.clientX, e.clientY);
                            return;
                        }
                        if (e.pointerType === 'pen' && e.pressure > 0) {
                            this.currentPressure = e.pressure;
                        }
                        // Track when pointer leaves canvas bounds during a stroke
                        if (this.isDrawing && (this.tool === 'brush' || this.tool === 'eraser')) {
                            const cr = this.canvasWrapper.getBoundingClientRect();
                            if (e.clientX < cr.left || e.clientX > cr.right || e.clientY < cr.top || e.clientY > cr.bottom) {
                                this._pointerOffCanvas = true;
                                return;
                            }
                        }
                        this.draw(e);
                    });
                    
                    canvasEl.addEventListener('pointerup', (e) => {
                        if (this.isPanning) {
                            this.stopPan();
                            return;
                        }
                        if (this._magnifying) {
                            this.endMagnifier(e.clientX, e.clientY);
                            return;
                        }
                        this.stopDrawing();
                    });
                    
                    canvasEl.addEventListener('pointercancel', (e) => {
                        if (this.isPanning) {
                            this.stopPan();
                            return;
                        }
                        if (this._magnifying) {
                            this._magnifying = false;
                            this._magStart = null;
                            document.getElementById('magnifierMarquee').style.display = 'none';
                            return;
                        }
                        this.stopDrawing();
                    });
                    
                    // --- TOUCH EVENTS (iPad: Apple Pencil + Finger) ---
                    // These fire FIRST on iPad. preventDefault() blocks pointer events.
                    // Result: iPad uses fast touch path, desktop uses pointer path.
                    
                    canvasEl.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Block pointer events on iPad!
                        
                        // Two-finger touch = always pan
                        if (e.touches.length === 2) {
                            const mid = {
                                x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                                y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                            };
                            this.startPan(mid.x, mid.y);
                            this._touchPanFingers = 2;
                            return;
                        }
                        
                        const touch = e.touches[0];
                        if (!touch) return;
                        
                        // Pan tool active — pan with single finger
                        if (this._isPanActive()) {
                            this.startPan(touch.clientX, touch.clientY);
                            this._spaceDidPan = true;
                            return;
                        }
                        
                        // Magnifier tool — start marquee or click zoom at touch point
                        if (this.tool === 'magnifier' || this.tool === 'magnifier-out') {
                            this.startMagnifier(touch.clientX, touch.clientY, false);
                            return;
                        }
                        
                        if (touch.touchType === 'stylus') {
                            this.hasStylusInput = true;
                            this.pointerType = 'pen';
                            this.currentPressure = touch.force > 0 ? touch.force : 0.5;
                        } else {
                            // Palm rejection: once Apple Pencil is detected, ignore
                            // finger/knuckle touches for drawing (still works for pan/zoom above)
                            if (this.hasStylusInput) return;
                            this.pointerType = 'touch';
                            this.currentPressure = 0.5;
                        }
                        
                        this.startDrawing({
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: canvasEl
                        });
                    }, { passive: false });
                    
                    canvasEl.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        
                        // Two-finger pan
                        if (this.isPanning && e.touches.length >= 2) {
                            const mid = {
                                x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                                y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                            };
                            this.doPan(mid.x, mid.y);
                            return;
                        }
                        
                        // Single-finger pan (pan tool)
                        if (this.isPanning) {
                            const touch = e.touches[0];
                            if (touch) this.doPan(touch.clientX, touch.clientY);
                            return;
                        }
                        
                        // Magnifier marquee drag
                        if (this._magnifying) {
                            const touch = e.touches[0];
                            if (touch) this.doMagnifier(touch.clientX, touch.clientY);
                            return;
                        }
                        
                        if (!this.isDrawing && !this.isTransforming) return;
                        const touch = e.touches[0];
                        if (!touch) return;
                        
                        if (touch.touchType === 'stylus' && touch.force > 0) {
                            this.currentPressure = touch.force;
                        }
                        
                        // Track when touch leaves canvas bounds during a stroke
                        if (this.isDrawing && (this.tool === 'brush' || this.tool === 'eraser')) {
                            const cr = this.canvasWrapper.getBoundingClientRect();
                            if (touch.clientX < cr.left || touch.clientX > cr.right || touch.clientY < cr.top || touch.clientY > cr.bottom) {
                                this._pointerOffCanvas = true;
                                return;
                            }
                        }
                        
                        this.draw({
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: canvasEl
                        });
                    }, { passive: false });
                    
                    canvasEl.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        if (this.isPanning) {
                            // If went from 2 fingers to 1, stay panning only if pan tool
                            if (e.touches.length === 0 || !this._isPanActive()) {
                                this.stopPan();
                                this._touchPanFingers = 0;
                            }
                            return;
                        }
                        if (this._magnifying) {
                            const ct = e.changedTouches[0];
                            this.endMagnifier(ct ? ct.clientX : null, ct ? ct.clientY : null);
                            return;
                        }
                        this.stopDrawing();
                    }, { passive: false });
                    
                    canvasEl.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        if (this.isPanning) {
                            this.stopPan();
                            this._touchPanFingers = 0;
                            return;
                        }
                        this.stopDrawing();
                    }, { passive: false });
                };
                
                setupCanvasEvents(this.canvas);
                setupCanvasEvents(this.selectionCanvas);
                
                // Document-level fallbacks — catch stylus lift outside canvas
                // Track pointer leaving canvas during active stroke
                document.addEventListener('pointermove', (e) => {
                    if (this.isDrawing && (this.tool === 'brush' || this.tool === 'eraser')) {
                        const target = e.target;
                        if (target !== this.canvas && target !== this.selectionCanvas) {
                            this._pointerOffCanvas = true;
                        }
                    }
                }, true);
                // Pointer path (desktop off-canvas lift)
                document.addEventListener('pointerup', (e) => {
                    if (this.isPanning) { this.stopPan(); return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                });
                document.addEventListener('pointercancel', (e) => {
                    if (this.isPanning) { this.stopPan(); return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                });
                // Touch path (iPad off-canvas lift)
                document.addEventListener('touchend', (e) => {
                    if (this.isPanning) { this.stopPan(); this._touchPanFingers = 0; return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                }, { passive: true });
                document.addEventListener('touchcancel', (e) => {
                    if (this.isPanning) { this.stopPan(); this._touchPanFingers = 0; return; }
                    if (this.isDrawing || this.isTransforming) {
                        this.stopDrawing();
                    }
                }, { passive: true });

                // Prevent iOS double-tap text selection menu and context menu
                const preventIOSMenus = (canvasEl) => {
                    canvasEl.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    canvasEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    // Prevent text selection that happens during fast drawing
                    canvasEl.addEventListener('selectstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    // Prevent long-press context menu on iOS
                    let longPressTimer = null;
                    canvasEl.addEventListener('touchstart', (e) => {
                        longPressTimer = setTimeout(() => {
                            // Cancel any context menu attempt
                            longPressTimer = null;
                        }, 500);
                    }, { passive: true });
                    
                    canvasEl.addEventListener('touchend', () => {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }, { passive: true });
                    
                    canvasEl.addEventListener('touchmove', () => {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }, { passive: true });
                };
                
                preventIOSMenus(this.canvas);
                preventIOSMenus(this.selectionCanvas);
                
                // Also prevent on canvas container
                const canvasArea = document.querySelector('.canvas-container');
                if (canvasArea) {
                    canvasArea.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    canvasArea.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                }
                
                // Tool selection
                const brushBtn = document.getElementById('brushTool');
                const brushDropdown = document.getElementById('brushDropdown');
                const eraserBtn = document.getElementById('eraserTool');
                const eraserDropdown = document.getElementById('eraserDropdown');
                
                brushBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectTool('brush');
                    brushDropdown.classList.toggle('show');
                    eraserDropdown.classList.remove('show');
                    document.getElementById('shapeDropdown').classList.remove('show');
                    document.getElementById('fileMenuDropdown').classList.remove('show');
                    document.getElementById('onionSkinDropdown').classList.remove('show');
                });
                
                eraserBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectTool('eraser');
                    eraserDropdown.classList.toggle('show');
                    brushDropdown.classList.remove('show');
                    document.getElementById('shapeDropdown').classList.remove('show');
                    document.getElementById('fileMenuDropdown').classList.remove('show');
                    document.getElementById('onionSkinDropdown').classList.remove('show');
                });
                
                // Prevent dropdown clicks from propagating
                brushDropdown.addEventListener('click', (e) => e.stopPropagation());
                eraserDropdown.addEventListener('click', (e) => e.stopPropagation());
                
                // Brush dropdown controls
                document.getElementById('brushShapePicker').querySelectorAll('.shape-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.brushShape = icon.dataset.shape;
                        document.getElementById('brushShapePicker').querySelectorAll('.shape-icon').forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        this.updateBrushCursor();
                    });
                });
                document.getElementById('brushDiameter').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushDiameterValue').textContent = this.brushSize;
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.updateBrushCursor();
                });
                document.getElementById('brushSmoothing').addEventListener('input', (e) => {
                    this.brushSmoothing = parseInt(e.target.value);
                    document.getElementById('brushSmoothingValue').textContent = e.target.value + '%';
                });
                
                // Pressure toggle — keep brush and eraser checkboxes synced
                const brushPressureCb = document.getElementById('pressureEnabled');
                const eraserPressureCb = document.getElementById('eraserPressureEnabled');
                brushPressureCb.addEventListener('change', (e) => {
                    this.pressureEnabled = e.target.checked;
                    eraserPressureCb.checked = e.target.checked;
                });
                eraserPressureCb.addEventListener('change', (e) => {
                    this.pressureEnabled = e.target.checked;
                    brushPressureCb.checked = e.target.checked;
                });
                
                // Eraser dropdown controls
                document.getElementById('eraserShapePicker').querySelectorAll('.shape-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.eraserShape = icon.dataset.shape;
                        document.getElementById('eraserShapePicker').querySelectorAll('.shape-icon').forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        this.updateBrushCursor();
                    });
                });
                document.getElementById('eraserDiameter').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('eraserDiameterValue').textContent = this.brushSize;
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.updateBrushCursor();
                });
                document.getElementById('eraserSmoothing').addEventListener('input', (e) => {
                    this.eraserSmoothing = parseInt(e.target.value);
                    document.getElementById('eraserSmoothingValue').textContent = e.target.value + '%';
                });

                document.getElementById('fillTool').addEventListener('click', () => this.selectTool('fill'));
                document.getElementById('lassoTool').addEventListener('click', () => this.selectTool('lasso'));
                // Transform tool dropdown
                const xformButton = document.getElementById('transformTool');
                const xformDropdown = document.getElementById('transformToolDropdown');
                
                xformButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate') {
                        xformDropdown.classList.toggle('show');
                    } else {
                        this.selectTool(this._activeTransformTool);
                    }
                });
                
                xformDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const xformtool = item.getAttribute('data-xformtool');
                        this._activeTransformTool = xformtool;
                        this.selectTool(xformtool);
                        xformDropdown.classList.remove('show');
                        this._updateTransformButton(xformtool);
                    });
                });
                
                // Navigation tool (Magnifier / Pan) dropdown
                const navButton = document.getElementById('navTool');
                const navDropdown = document.getElementById('navToolDropdown');
                this._activeNavTool = 'magnifier'; // Track which sub-tool is primary
                
                navButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // If already on a nav tool, toggle dropdown; otherwise activate current sub-tool
                    if (this.tool === 'magnifier' || this.tool === 'magnifier-out' || this.tool === 'pan') {
                        navDropdown.classList.toggle('show');
                    } else {
                        this.selectTool(this._activeNavTool);
                    }
                });
                
                navDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const navtool = item.getAttribute('data-navtool');
                        this._activeNavTool = navtool;
                        this.selectTool(navtool);
                        navDropdown.classList.remove('show');
                        this._updateNavButton(navtool);
                    });
                });
                
                // Brush cursor tracking
                const canvasContainer = document.getElementById('canvasContainer');
                canvasContainer.addEventListener('pointermove', (e) => {
                    if (this.tool === 'brush' || this.tool === 'eraser') {
                        this.brushCursor.style.display = 'block';
                        this.brushCursor.style.left = e.clientX + 'px';
                        this.brushCursor.style.top = e.clientY + 'px';
                        this.updateBrushCursor();
                    }
                });
                canvasContainer.addEventListener('pointerleave', () => {
                    this.brushCursor.style.display = 'none';
                });
                
                // Shapes dropdown
                const shapeButton = document.getElementById('shapeTool');
                const shapeDropdown = document.getElementById('shapeDropdown');
                
                shapeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    shapeDropdown.classList.toggle('show');
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', () => {
                    shapeDropdown.classList.remove('show');
                    onionDropdown.classList.remove('show');
                    brushDropdown.classList.remove('show');
                    eraserDropdown.classList.remove('show');
                    document.getElementById('fileMenuDropdown').classList.remove('show');
                    document.getElementById('navToolDropdown').classList.remove('show');
                });
                
                // Shape selection
                shapeDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const shape = item.getAttribute('data-shape');
                        this.selectTool(shape);
                        shapeDropdown.classList.remove('show');
                        
                        // Update button text to show selected shape
                        const icons = {
                            'line': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M3 13L13 3"/></svg>',
                            'rect': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><rect x="2" y="3" width="10" height="8" rx="0.5"/></svg>',
                            'circle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><circle cx="7" cy="7.5" r="5"/></svg>',
                            'triangle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" width="14" height="14"><path d="M7 2l6 11H1z"/></svg>'
                        };
                        shapeButton.innerHTML = `${icons[shape]} <span class="btn-label">${item.textContent.split(' ')[1]} ▼</span>`;
                    });
                });
                
                // Color and size
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.color = e.target.value;
                });
                
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.syncBrushSizeUI();
                    this.updateBrushCursor();
                });
                
                const stepBrushSize = (delta) => {
                    this.brushSize = Math.max(1, Math.min(100, this.brushSize + delta));
                    document.getElementById('brushSize').value = this.brushSize;
                    document.getElementById('sizeValue').textContent = this.brushSize;
                    this.syncBrushSizeUI();
                    this.updateBrushCursor();
                };
                document.getElementById('brushSizeMinus').addEventListener('click', () => stepBrushSize(-1));
                document.getElementById('brushSizePlus').addEventListener('click', () => stepBrushSize(1));
                
                // Frame controls
                document.getElementById('clearFrame').addEventListener('click', () => this.clearCurrentFrame());
                
                // Onion skin dropdown
                const onionBtn = document.getElementById('onionSkinToggle');
                const onionDropdown = document.getElementById('onionSkinDropdown');
                onionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    onionDropdown.classList.toggle('show');
                });
                onionDropdown.addEventListener('click', (e) => e.stopPropagation());
                
                document.getElementById('onionEnabled').addEventListener('change', (e) => {
                    this.onionSkinEnabled = e.target.checked;
                    onionBtn.style.opacity = this.onionSkinEnabled ? '1' : '0.5';
                    this.render();
                });
                document.getElementById('onionOpacity').addEventListener('input', (e) => {
                    this.onionSkinOpacity = parseInt(e.target.value) / 100;
                    document.getElementById('onionOpacityValue').textContent = e.target.value + '%';
                    this.render();
                });
                document.getElementById('onionFramesBefore').addEventListener('change', (e) => {
                    this.onionFramesBefore = parseInt(e.target.value);
                    this.render();
                });
                document.getElementById('onionBeforeMinus').addEventListener('click', () => {
                    const input = document.getElementById('onionFramesBefore');
                    input.value = Math.max(0, parseInt(input.value) - 1);
                    this.onionFramesBefore = parseInt(input.value);
                    this.render();
                });
                document.getElementById('onionBeforePlus').addEventListener('click', () => {
                    const input = document.getElementById('onionFramesBefore');
                    input.value = Math.min(10, parseInt(input.value) + 1);
                    this.onionFramesBefore = parseInt(input.value);
                    this.render();
                });
                document.getElementById('onionFramesAfter').addEventListener('change', (e) => {
                    this.onionFramesAfter = parseInt(e.target.value);
                    this.render();
                });
                document.getElementById('onionAfterMinus').addEventListener('click', () => {
                    const input = document.getElementById('onionFramesAfter');
                    input.value = Math.max(0, parseInt(input.value) - 1);
                    this.onionFramesAfter = parseInt(input.value);
                    this.render();
                });
                document.getElementById('onionAfterPlus').addEventListener('click', () => {
                    const input = document.getElementById('onionFramesAfter');
                    input.value = Math.min(10, parseInt(input.value) + 1);
                    this.onionFramesAfter = parseInt(input.value);
                    this.render();
                });
                document.getElementById('onionPrevColor').addEventListener('input', (e) => {
                    this.onionPrevColor = e.target.value;
                    this.render();
                });
                document.getElementById('onionNextColor').addEventListener('input', (e) => {
                    this.onionNextColor = e.target.value;
                    this.render();
                });
                
                // Copy/Paste buttons
                document.getElementById('copyBtn').addEventListener('click', () => {
                    if (this.selection) {
                        this.copySelection();
                    } else {
                        this.copyFrame();
                    }
                });
                document.getElementById('pasteBtn').addEventListener('click', () => {
                    if (this.copiedSelection) {
                        this.pasteSelection();
                    } else if (this.copiedFrame) {
                        this.pasteFrame();
                    }
                });
                document.getElementById('pasteInPlaceBtn').addEventListener('click', () => {
                    if (this.copiedSelection) {
                        this.pasteSelectionInPlace();
                    }
                });
                
                // Undo/Redo controls
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                
                // Zoom controls
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomFitBtn').addEventListener('click', () => this.zoomFit());
                
                // Pill pan button
                document.getElementById('pillPanBtn').addEventListener('click', () => {
                    if (this.tool === 'pan') {
                        this.selectTool('brush');
                    } else {
                        this.selectTool('pan');
                    }
                });
                
                // Ctrl/Cmd+Scroll wheel zoom (on canvas container only)
                this.canvasContainer.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.deltaY < 0) this.zoomIn();
                        else if (e.deltaY > 0) this.zoomOut();
                    }
                }, { passive: false });
                
                // Prevent middle-click auto-scroll on container
                this.canvasContainer.addEventListener('mousedown', (e) => {
                    if (e.button === 1) e.preventDefault();
                });
                
                // Keyboard shortcuts for undo/redo
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        this.saveProject();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                        e.preventDefault();
                        document.getElementById('loadProjectInput').click();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        this.redo();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        if (this.selection) {
                            this.copySelection();
                        } else {
                            this.copyFrame();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'v' || e.key === 'V')) {
                        e.preventDefault();
                        if (this.copiedSelection) {
                            this.pasteSelectionInPlace();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                        e.preventDefault();
                        if (this.copiedSelection) {
                            this.pasteSelection();
                        } else if (this.copiedFrame) {
                            this.pasteFrame();
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        this.duplicateFrame();
                    } else if ((e.ctrlKey || e.metaKey) && (e.key === '=' || e.key === '+')) {
                        e.preventDefault();
                        this.zoomIn();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                        e.preventDefault();
                        this.zoomOut();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                        e.preventDefault();
                        this.zoomFit();
                    } else if (e.key === 'Enter' && this.selection) {
                        e.preventDefault();
                        this.applySelection();
                        this.clearSelection();
                        this.selectTool('brush');
                    } else if (e.key === 'Escape' && this.selection) {
                        e.preventDefault();
                        this.clearSelection();
                        this.selectTool('brush');
                        this.render();
                    } else if ((e.key === 'Delete' || e.key === 'Backspace') && this.selection) {
                        e.preventDefault();
                        this.clearSelection();
                        this.render();
                    }
                    
                    // Single-key shortcuts (only when no modifier keys held, no modal open, no input focused)
                    const activeEl = document.activeElement;
                    const inputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'SELECT' || activeEl.tagName === 'TEXTAREA');
                    const modalOpen = document.querySelector('.modal-overlay.show');
                    if (!e.ctrlKey && !e.metaKey && !e.altKey && !inputFocused && !modalOpen) {
                        switch (e.key) {
                            case 'b':
                                e.preventDefault();
                                this.selectTool('brush');
                                break;
                            case 'e':
                                e.preventDefault();
                                this.selectTool('eraser');
                                break;
                            case 'f':
                            case 'k':
                                e.preventDefault();
                                this.selectTool('fill');
                                break;
                            case 'l':
                                e.preventDefault();
                                this.selectTool('lasso');
                                break;
                            case 'v':
                            case 't':
                                e.preventDefault();
                                this._activeTransformTool = 'transform';
                                this._updateTransformButton('transform');
                                this.selectTool('transform');
                                break;
                            case 's':
                                e.preventDefault();
                                this._activeTransformTool = 'scale';
                                this._updateTransformButton('scale');
                                this.selectTool('scale');
                                break;
                            case 'r':
                                e.preventDefault();
                                this._activeTransformTool = 'rotate';
                                this._updateTransformButton('rotate');
                                this.selectTool('rotate');
                                break;
                            case 'h':
                                e.preventDefault();
                                this._activeNavTool = 'pan';
                                this._updateNavButton('pan');
                                this.selectTool('pan');
                                break;
                            case 'z':
                                e.preventDefault();
                                this._activeNavTool = 'magnifier';
                                this._updateNavButton('magnifier');
                                this.selectTool('magnifier');
                                break;
                            case '[':
                                e.preventDefault();
                                this.brushSize = Math.max(1, this.brushSize - 1);
                                document.getElementById('brushSize').value = this.brushSize;
                                document.getElementById('sizeValue').textContent = this.brushSize;
                                this.syncBrushSizeUI();
                                this.updateBrushCursor();
                                break;
                            case ']':
                                e.preventDefault();
                                this.brushSize = Math.min(100, this.brushSize + 1);
                                document.getElementById('brushSize').value = this.brushSize;
                                document.getElementById('sizeValue').textContent = this.brushSize;
                                this.syncBrushSizeUI();
                                this.updateBrushCursor();
                                break;
                            case 'F5':
                                e.preventDefault();
                                this.duplicateFrame();
                                break;
                            case 'F6':
                                e.preventDefault();
                                this.insertFrameAfterCurrent();
                                break;
                            case 'F7':
                                e.preventDefault();
                                this.deleteCurrentFrame();
                                break;
                            case 'Backspace':
                                if (!this.selection) {
                                    e.preventDefault();
                                    this.clearCurrentFrame();
                                }
                                break;
                            case ' ':
                                e.preventDefault();
                                // Space hold = temporary pan mode
                                if (!this._spaceHeld) {
                                    this._spaceHeld = true;
                                    this._spaceDidPan = false;
                                    this._toolBeforeSpace = this.tool;
                                    this.canvas.style.cursor = 'grab';
                                    this.selectionCanvas.style.cursor = 'grab';
                                    this.brushCursor.style.display = 'none';
                                }
                                break;
                            case ',':
                                e.preventDefault();
                                this.previousFrame();
                                break;
                            case '.':
                                e.preventDefault();
                                this.goToNextFrame();
                                break;
                            case 'o':
                                e.preventDefault();
                                this.onionSkinEnabled = !this.onionSkinEnabled;
                                document.getElementById('onionEnabled').checked = this.onionSkinEnabled;
                                document.getElementById('onionSkinToggle').style.opacity = this.onionSkinEnabled ? '1' : '0.5';
                                this.render();
                                break;
                            case '=':
                            case '+':
                                e.preventDefault();
                                this.zoomIn();
                                break;
                            case '-':
                                e.preventDefault();
                                this.zoomOut();
                                break;
                            case '0':
                                e.preventDefault();
                                this.zoomFit();
                                break;
                        }
                    }
                });
                
                // Space keyup: if no drag happened, toggle play/stop. Restore previous tool.
                document.addEventListener('keyup', (e) => {
                    if (e.key === ' ' && this._spaceHeld) {
                        e.preventDefault();
                        this._spaceHeld = false;
                        if (this.isPanning) {
                            this.stopPan();
                        }
                        // If user didn't drag at all, treat as play/stop toggle
                        if (!this._spaceDidPan) {
                            if (this.isPlaying) {
                                this.stop();
                            } else {
                                this.play();
                            }
                        }
                        this._spaceDidPan = false;
                        // Restore cursor to previous tool
                        if (this._toolBeforeSpace && this.tool !== 'pan') {
                            this.selectTool(this._toolBeforeSpace);
                        } else if (this.tool !== 'pan') {
                            this.selectTool(this.tool);
                        }
                        this._toolBeforeSpace = null;
                    }
                    // Alt release: restore magnifier cursor
                    if (e.key === 'Alt' && (this.tool === 'magnifier' || this.tool === 'magnifier-out')) {
                        const cur = this.tool === 'magnifier' ? 'zoom-in' : 'zoom-out';
                        this.canvas.style.cursor = cur;
                        this.selectionCanvas.style.cursor = cur;
                    }
                });
                
                // Alt key toggles magnifier between zoom-in and zoom-out cursor
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Alt' && (this.tool === 'magnifier' || this.tool === 'magnifier-out')) {
                        e.preventDefault();
                        const cur = this.tool === 'magnifier' ? 'zoom-out' : 'zoom-in';
                        this.canvas.style.cursor = cur;
                        this.selectionCanvas.style.cursor = cur;
                    }
                }, true);
                
                // Playback controls
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('prevFrame').addEventListener('click', () => this.previousFrame());
                document.getElementById('nextFrame').addEventListener('click', () => this.nextFrame());
                document.getElementById('insertFrame').addEventListener('click', () => this.insertFrameAfterCurrent());
                document.getElementById('duplicateFrame').addEventListener('click', () => this.duplicateFrame());
                document.getElementById('deleteFrame').addEventListener('click', () => this.deleteCurrentFrame());
                document.getElementById('fpsInput').addEventListener('change', (e) => {
                    this.fps = parseInt(e.target.value);
                });
                
                // Frame context menu
                const ctxMenu = document.getElementById('frameContextMenu');
                document.getElementById('ctxCopyFrame').addEventListener('click', () => {
                    this.copyFrame(this.contextMenuFrameIndex);
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxPasteFrame').addEventListener('click', () => {
                    if (this.copiedFrame) {
                        this.pasteFrame(this.contextMenuFrameIndex);
                    }
                    ctxMenu.classList.remove('show');
                });
                document.getElementById('ctxDuplicateFrame').addEventListener('click', () => {
                    this.duplicateFrame(this.contextMenuFrameIndex);
                    ctxMenu.classList.remove('show');
                });
                
                // Close context menu on click outside
                document.addEventListener('click', () => {
                    ctxMenu.classList.remove('show');
                });
                
                // Layer controls
                document.getElementById('addLayerBtn').addEventListener('click', () => this.addLayer());
                document.getElementById('duplicateLayerBtn').addEventListener('click', () => this.duplicateLayer());
                document.getElementById('deleteLayerBtn').addEventListener('click', () => this.deleteLayer());
                
                // File menu (Save, Load, Export)
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const fileMenuDropdown = document.getElementById('fileMenuDropdown');
                fileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fileMenuDropdown.classList.toggle('show');
                });
                document.getElementById('saveProjectBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    this.saveProject();
                });
                document.getElementById('loadProjectBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.getElementById('loadProjectInput').click();
                });
                document.getElementById('loadProjectInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadProject(e.target.files[0]);
                        e.target.value = ''; // Reset so same file can be loaded again
                    }
                });
                document.getElementById('importSequenceBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    document.getElementById('importSequenceInput').click();
                });
                document.getElementById('importSequenceInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.importImageSequence(Array.from(e.target.files));
                        e.target.value = '';
                    }
                });
                document.getElementById('exportPngZip').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    this.exportGif();
                });
                document.getElementById('exportGifBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    this.exportAsGif();
                });
                document.getElementById('exportMp4Btn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    this.exportAsMp4();
                });
                
                // Touch support for Export submenu — toggle on tap since hover doesn't work on touch
                const submenuTrigger = document.querySelector('.submenu-trigger');
                if (submenuTrigger) {
                    submenuTrigger.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        const container = submenuTrigger.closest('.dropdown-submenu-container');
                        container.classList.toggle('touch-open');
                    });
                }
                
                // Canvas Size modal
                const csModal = document.getElementById('canvasSizeModal');
                const csWidthIn = document.getElementById('canvasWidthInput');
                const csHeightIn = document.getElementById('canvasHeightInput');
                const csPreset = document.getElementById('canvasPreset');
                const csLinkBtn = document.getElementById('canvasLinkBtn');
                const csInfo = document.getElementById('canvasSizeInfo');
                let csLinked = false;
                let csAspect = 1;
                
                const csUpdateInfo = () => {
                    const w = parseInt(csWidthIn.value) || 0;
                    const h = parseInt(csHeightIn.value) || 0;
                    const curW = this.canvas.width;
                    const curH = this.canvas.height;
                    if (w === curW && h === curH) {
                        csInfo.textContent = `Current size: ${curW} × ${curH}`;
                    } else {
                        csInfo.textContent = `${curW} × ${curH}  →  ${w} × ${h}`;
                    }
                };
                
                document.getElementById('canvasSizeBtn').addEventListener('click', () => {
                    fileMenuDropdown.classList.remove('show');
                    csWidthIn.value = this.canvas.width;
                    csHeightIn.value = this.canvas.height;
                    csPreset.value = 'custom';
                    csAspect = this.canvas.width / this.canvas.height;
                    csUpdateInfo();
                    csModal.classList.add('show');
                });
                
                const csClose = () => csModal.classList.remove('show');
                document.getElementById('canvasSizeClose').addEventListener('click', csClose);
                document.getElementById('canvasSizeCancel').addEventListener('click', csClose);
                csModal.addEventListener('click', (e) => { if (e.target === csModal) csClose(); });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && csModal.classList.contains('show')) {
                        e.preventDefault();
                        e.stopPropagation();
                        csClose();
                    }
                });
                
                csLinkBtn.addEventListener('click', () => {
                    csLinked = !csLinked;
                    csLinkBtn.classList.toggle('linked', csLinked);
                    if (csLinked) csAspect = (parseInt(csWidthIn.value) || 1) / (parseInt(csHeightIn.value) || 1);
                });
                
                csWidthIn.addEventListener('input', () => {
                    csPreset.value = 'custom';
                    if (csLinked) {
                        csHeightIn.value = Math.round((parseInt(csWidthIn.value) || 1) / csAspect);
                    }
                    csUpdateInfo();
                });
                csHeightIn.addEventListener('input', () => {
                    csPreset.value = 'custom';
                    if (csLinked) {
                        csWidthIn.value = Math.round((parseInt(csHeightIn.value) || 1) * csAspect);
                    }
                    csUpdateInfo();
                });
                
                csPreset.addEventListener('change', () => {
                    if (csPreset.value !== 'custom') {
                        const [w, h] = csPreset.value.split('x').map(Number);
                        csWidthIn.value = w;
                        csHeightIn.value = h;
                        if (csLinked) csAspect = w / h;
                        csUpdateInfo();
                    }
                });
                
                document.getElementById('canvasSizeApply').addEventListener('click', () => {
                    const newW = Math.max(1, Math.min(7680, parseInt(csWidthIn.value) || this.canvas.width));
                    const newH = Math.max(1, Math.min(7680, parseInt(csHeightIn.value) || this.canvas.height));
                    const mode = document.getElementById('canvasResizeMode').value;
                    csClose();
                    if (newW !== this.canvas.width || newH !== this.canvas.height) {
                        this.resizeCanvas(newW, newH, mode);
                    }
                });
            }
            
            selectTool(tool) {
                this.tool = tool;
                document.querySelectorAll('.toolbar button').forEach(btn => btn.classList.remove('active'));
                const toolButton = document.getElementById(tool + 'Tool');
                if (toolButton) toolButton.classList.add('active');
                
                // For magnifier, magnifier-out and pan, highlight the navTool dropdown button
                if (tool === 'magnifier' || tool === 'magnifier-out' || tool === 'pan') {
                    document.getElementById('navTool').classList.add('active');
                }
                
                // For transform sub-tools, highlight the transformTool dropdown button
                if (tool === 'transform' || tool === 'scale' || tool === 'rotate') {
                    document.getElementById('transformTool').classList.add('active');
                }
                
                // Sync pill pan button
                const pillPan = document.getElementById('pillPanBtn');
                if (pillPan) {
                    pillPan.classList.toggle('pill-active', tool === 'pan');
                }
                
                // Clear selection when switching away from transform (but not for pan/magnifier)
                const isTransformTool = tool === 'transform' || tool === 'scale' || tool === 'rotate';
                const isNavTool = tool === 'pan' || tool === 'magnifier' || tool === 'magnifier-out';
                if (!isTransformTool && !isNavTool && this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                // Show transform handles if transform-family tool and selection exists
                if (isTransformTool && this.selection) {
                    this.showTransformHandles();
                } else if (isTransformTool && !this.selection) {
                    // Auto-select all content in the current frame
                    this.selectAllInFrame();
                } else {
                    this.hideTransformHandles();
                }
                
                // Manage brush cursor visibility and canvas default cursor
                if (tool === 'brush' || tool === 'eraser') {
                    this.canvas.style.cursor = 'none';
                    this.selectionCanvas.style.cursor = 'none';
                } else if (tool === 'fill' || tool === 'lasso') {
                    this.canvas.style.cursor = 'crosshair';
                    this.selectionCanvas.style.cursor = 'crosshair';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'pan') {
                    this.canvas.style.cursor = 'grab';
                    this.selectionCanvas.style.cursor = 'grab';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'magnifier') {
                    this.canvas.style.cursor = 'zoom-in';
                    this.selectionCanvas.style.cursor = 'zoom-in';
                    this.brushCursor.style.display = 'none';
                } else if (tool === 'magnifier-out') {
                    this.canvas.style.cursor = 'zoom-out';
                    this.selectionCanvas.style.cursor = 'zoom-out';
                    this.brushCursor.style.display = 'none';
                } else {
                    this.canvas.style.cursor = 'default';
                    this.selectionCanvas.style.cursor = 'default';
                    this.brushCursor.style.display = 'none';
                }
            }
            
            _updateNavButton(navtool) {
                const navButton = document.getElementById('navTool');
                const icons = {
                    'magnifier': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M7 5v4M5 7h4"/><path d="M11 11l3.5 3.5"/></svg>',
                    'magnifier-out': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="5"/><path d="M5 7h4"/><path d="M11 11l3.5 3.5"/></svg>',
                    'pan': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5.5 8V3.5a1 1 0 012 0V7"/><path d="M7.5 7V2.5a1 1 0 012 0V7"/><path d="M9.5 7V3.5a1 1 0 012 0V7"/><path d="M11.5 5.5a1 1 0 012 0V10c0 2.5-2 4.5-4.5 4.5h-1C6 14.5 4 12.5 4 10V8.5"/><path d="M5.5 8c0 0-2-1-2.5-2s0-2 1-1.5l1.5 1"/></svg>'
                };
                const labels = { 'magnifier': 'Zoom In', 'magnifier-out': 'Zoom Out', 'pan': 'Pan' };
                navButton.innerHTML = `${icons[navtool]} <span class="btn-label">${labels[navtool]} ▼</span>`;
            }
            
            _updateTransformButton(xformtool) {
                const btn = document.getElementById('transformTool');
                const icons = {
                    'transform': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2.5" y="2.5" width="11" height="11" rx="0.5" stroke-dasharray="2 2"/><circle cx="2.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="2.5" r="1" fill="currentColor" stroke="none"/><circle cx="2.5" cy="13.5" r="1" fill="currentColor" stroke="none"/><circle cx="13.5" cy="13.5" r="1" fill="currentColor" stroke="none"/></svg>',
                    'scale': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10 2h4v4"/><path d="M14 2l-4.5 4.5"/><path d="M6 14H2v-4"/><path d="M2 14l4.5-4.5"/></svg>',
                    'rotate': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 8A5.5 5.5 0 112.5 5.5"/><path d="M2.5 1.5v4h4"/></svg>'
                };
                const labels = { 'transform': 'Transform', 'scale': 'Scale', 'rotate': 'Rotate' };
                btn.innerHTML = `${icons[xformtool]} <span class="btn-label">${labels[xformtool]} ▼</span>`;
            }
            
            updateBrushCursor() {
                const shape = this.tool === 'eraser' ? this.eraserShape : this.brushShape;
                const rect = this.canvas.getBoundingClientRect();
                const displayScale = rect.width / this.canvas.width;
                const size = Math.max(2, this.brushSize * displayScale);
                
                let w = size, h = size;
                if (shape === 'oval-h') {
                    w = size;
                    h = size * 0.4;
                } else if (shape === 'oval-v') {
                    w = size * 0.4;
                    h = size;
                }
                
                this.brushCursor.style.width = w + 'px';
                this.brushCursor.style.height = h + 'px';
                this.brushCursor.className = 'brush-cursor ' + shape;
            }
            
            syncBrushSizeUI() {
                // Sync the dropdown diameter sliders with the current brushSize
                if (this.tool === 'brush') {
                    document.getElementById('brushDiameter').value = this.brushSize;
                    document.getElementById('brushDiameterValue').textContent = this.brushSize;
                } else if (this.tool === 'eraser') {
                    document.getElementById('eraserDiameter').value = this.brushSize;
                    document.getElementById('eraserDiameterValue').textContent = this.brushSize;
                }
            }
            
            getCurrentBrushShape() {
                return this.tool === 'eraser' ? this.eraserShape : this.brushShape;
            }
            
            getSmoothing() {
                return this.tool === 'eraser' ? this.eraserSmoothing : this.brushSmoothing;
            }
            
            selectAllInFrame() {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                if (!frame) return;
                
                const frameCtx = frame.getContext('2d');
                const pixelData = frameCtx.getImageData(0, 0, frame.width, frame.height);
                const pixels = pixelData.data;
                
                // Find tight bounding box of non-transparent pixels
                let minX = frame.width, minY = frame.height, maxX = -1, maxY = -1;
                
                for (let py = 0; py < frame.height; py++) {
                    for (let px = 0; px < frame.width; px++) {
                        const alpha = pixels[(py * frame.width + px) * 4 + 3];
                        if (alpha > 0) {
                            if (px < minX) minX = px;
                            if (px > maxX) maxX = px;
                            if (py < minY) minY = py;
                            if (py > maxY) maxY = py;
                        }
                    }
                }
                
                // Nothing on the frame
                if (maxX < 0 || maxY < 0) {
                    this.hideTransformHandles();
                    return;
                }
                
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                
                // Create selection canvas with the content
                const selectedCanvas = document.createElement('canvas');
                selectedCanvas.width = width;
                selectedCanvas.height = height;
                const selectedCtx = selectedCanvas.getContext('2d');
                selectedCtx.drawImage(frame, minX, minY, width, height, 0, 0, width, height);
                
                // Store selection
                this.selection = {
                    imageData: selectedCanvas,
                    bounds: { x: minX, y: minY, width, height },
                    originalBounds: { x: minX, y: minY, width, height }
                };
                
                // Erase content from original frame
                this.saveState();
                frameCtx.clearRect(0, 0, frame.width, frame.height);
                
                this.showTransformHandles();
                this.render();
            }
            
            // === UNDO SYSTEM: Two-tier snapshots ===
            // saveState()     → fast, single-frame (brush, fill, eraser, clear, lasso, paste)
            // saveFullState() → slow, all frames   (add/delete layer/frame, resize, import)
            
            snapshotFrame() {
                // Fast: only copy current frame on current layer (1 getImageData call)
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                let frameData = null;
                if (frame) {
                    frameData = {
                        width: frame.width,
                        height: frame.height,
                        imageData: frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
                    };
                }
                return {
                    type: 'frame',
                    layerId: this.currentLayerId,
                    frameIndex: this.currentFrameIndex,
                    frameData: frameData
                };
            }
            
            snapshotState() {
                // Full: copy ALL frames as ImageData (N getImageData calls)
                return {
                    type: 'full',
                    layers: this.layers.map(layer => ({
                        id: layer.id,
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        frames: layer.frames.map(frame => {
                            if (!frame) return null;
                            return {
                                width: frame.width,
                                height: frame.height,
                                imageData: frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
                            };
                        })
                    })),
                    currentLayerId: this.currentLayerId,
                    currentFrameIndex: this.currentFrameIndex,
                    nextLayerId: this.nextLayerId
                };
            }
            
            _pushUndo(entry) {
                this.undoStack.push(entry);
                if (this.undoStack.length > this.maxHistorySize) this.undoStack.shift();
                this.redoStack = [];
                this.updateUndoRedoButtons();
            }
            
            saveState() {
                // Fast path — single frame snapshot
                this._pushUndo(this.snapshotFrame());
            }
            
            saveFullState() {
                // Slow path — full snapshot for structural changes
                this._pushUndo(this.snapshotState());
            }
            
            // Snapshot current state matching the type of entry about to be restored
            _snapshotMatching(entry) {
                if (entry.type === 'frame') {
                    const layer = this.layers.find(l => l.id === entry.layerId);
                    if (layer && layer.frames[entry.frameIndex]) {
                        const frame = layer.frames[entry.frameIndex];
                        return {
                            type: 'frame',
                            layerId: entry.layerId,
                            frameIndex: entry.frameIndex,
                            frameData: {
                                width: frame.width,
                                height: frame.height,
                                imageData: frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
                            }
                        };
                    }
                    // Layer/frame gone — fall back to full
                    return this.snapshotState();
                }
                return this.snapshotState();
            }
            
            undo() {
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    this.saveState();
                }
                
                if (this.selection && this.selectionUndoStack.length > 0) {
                    this.restoreSelectionState();
                    return;
                }
                
                if (this.undoStack.length === 0) return;
                
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                    this.hideTransformHandles();
                }
                
                const prev = this.undoStack.pop();
                this.redoStack.push(this._snapshotMatching(prev));
                this.restoreState(prev);
                this.updateUndoRedoButtons();
            }
            
            redo() {
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    this.saveState();
                }
                
                if (this.selection && this.selectionRedoStack.length > 0) {
                    this.redoSelectionState();
                    return;
                }
                
                if (this.redoStack.length === 0) return;
                
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                    this.hideTransformHandles();
                }
                
                const next = this.redoStack.pop();
                this.undoStack.push(this._snapshotMatching(next));
                this.restoreState(next);
                this.updateUndoRedoButtons();
            }
            
            restoreState(state) {
                if (state.type === 'frame') {
                    // Fast restore — overwrite just one frame's pixels
                    const layer = this.layers.find(l => l.id === state.layerId);
                    if (layer && layer.frames[state.frameIndex] && state.frameData) {
                        const frame = layer.frames[state.frameIndex];
                        const ctx = frame.getContext('2d');
                        ctx.clearRect(0, 0, frame.width, frame.height);
                        ctx.putImageData(state.frameData.imageData, 0, 0);
                    }
                    this.render();
                    return;
                }
                
                // Full restore — rebuild all layers
                this.layers = state.layers.map(layer => ({
                    id: layer.id,
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    frames: layer.frames.map(snapshot => {
                        if (!snapshot) return null;
                        const c = document.createElement('canvas');
                        c.width = snapshot.width;
                        c.height = snapshot.height;
                        c.getContext('2d').putImageData(snapshot.imageData, 0, 0);
                        return c;
                    })
                }));
                
                this.currentLayerId = state.currentLayerId;
                this.currentFrameIndex = state.currentFrameIndex;
                this.nextLayerId = state.nextLayerId;
                
                this.renderLayers();
                this.render();
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                const canUndo = this.undoStack.length > 0 || (this.selection && this.selectionUndoStack.length > 0);
                const canRedo = this.redoStack.length > 0 || (this.selection && this.selectionRedoStack.length > 0);
                
                undoBtn.disabled = !canUndo;
                redoBtn.disabled = !canRedo;
                
                undoBtn.style.opacity = canUndo ? '1' : '0.5';
                redoBtn.style.opacity = canRedo ? '1' : '0.5';
            }
            
            startDrawing(e) {
                // Pan and magnifier tools don't draw
                if (this.tool === 'pan' || this.tool === 'magnifier' || this.tool === 'magnifier-out') return;
                
                // Handle fill tool
                if (this.tool === 'fill') {
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = Math.floor((e.clientX - rect.left) * scaleX);
                    const y = Math.floor((e.clientY - rect.top) * scaleY);
                    this.floodFill(x, y);
                    return;
                }
                
                // Handle lasso tool differently
                if (this.tool === 'lasso') {
                    this.saveState(); // Save before starting lasso selection
                    this.lassoPath = [];
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    this.lassoPath.push({x, y});
                    this.isDrawing = true;
                    return;
                }
                
                // Handle transform tool
                if (this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate') {
                    // Check if clicking on a handle
                    const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    for (let handle of this.transformHandles) {
                        const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                        if (dist < 20) { // Large hit area for Apple Pencil & touch
                            const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                           handle.type === 'se' || handle.type === 'sw';
                            
                            // Rotate tool: corners always rotate
                            // Scale tool: corners always resize (never rotate)
                            // Free transform: hover-based rotation mode
                            const shouldRotate = (this.tool === 'rotate' && isCorner) ||
                                                 (this.tool === 'transform' && this.rotationMode && isCorner);
                            
                            if (shouldRotate) {
                                this.activeHandle = {type: 'rotate', corner: handle.type};
                                this.isRotating = true;
                                this.initialRotation = this.selection.rotation || 0;
                                const anchorX = this.selection.anchorX;
                                const anchorY = this.selection.anchorY;
                                this.startAngle = Math.atan2(y - anchorY, x - anchorX);
                                this.updateRotationCursor(handle.type, true);
                            } else if (this.tool !== 'rotate') {
                                // Scale or free transform resize
                                this.activeHandle = handle;
                            } else {
                                // Rotate tool on edge handles: allow move only
                                continue;
                            }
                            
                            this.transformStart = {x, y};
                            this.isTransforming = true;
                            this.saveSelectionState();
                            return;
                        }
                    }
                    
                    // Check if clicking inside selection to move it
                    if (this.selection && this.isPointInSelection(x, y)) {
                        this.activeHandle = {type: 'move'};
                        this.transformStart = {x, y};
                        this.isTransforming = true;
                        this.saveSelectionState();
                        return;
                    }
                    
                    // Clicked outside selection — apply and deselect
                    if (this.selection) {
                        this.applySelection();
                        this.clearSelection();
                        this.selectTool('brush');
                        this.render();
                    }
                    return;
                }
                
                // Draw FIRST for instant visual feedback (critical for iPad)
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                this.lastX = (e.clientX - rect.left) * scaleX;
                this.lastY = (e.clientY - rect.top) * scaleY;
                this.shapeStart = { x: this.lastX, y: this.lastY };
                this.smoothX = this.lastX;
                this.smoothY = this.lastY;
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    this.drawPoint(this.lastX, this.lastY);
                }
                
                // THEN save state asynchronously (doesn't block drawing)
                // This prevents the 20-50ms blocking that causes dropped strokes on iPad
                if (!this.strokeStateSaved) {
                    this.strokeStateSaved = true;
                    this._pendingSaveTimer = setTimeout(() => {
                        this._pendingSaveTimer = null;
                        this.saveState();
                    }, 0);
                }
            }
            
            // Get effective brush size factoring in Apple Pencil pressure
            getPressureBrushSize() {
                if (this.pressureEnabled && (this.pointerType === 'pen' || this.hasStylusInput)) {
                    // Pen pressure: 0.0 to 1.0 — scale brush between 30% and 100% of set size
                    const pressureScale = 0.3 + this.currentPressure * 0.7;
                    return Math.max(1, this.brushSize * pressureScale);
                }
                return this.brushSize;
            }
            
            
            draw(e) {
                // Handle hover detection for rotation mode (free transform only, not scale-only)
                if (this.tool === 'transform' && this.selection && !this.isDrawing && !this.isTransforming) {
                    this.checkRotationHover(e);
                }
                // Rotate tool: always show rotation cursor near corners
                if (this.tool === 'rotate' && this.selection && !this.isDrawing && !this.isTransforming) {
                    this.checkRotateCursor(e);
                }
                
                if (!this.isDrawing && !this.isTransforming) return;
                
                // Store last mouse event for shape finalization
                this.lastMouseEvent = e;
                
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Handle lasso
                if (this.tool === 'lasso' && this.isDrawing) {
                    this.lassoPath.push({x, y});
                    this.drawLassoPath();
                    return;
                }
                
                // Handle transform / scale / rotate
                if (this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate') {
                    if (this.isTransforming) this.performTransform(x, y);
                    return;
                }
                
                if (this.tool === 'brush' || this.tool === 'eraser') {
                    // If pointer just re-entered canvas, jump to new position without connecting line
                    if (this._pointerOffCanvas) {
                        this._pointerOffCanvas = false;
                        this.lastX = x;
                        this.lastY = y;
                        this.smoothX = x;
                        this.smoothY = y;
                        this.drawPoint(x, y);
                        return;
                    }
                    const smoothing = this.getSmoothing();
                    if (smoothing > 0) {
                        // Exponential smoothing: higher smoothing = slower catch-up
                        const factor = 1 - (smoothing / 100) * 0.95;
                        this.smoothX += (x - this.smoothX) * factor;
                        this.smoothY += (y - this.smoothY) * factor;
                        this.drawLine(this.lastX, this.lastY, this.smoothX, this.smoothY);
                        this.lastX = this.smoothX;
                        this.lastY = this.smoothY;
                    } else {
                        this.drawLine(this.lastX, this.lastY, x, y);
                        this.lastX = x;
                        this.lastY = y;
                    }
                } else if (this.shapeStart) {
                    // Preview shape (line, rect, circle, triangle)
                    this.drawShape(this.shapeStart.x, this.shapeStart.y, x, y, true, e.shiftKey, e.altKey);
                }
            }
            
            checkRotationHover(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Check if hovering near a corner handle
                let nearCorner = false;
                let hoveredHandle = null;
                
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    
                    const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                     handle.type === 'se' || handle.type === 'sw';
                    
                    const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                    
                    // Larger hover area for rotation detection (20px)
                    if (dist < 20 && isCorner) {
                        nearCorner = true;
                        hoveredHandle = handle;
                        break;
                    }
                }
                
                // Set up hover timer for rotation mode
                if (nearCorner) {
                    // If we're hovering and don't have a timer running, start one
                    if (!this.hoverTimer) {
                        this.hoverHandle = hoveredHandle;
                        
                        // After 500ms of hovering, switch to rotation mode
                        this.hoverTimer = setTimeout(() => {
                            this.rotationMode = true;
                            // Create custom cursor with rotation arrow based on corner
                            this.updateRotationCursor(hoveredHandle.type);
                            this.hoverTimer = null; // Clear timer reference
                        }, 500);
                    }
                } else {
                    // Clear hover state when not near any corner
                    if (this.hoverTimer) {
                        clearTimeout(this.hoverTimer);
                        this.hoverTimer = null;
                    }
                    this.hoverHandle = null;
                    this.rotationMode = false;
                    this.selectionCanvas.style.cursor = 'default';
                }
            }
            
            checkRotateCursor(e) {
                const canvas = e.target === this.selectionCanvas ? this.selectionCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                let nearCorner = false;
                let hoveredHandle = null;
                
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    const isCorner = handle.type === 'nw' || handle.type === 'ne' || 
                                     handle.type === 'se' || handle.type === 'sw';
                    const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                    if (dist < 20 && isCorner) {
                        nearCorner = true;
                        hoveredHandle = handle;
                        break;
                    }
                }
                
                if (nearCorner) {
                    this.updateRotationCursor(hoveredHandle.type);
                } else {
                    this.selectionCanvas.style.cursor = 'default';
                }
            }
            
            updateRotationCursor(cornerType, isActive = false) {
                // Create SVG cursor with rotation arrow based on corner position
                let arrow, rotation;
                
                // Determine which arrow and rotation based on corner
                switch(cornerType) {
                    case 'nw': // Top-left: counter-clockwise arrow
                        arrow = '↶';
                        rotation = 0;
                        break;
                    case 'ne': // Top-right: clockwise arrow
                        arrow = '↷';
                        rotation = 0;
                        break;
                    case 'se': // Bottom-right: counter-clockwise arrow
                        arrow = '↶';
                        rotation = 180;
                        break;
                    case 'sw': // Bottom-left: clockwise arrow
                        arrow = '↷';
                        rotation = 180;
                        break;
                    default:
                        arrow = '↻';
                        rotation = 0;
                }
                
                // Create SVG cursor with visible dark colors
                const svg = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
                        <text x="16" y="20" font-size="26" text-anchor="middle" 
                              transform="rotate(${rotation}, 16, 16)"
                              fill="${isActive ? '#0066cc' : '#222'}" 
                              stroke="#000" 
                              stroke-width="0.5"
                              paint-order="stroke">${arrow}</text>
                    </svg>
                `;
                
                const encodedSvg = encodeURIComponent(svg);
                this.selectionCanvas.style.cursor = `url('data:image/svg+xml;utf8,${encodedSvg}') 16 16, pointer`;
            }
            
            stopDrawing() {
                if (!this.isDrawing && !this.isTransforming) return;
                
                // Reset stroke state flag for next stroke
                this.strokeStateSaved = false;
                
                // Handle lasso completion
                if (this.tool === 'lasso' && this.isDrawing) {
                    this.isDrawing = false;
                    this.completeLassoSelection();
                    return;
                }
                
                // Handle transform completion
                if ((this.tool === 'transform' || this.tool === 'scale' || this.tool === 'rotate') && this.isTransforming) {
                    this.isTransforming = false;
                    this.isRotating = false;
                    if (this.tool === 'transform') this.rotationMode = false;
                    this.activeHandle = null;
                    this.transformStart = null;
                    if (this.hoverTimer) {
                        clearTimeout(this.hoverTimer);
                        this.hoverTimer = null;
                    }
                    this.hoverHandle = null;
                    this.selectionCanvas.style.cursor = 'default';
                    this.render();
                    return;
                }
                
                if (['line', 'rect', 'circle', 'triangle'].includes(this.tool) && this.shapeStart) {
                    // Get current mouse position from last draw
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    // Finalize shape by drawing it to the frame
                    const mouseEvent = this.lastMouseEvent;
                    if (mouseEvent) {
                        const x = (mouseEvent.clientX - rect.left) * scaleX;
                        const y = (mouseEvent.clientY - rect.top) * scaleY;
                        this.drawShape(this.shapeStart.x, this.shapeStart.y, x, y, false, mouseEvent.shiftKey, mouseEvent.altKey);
                    }
                }
                
                this.isDrawing = false;
                this.shapeStart = null;
                this._pointerOffCanvas = false;
                this.render();
            }
            
            drawPoint(x, y) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const shape = this.getCurrentBrushShape();
                const size = this.getPressureBrushSize();
                const radius = size / 2;
                
                frameCtx.globalCompositeOperation = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                frameCtx.fillStyle = this.color;
                if (shape === 'square') {
                    frameCtx.fillRect(x - radius, y - radius, size, size);
                } else if (shape === 'oval-h') {
                    frameCtx.beginPath();
                    frameCtx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
                    frameCtx.fill();
                } else if (shape === 'oval-v') {
                    frameCtx.beginPath();
                    frameCtx.ellipse(x, y, radius * 0.4, radius, 0, 0, Math.PI * 2);
                    frameCtx.fill();
                } else {
                    frameCtx.beginPath();
                    frameCtx.arc(x, y, radius, 0, Math.PI * 2);
                    frameCtx.fill();
                }
                frameCtx.globalCompositeOperation = 'source-over';
                
                // Also draw directly to main canvas for immediate feedback
                this.ctx.globalCompositeOperation = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                this.ctx.fillStyle = this.color;
                if (shape === 'square') {
                    this.ctx.fillRect(x - radius, y - radius, size, size);
                } else if (shape === 'oval-h') {
                    this.ctx.beginPath();
                    this.ctx.ellipse(x, y, radius, radius * 0.4, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (shape === 'oval-v') {
                    this.ctx.beginPath();
                    this.ctx.ellipse(x, y, radius * 0.4, radius, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalCompositeOperation = 'source-over';
            }
            
            drawLine(x1, y1, x2, y2) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                const shape = this.getCurrentBrushShape();
                const size = this.getPressureBrushSize();
                
                if (shape === 'oval-h' || shape === 'oval-v') {
                    // Stamp ellipses along the line path
                    const rx = shape === 'oval-h' ? size / 2 : size * 0.2;
                    const ry = shape === 'oval-v' ? size / 2 : size * 0.2;
                    const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const step = Math.max(1, Math.min(rx, ry) * 0.3);
                    const steps = Math.max(1, Math.ceil(dist / step));
                    
                    const compositeOp = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                    
                    for (const ctx of [frameCtx, this.ctx]) {
                        ctx.globalCompositeOperation = compositeOp;
                        ctx.fillStyle = this.color;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const px = x1 + (x2 - x1) * t;
                            const py = y1 + (y2 - y1) * t;
                            ctx.beginPath();
                            ctx.ellipse(px, py, rx, ry, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalCompositeOperation = 'source-over';
                    }
                } else {
                    const cap = shape === 'square' ? 'square' : 'round';
                    const join = shape === 'square' ? 'miter' : 'round';
                    const compositeOp = this.tool === 'eraser' ? 'destination-out' : 'source-over';
                    
                    for (const ctx of [frameCtx, this.ctx]) {
                        ctx.globalCompositeOperation = compositeOp;
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = size;
                        ctx.lineCap = cap;
                        ctx.lineJoin = join;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.globalCompositeOperation = 'source-over';
                    }
                }
            }
            
            drawShape(x1, y1, x2, y2, preview = false, shiftKey = false, altKey = false) {
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                
                // Constrain aspect ratio when shift is held
                let sx1 = x1, sy1 = y1, sx2 = x2, sy2 = y2;
                if (shiftKey) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    
                    if (this.tool === 'line') {
                        // Snap to nearest 45° angle
                        const angle = Math.atan2(dy, dx);
                        const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        sx2 = x1 + Math.cos(snapAngle) * dist;
                        sy2 = y1 + Math.sin(snapAngle) * dist;
                    } else {
                        // Force square aspect ratio for rect, circle, triangle
                        const size = Math.max(absDx, absDy);
                        sx2 = x1 + size * Math.sign(dx || 1);
                        sy2 = y1 + size * Math.sign(dy || 1);
                    }
                }
                
                // Draw from center when alt/option is held
                if (altKey && this.tool !== 'line') {
                    const dx = sx2 - sx1;
                    const dy = sy2 - sy1;
                    sx1 = x1 - dx;
                    sy1 = y1 - dy;
                    sx2 = x1 + dx;
                    sy2 = y1 + dy;
                }
                
                const drawShapeOnCtx = (ctx) => {
                    if (this.tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(sx1, sy1);
                        ctx.lineTo(sx2, sy2);
                        ctx.stroke();
                    } else if (this.tool === 'rect') {
                        ctx.strokeRect(sx1, sy1, sx2 - sx1, sy2 - sy1);
                    } else if (this.tool === 'circle') {
                        // Draw ellipse inscribed in bounding box (corner-to-corner)
                        const cx = (sx1 + sx2) / 2;
                        const cy = (sy1 + sy2) / 2;
                        const rx = Math.abs(sx2 - sx1) / 2;
                        const ry = Math.abs(sy2 - sy1) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (this.tool === 'triangle') {
                        const midX = (sx1 + sx2) / 2;
                        ctx.beginPath();
                        ctx.moveTo(midX, sy1);
                        ctx.lineTo(sx2, sy2);
                        ctx.lineTo(sx1, sy2);
                        ctx.closePath();
                        ctx.stroke();
                    }
                };
                
                if (preview) {
                    // Clear and redraw everything for preview
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw all visible layers
                    for (const l of this.layers) {
                        if (l.visible && l.frames[this.currentFrameIndex]) {
                            this.ctx.drawImage(l.frames[this.currentFrameIndex], 0, 0);
                        }
                    }
                    
                    // Now draw the preview shape on top
                    this.ctx.strokeStyle = this.color;
                    this.ctx.lineWidth = this.brushSize;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.globalCompositeOperation = 'source-over';
                    drawShapeOnCtx(this.ctx);
                } else {
                    // Draw final shape to frame
                    const frameCtx = frame.getContext('2d');
                    frameCtx.strokeStyle = this.color;
                    frameCtx.lineWidth = this.brushSize;
                    frameCtx.lineCap = 'round';
                    frameCtx.lineJoin = 'round';
                    frameCtx.globalCompositeOperation = 'source-over';
                    drawShapeOnCtx(frameCtx);
                }
            }
            
            clearCurrentFrame() {
                this.saveState();
                const layer = this.getCurrentLayer();
                layer.frames[this.currentFrameIndex] = this.createEmptyFrame();
                this.render();
            }
            
            // Render a tinted version of a frame onto the onion canvas
            drawOnionFrame(frame, tintColor, opacity) {
                // Create a temp canvas to composite the tint
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw the frame artwork
                tempCtx.drawImage(frame, 0, 0);
                
                // Apply a semi-transparent tint over only the artwork pixels
                // source-atop draws only where existing pixels are opaque
                tempCtx.globalCompositeOperation = 'source-atop';
                tempCtx.globalAlpha = 0.5;
                tempCtx.fillStyle = tintColor;
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.globalAlpha = 1;
                tempCtx.globalCompositeOperation = 'source-over';
                
                // Draw the tinted result onto the onion canvas
                this.onionCtx.globalAlpha = opacity;
                this.onionCtx.drawImage(tempCanvas, 0, 0);
                this.onionCtx.globalAlpha = 1;
            }
            
            addLayer() {
                this.commitSelection();
                this.saveFullState();
                
                const newLayer = {
                    id: this.nextLayerId++,
                    name: `Layer ${this.layers.length + 1}`,
                    visible: true,
                    opacity: 1.0,
                    frames: []
                };
                this.layers.push(newLayer);
                this.currentLayerId = newLayer.id;
                this.renderLayers();
                this.initializeFrame();
                this.render();
            }
            
            duplicateLayer() {
                this.commitSelection();
                this.saveFullState();
                
                const currentLayer = this.getCurrentLayer();
                const newLayer = {
                    id: this.nextLayerId++,
                    name: currentLayer.name + ' copy',
                    visible: currentLayer.visible,
                    opacity: currentLayer.opacity,
                    frames: currentLayer.frames.map(frame => {
                        if (!frame) return null;
                        const copy = document.createElement('canvas');
                        copy.width = frame.width;
                        copy.height = frame.height;
                        copy.getContext('2d').drawImage(frame, 0, 0);
                        return copy;
                    })
                };
                
                // Insert after current layer
                const idx = this.layers.findIndex(l => l.id === this.currentLayerId);
                this.layers.splice(idx + 1, 0, newLayer);
                this.currentLayerId = newLayer.id;
                this.renderLayers();
                this.initializeFrame();
                this.render();
            }
            
            deleteLayer() {
                // Don't delete if it's the only layer
                if (this.layers.length <= 1) {
                    alert('Cannot delete the only layer. Create another layer first.');
                    return;
                }
                
                this.commitSelection();
                this.saveFullState();
                
                // Find index of current layer
                const layerIndex = this.layers.findIndex(l => l.id === this.currentLayerId);
                
                // Remove the layer
                this.layers.splice(layerIndex, 1);
                
                // Select a different layer
                if (layerIndex >= this.layers.length) {
                    // If we deleted the last layer, select the new last layer
                    this.currentLayerId = this.layers[this.layers.length - 1].id;
                } else {
                    // Select the layer that took this position
                    this.currentLayerId = this.layers[layerIndex].id;
                }
                
                this.renderLayers();
                this.initializeFrame();
                this.render();
            }
            
            previousFrame() {
                this.commitSelection();
                if (this.currentFrameIndex > 0) {
                    this.currentFrameIndex--;
                    this.initializeFrame();
                    this.render();
                }
            }
            
            goToNextFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                if (this.currentFrameIndex < layer.frames.length - 1) {
                    this.currentFrameIndex++;
                    this.initializeFrame();
                    this.render();
                }
            }
            
            nextFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                
                // Insert new blank frame after the current frame
                const newFrameIndex = this.currentFrameIndex + 1;
                
                // Create a new blank frame
                const newFrame = this.createEmptyFrame();
                
                // Insert the new frame at the position after current frame
                layer.frames.splice(newFrameIndex, 0, newFrame);
                
                // Move to the new frame
                this.currentFrameIndex = newFrameIndex;
                
                this.render();
            }
            
            insertFrameAfterCurrent() {
                // Same as nextFrame - inserts blank frame after current
                this.nextFrame();
            }
            
            deleteCurrentFrame() {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                
                // Don't delete if it's the only frame
                if (layer.frames.length <= 1) {
                    alert('Cannot delete the only frame. Create another frame first.');
                    return;
                }
                
                // Remove the current frame
                layer.frames.splice(this.currentFrameIndex, 1);
                
                // Adjust current frame index if needed
                if (this.currentFrameIndex >= layer.frames.length) {
                    this.currentFrameIndex = layer.frames.length - 1;
                }
                
                this.render();
            }
            
            // Lasso Selection Methods
            drawLassoPath() {
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                if (this.lassoPath.length < 2) return;
                
                this.selectionCtx.strokeStyle = '#0066cc';
                this.selectionCtx.lineWidth = 2;
                this.selectionCtx.setLineDash([5, 5]);
                this.selectionCtx.beginPath();
                this.selectionCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                
                for (let i = 1; i < this.lassoPath.length; i++) {
                    this.selectionCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                
                this.selectionCtx.closePath();
                this.selectionCtx.stroke();
                this.selectionCtx.setLineDash([]);
            }
            
            completeLassoSelection() {
                if (this.lassoPath.length < 3) {
                    this.lassoPath = [];
                    this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                    return;
                }
                
                // Calculate lasso path bounds (used as initial working area)
                let lassoMinX = Infinity, lassoMinY = Infinity, lassoMaxX = -Infinity, lassoMaxY = -Infinity;
                for (let point of this.lassoPath) {
                    lassoMinX = Math.min(lassoMinX, point.x);
                    lassoMinY = Math.min(lassoMinY, point.y);
                    lassoMaxX = Math.max(lassoMaxX, point.x);
                    lassoMaxY = Math.max(lassoMaxY, point.y);
                }
                
                // Clamp to canvas bounds
                lassoMinX = Math.max(0, Math.floor(lassoMinX));
                lassoMinY = Math.max(0, Math.floor(lassoMinY));
                lassoMaxX = Math.min(this.canvas.width, Math.ceil(lassoMaxX));
                lassoMaxY = Math.min(this.canvas.height, Math.ceil(lassoMaxY));
                
                const lassoWidth = lassoMaxX - lassoMinX;
                const lassoHeight = lassoMaxY - lassoMinY;
                
                if (lassoWidth <= 0 || lassoHeight <= 0) {
                    this.lassoPath = [];
                    return;
                }
                
                // Get image data from current frame
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                
                // Create a mask for the lasso selection (full canvas size)
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = this.canvas.width;
                maskCanvas.height = this.canvas.height;
                const maskCtx = maskCanvas.getContext('2d');
                
                // Draw lasso path as mask
                maskCtx.fillStyle = 'white';
                maskCtx.beginPath();
                maskCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                for (let i = 1; i < this.lassoPath.length; i++) {
                    maskCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                maskCtx.closePath();
                maskCtx.fill();
                
                // Create masked selection at lasso bounds size
                const maskedCanvas = document.createElement('canvas');
                maskedCanvas.width = lassoWidth;
                maskedCanvas.height = lassoHeight;
                const maskedCtx = maskedCanvas.getContext('2d');
                
                // Copy frame content within lasso bounds
                maskedCtx.drawImage(frame, lassoMinX, lassoMinY, lassoWidth, lassoHeight, 0, 0, lassoWidth, lassoHeight);
                
                // Apply lasso mask
                maskedCtx.globalCompositeOperation = 'destination-in';
                maskedCtx.drawImage(maskCanvas, lassoMinX, lassoMinY, lassoWidth, lassoHeight, 0, 0, lassoWidth, lassoHeight);
                maskedCtx.globalCompositeOperation = 'source-over';
                
                // Scan pixel data to find tight bounding box of actual content
                const pixelData = maskedCtx.getImageData(0, 0, lassoWidth, lassoHeight);
                const pixels = pixelData.data;
                
                let tightMinX = lassoWidth, tightMinY = lassoHeight, tightMaxX = -1, tightMaxY = -1;
                
                for (let py = 0; py < lassoHeight; py++) {
                    for (let px = 0; px < lassoWidth; px++) {
                        const alpha = pixels[(py * lassoWidth + px) * 4 + 3];
                        if (alpha > 0) {
                            if (px < tightMinX) tightMinX = px;
                            if (px > tightMaxX) tightMaxX = px;
                            if (py < tightMinY) tightMinY = py;
                            if (py > tightMaxY) tightMaxY = py;
                        }
                    }
                }
                
                // If no pixels found, nothing to select
                if (tightMaxX < 0 || tightMaxY < 0) {
                    this.lassoPath = [];
                    this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                    return;
                }
                
                // Calculate tight bounds in canvas coordinates
                const tightWidth = tightMaxX - tightMinX + 1;
                const tightHeight = tightMaxY - tightMinY + 1;
                const finalX = lassoMinX + tightMinX;
                const finalY = lassoMinY + tightMinY;
                
                // Create final trimmed selection canvas
                const selectedCanvas = document.createElement('canvas');
                selectedCanvas.width = tightWidth;
                selectedCanvas.height = tightHeight;
                const selectedCtx = selectedCanvas.getContext('2d');
                
                // Copy only the tight region from the masked canvas
                selectedCtx.drawImage(maskedCanvas, tightMinX, tightMinY, tightWidth, tightHeight, 0, 0, tightWidth, tightHeight);
                
                // Store selection with tight bounds
                this.selection = {
                    imageData: selectedCanvas,
                    bounds: { x: finalX, y: finalY, width: tightWidth, height: tightHeight },
                    originalBounds: { x: finalX, y: finalY, width: tightWidth, height: tightHeight }
                };
                
                // Erase selected area from original frame (using lasso path shape)
                frameCtx.save();
                frameCtx.globalCompositeOperation = 'destination-out';
                frameCtx.beginPath();
                frameCtx.moveTo(this.lassoPath[0].x, this.lassoPath[0].y);
                for (let i = 1; i < this.lassoPath.length; i++) {
                    frameCtx.lineTo(this.lassoPath[i].x, this.lassoPath[i].y);
                }
                frameCtx.closePath();
                frameCtx.fill();
                frameCtx.restore();
                
                // Clear lasso path
                this.lassoPath = [];
                
                // Switch to transform tool
                this.selectTool('transform');
                this.render();
            }
            
            // Transform Methods
            isPointInSelection(x, y) {
                if (!this.selection) return false;
                const b = this.selection.bounds;
                return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
            }
            
            showTransformHandles() {
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                
                // Initialize anchor point at center if not set
                if (!this.selection.anchorX || !this.selection.anchorY) {
                    this.selection.anchorX = b.x + b.width / 2;
                    this.selection.anchorY = b.y + b.height / 2;
                }
                
                // Initialize rotation if not set
                if (this.selection.rotation === undefined) {
                    this.selection.rotation = 0;
                }
                
                const rotation = this.selection.rotation;
                const anchorX = this.selection.anchorX;
                const anchorY = this.selection.anchorY;
                
                // Helper function to rotate a point around anchor
                const rotatePoint = (px, py) => {
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    const dx = px - anchorX;
                    const dy = py - anchorY;
                    return {
                        x: anchorX + dx * cos - dy * sin,
                        y: anchorY + dx * sin + dy * cos
                    };
                };
                
                // Calculate handle positions in unrotated space, then rotate them
                const unrotatedHandles = [
                    { x: b.x, y: b.y, type: 'nw' },
                    { x: b.x + b.width, y: b.y, type: 'ne' },
                    { x: b.x + b.width, y: b.y + b.height, type: 'se' },
                    { x: b.x, y: b.y + b.height, type: 'sw' },
                    { x: b.x + b.width / 2, y: b.y, type: 'n' },
                    { x: b.x + b.width, y: b.y + b.height / 2, type: 'e' },
                    { x: b.x + b.width / 2, y: b.y + b.height, type: 's' },
                    { x: b.x, y: b.y + b.height / 2, type: 'w' }
                ];
                
                // Rotate all handle positions
                this.transformHandles = unrotatedHandles.map(h => {
                    const rotated = rotatePoint(h.x, h.y);
                    return { x: rotated.x, y: rotated.y, type: h.type };
                });
                
                // Add anchor point (not rotated)
                this.transformHandles.push({ x: anchorX, y: anchorY, type: 'anchor' });
                
                this.drawTransformHandles();
            }
            
            hideTransformHandles() {
                this.transformHandles = [];
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
            }
            
            drawTransformHandles() {
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                
                if (!this.selection) return;
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                
                // Save context and apply rotation for the bounding box
                this.selectionCtx.save();
                this.selectionCtx.translate(anchorX, anchorY);
                this.selectionCtx.rotate(rotation);
                this.selectionCtx.translate(-anchorX, -anchorY);
                
                // Draw selection box (rotated)
                this.selectionCtx.strokeStyle = '#0066cc';
                this.selectionCtx.lineWidth = 2;
                this.selectionCtx.setLineDash([5, 5]);
                this.selectionCtx.strokeRect(b.x, b.y, b.width, b.height);
                this.selectionCtx.setLineDash([]);
                
                // Restore context before drawing handles
                this.selectionCtx.restore();
                
                // Draw resize/rotate handles at their already-rotated positions
                // (handles are already at correct positions from showTransformHandles)
                for (let handle of this.transformHandles) {
                    if (handle.type === 'anchor') continue;
                    
                    this.selectionCtx.fillStyle = 'white';
                    this.selectionCtx.strokeStyle = '#0066cc';
                    this.selectionCtx.lineWidth = 2;
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
                    this.selectionCtx.fill();
                    this.selectionCtx.stroke();
                }
                
                // Draw anchor point crosshair (NOT rotated - stays fixed)
                const anchorHandle = this.transformHandles.find(h => h.type === 'anchor');
                if (anchorHandle) {
                    this.selectionCtx.strokeStyle = '#ff6600';
                    this.selectionCtx.lineWidth = 2;
                    this.selectionCtx.beginPath();
                    this.selectionCtx.moveTo(anchorHandle.x - 8, anchorHandle.y);
                    this.selectionCtx.lineTo(anchorHandle.x + 8, anchorHandle.y);
                    this.selectionCtx.moveTo(anchorHandle.x, anchorHandle.y - 8);
                    this.selectionCtx.lineTo(anchorHandle.x, anchorHandle.y + 8);
                    this.selectionCtx.stroke();
                    
                    // Draw circle around anchor
                    this.selectionCtx.strokeStyle = '#ff6600';
                    this.selectionCtx.fillStyle = 'white';
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(anchorHandle.x, anchorHandle.y, 6, 0, Math.PI * 2);
                    this.selectionCtx.fill();
                    this.selectionCtx.stroke();
                }
            }
            
            performTransform(x, y) {
                if (!this.selection || !this.activeHandle || !this.transformStart) return;
                
                const dx = x - this.transformStart.x;
                const dy = y - this.transformStart.y;
                
                if (this.activeHandle.type === 'move') {
                    // Move selection and anchor point together
                    this.selection.bounds.x += dx;
                    this.selection.bounds.y += dy;
                    this.selection.anchorX += dx;
                    this.selection.anchorY += dy;
                    this.transformStart = { x, y };
                } else if (this.activeHandle.type === 'anchor') {
                    // Move anchor point independently
                    this.selection.anchorX = x;
                    this.selection.anchorY = y;
                } else if (this.activeHandle.type === 'rotate' || this.isRotating) {
                    // Calculate rotation angle from anchor point
                    const anchorX = this.selection.anchorX;
                    const anchorY = this.selection.anchorY;
                    
                    // Calculate current angle from anchor to mouse position
                    const currentAngle = Math.atan2(y - anchorY, x - anchorX);
                    
                    // Calculate rotation delta from start
                    const angleDelta = currentAngle - this.startAngle;
                    
                    // Apply rotation
                    this.selection.rotation = this.initialRotation + angleDelta;
                } else {
                    // Resize selection
                    const b = this.selection.bounds;
                    const type = this.activeHandle.type;
                    
                    if (type.includes('n')) {
                        const newY = b.y + dy;
                        const newHeight = b.height - dy;
                        if (newHeight > 10) {
                            b.y = newY;
                            b.height = newHeight;
                        }
                    }
                    if (type.includes('s')) {
                        b.height += dy;
                        if (b.height < 10) b.height = 10;
                    }
                    if (type.includes('w')) {
                        const newX = b.x + dx;
                        const newWidth = b.width - dx;
                        if (newWidth > 10) {
                            b.x = newX;
                            b.width = newWidth;
                        }
                    }
                    if (type.includes('e')) {
                        b.width += dx;
                        if (b.width < 10) b.width = 10;
                    }
                    
                    this.transformStart = { x, y };
                }
                
                this.showTransformHandles();
                this.render();
            }
            
            applySelection() {
                if (!this.selection) return;
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const frameCtx = frame.getContext('2d');
                
                const b = this.selection.bounds;
                const rotation = this.selection.rotation || 0;
                const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                
                // Save context state
                frameCtx.save();
                
                // Apply rotation around anchor point
                frameCtx.translate(anchorX, anchorY);
                frameCtx.rotate(rotation);
                frameCtx.translate(-anchorX, -anchorY);
                
                // Draw the transformed selection onto the frame
                frameCtx.drawImage(
                    this.selection.imageData,
                    b.x, b.y, b.width, b.height
                );
                
                // Restore context state
                frameCtx.restore();
            }
            
            clearSelection() {
                this.selection = null;
                this.transformHandles = [];
                this.selectionUndoStack = [];
                this.selectionRedoStack = [];
                this.selectionCtx.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
                this.updateUndoRedoButtons();
            }
            
            saveSelectionState() {
                if (!this.selection) return;
                this.selectionUndoStack.push({
                    bounds: { ...this.selection.bounds },
                    originalBounds: { ...this.selection.originalBounds },
                    rotation: this.selection.rotation || 0,
                    anchorX: this.selection.anchorX,
                    anchorY: this.selection.anchorY
                });
                // New transform action invalidates redo history
                this.selectionRedoStack = [];
                this.updateUndoRedoButtons();
            }
            
            restoreSelectionState() {
                if (!this.selection || this.selectionUndoStack.length === 0) return false;
                // Save current state to redo stack before restoring
                this.selectionRedoStack.push({
                    bounds: { ...this.selection.bounds },
                    originalBounds: { ...this.selection.originalBounds },
                    rotation: this.selection.rotation || 0,
                    anchorX: this.selection.anchorX,
                    anchorY: this.selection.anchorY
                });
                const state = this.selectionUndoStack.pop();
                this.selection.bounds = { ...state.bounds };
                this.selection.originalBounds = { ...state.originalBounds };
                this.selection.rotation = state.rotation;
                this.selection.anchorX = state.anchorX;
                this.selection.anchorY = state.anchorY;
                this.showTransformHandles();
                this.render();
                this.updateUndoRedoButtons();
                return true;
            }
            
            redoSelectionState() {
                if (!this.selection || this.selectionRedoStack.length === 0) return false;
                // Save current state to undo stack before redoing
                this.selectionUndoStack.push({
                    bounds: { ...this.selection.bounds },
                    originalBounds: { ...this.selection.originalBounds },
                    rotation: this.selection.rotation || 0,
                    anchorX: this.selection.anchorX,
                    anchorY: this.selection.anchorY
                });
                const state = this.selectionRedoStack.pop();
                this.selection.bounds = { ...state.bounds };
                this.selection.originalBounds = { ...state.originalBounds };
                this.selection.rotation = state.rotation;
                this.selection.anchorX = state.anchorX;
                this.selection.anchorY = state.anchorY;
                this.showTransformHandles();
                this.render();
                this.updateUndoRedoButtons();
                return true;
            }
            
            // Apply any active selection back to its frame and dismiss it
            commitSelection() {
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
            }
            
            // Clipboard Methods - Selection
            copySelection() {
                if (!this.selection) return;
                
                // Deep copy the selection image data to a new canvas
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = this.selection.imageData.width;
                copyCanvas.height = this.selection.imageData.height;
                const copyCtx = copyCanvas.getContext('2d');
                copyCtx.drawImage(this.selection.imageData, 0, 0);
                
                this.copiedSelection = {
                    imageData: copyCanvas,
                    width: this.selection.bounds.width,
                    height: this.selection.bounds.height,
                    x: this.selection.bounds.x,
                    y: this.selection.bounds.y
                };
                
                // Apply selection back to the frame and dismiss bounding box
                this.applySelection();
                this.clearSelection();
                this.selectTool('brush');
                this.render();
            }
            
            pasteSelection() {
                if (!this.copiedSelection) return;
                
                // Apply any current selection first
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                this.saveState();
                
                // Create a new canvas copy for the pasted selection
                const pasteCanvas = document.createElement('canvas');
                pasteCanvas.width = this.copiedSelection.imageData.width;
                pasteCanvas.height = this.copiedSelection.imageData.height;
                const pasteCtx = pasteCanvas.getContext('2d');
                pasteCtx.drawImage(this.copiedSelection.imageData, 0, 0);
                
                // Paste centered on canvas
                const centerX = Math.round((this.canvas.width - this.copiedSelection.width) / 2);
                const centerY = Math.round((this.canvas.height - this.copiedSelection.height) / 2);
                
                this.selection = {
                    imageData: pasteCanvas,
                    bounds: {
                        x: centerX,
                        y: centerY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    },
                    originalBounds: {
                        x: centerX,
                        y: centerY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    }
                };
                
                // Switch to transform tool so the user can position it
                this.selectTool('transform');
                this.render();
            }
            
            pasteSelectionInPlace() {
                if (!this.copiedSelection) return;
                
                // Apply any current selection first
                if (this.selection) {
                    this.applySelection();
                    this.clearSelection();
                }
                
                this.saveState();
                
                // Create a new canvas copy for the pasted selection
                const pasteCanvas = document.createElement('canvas');
                pasteCanvas.width = this.copiedSelection.imageData.width;
                pasteCanvas.height = this.copiedSelection.imageData.height;
                const pasteCtx = pasteCanvas.getContext('2d');
                pasteCtx.drawImage(this.copiedSelection.imageData, 0, 0);
                
                // Paste at original position
                const origX = this.copiedSelection.x;
                const origY = this.copiedSelection.y;
                
                this.selection = {
                    imageData: pasteCanvas,
                    bounds: {
                        x: origX,
                        y: origY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    },
                    originalBounds: {
                        x: origX,
                        y: origY,
                        width: this.copiedSelection.width,
                        height: this.copiedSelection.height
                    }
                };
                
                // Switch to transform tool
                this.selectTool('transform');
                this.render();
            }
            
            // Clipboard Methods - Frames
            copyFrame(frameIndex) {
                const layer = this.getCurrentLayer();
                const idx = (frameIndex !== undefined) ? frameIndex : this.currentFrameIndex;
                const sourceFrame = layer.frames[idx];
                if (!sourceFrame) return;
                
                // Deep copy the frame canvas
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = sourceFrame.width;
                copyCanvas.height = sourceFrame.height;
                const copyCtx = copyCanvas.getContext('2d');
                copyCtx.drawImage(sourceFrame, 0, 0);
                
                this.copiedFrame = copyCanvas;
            }
            
            pasteFrame(afterIndex) {
                if (!this.copiedFrame) return;
                
                this.commitSelection();
                this.saveFullState();
                
                const layer = this.getCurrentLayer();
                const idx = (afterIndex !== undefined) ? afterIndex : this.currentFrameIndex;
                
                // Create a new canvas with the copied content
                const newFrame = document.createElement('canvas');
                newFrame.width = this.copiedFrame.width;
                newFrame.height = this.copiedFrame.height;
                const newCtx = newFrame.getContext('2d');
                newCtx.drawImage(this.copiedFrame, 0, 0);
                
                // Insert after the target frame
                layer.frames.splice(idx + 1, 0, newFrame);
                
                // Navigate to the pasted frame
                this.currentFrameIndex = idx + 1;
                this.render();
            }
            
            duplicateFrame(frameIndex) {
                this.commitSelection();
                const layer = this.getCurrentLayer();
                const idx = (frameIndex !== undefined) ? frameIndex : this.currentFrameIndex;
                const sourceFrame = layer.frames[idx];
                if (!sourceFrame) return;
                
                this.saveFullState();
                
                // Deep copy the frame
                const newFrame = document.createElement('canvas');
                newFrame.width = sourceFrame.width;
                newFrame.height = sourceFrame.height;
                const newCtx = newFrame.getContext('2d');
                newCtx.drawImage(sourceFrame, 0, 0);
                
                // Insert right after the source frame
                layer.frames.splice(idx + 1, 0, newFrame);
                
                // Navigate to the new duplicate
                this.currentFrameIndex = idx + 1;
                this.render();
            }
            
            // Flood Fill (Paint Bucket) Algorithm
            floodFill(startX, startY) {
                // Flush any pending async saveState from a previous brush stroke
                // to prevent it from firing after the fill and corrupting undo history
                if (this._pendingSaveTimer) {
                    clearTimeout(this._pendingSaveTimer);
                    this._pendingSaveTimer = null;
                    this.saveState(); // flush it now synchronously (pre-fill state)
                }
                
                const layer = this.getCurrentLayer();
                const frame = layer.frames[this.currentFrameIndex];
                const ctx = frame.getContext('2d');
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // Bounds check
                if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;
                
                // Get target color (color at click point)
                const startPos = (startY * width + startX) * 4;
                const targetR = data[startPos];
                const targetG = data[startPos + 1];
                const targetB = data[startPos + 2];
                const targetA = data[startPos + 3];
                
                // Get fill color
                const fillColor = this.hexToRgb(this.color);
                
                // Don't fill if target is already the fill color
                if (targetR === fillColor.r && targetG === fillColor.g && 
                    targetB === fillColor.b && targetA === 255) {
                    return; // No saveState — no phantom undo entry
                }
                
                // NOW save state, after confirming the fill will actually do something
                this.saveState();
                
                const tolerance = 50;
                
                // Use Uint8Array bitmap instead of string Set — O(1) lookup, zero allocation
                const visited = new Uint8Array(width * height); // 0 = unvisited, 1 = filled
                
                // Color match check using bitmap index
                const colorMatch = (idx) => {
                    const pos = idx * 4;
                    const a = data[pos + 3];
                    if (a < 30) return true; // Transparent pixels match
                    return Math.abs(data[pos] - targetR) <= tolerance &&
                           Math.abs(data[pos + 1] - targetG) <= tolerance &&
                           Math.abs(data[pos + 2] - targetB) <= tolerance &&
                           Math.abs(a - targetA) <= tolerance;
                };
                
                // Scanline flood fill — much faster than per-pixel stack
                const stack = [startX + startY * width];
                let filledCount = 0;
                
                while (stack.length > 0) {
                    let idx = stack.pop();
                    let x = idx % width;
                    const y = (idx - x) / width;
                    
                    // Scan left to find the start of this span
                    while (x > 0 && !visited[(idx - 1)] && colorMatch(idx - 1)) {
                        x--;
                        idx--;
                    }
                    
                    // Scan right, filling pixels and checking rows above and below
                    let spanAbove = false;
                    let spanBelow = false;
                    
                    while (x < width && !visited[idx] && colorMatch(idx)) {
                        // Fill this pixel
                        visited[idx] = 1;
                        const pos = idx * 4;
                        data[pos] = fillColor.r;
                        data[pos + 1] = fillColor.g;
                        data[pos + 2] = fillColor.b;
                        data[pos + 3] = 255;
                        filledCount++;
                        
                        // Check pixel above
                        if (y > 0) {
                            const aboveIdx = idx - width;
                            if (!visited[aboveIdx] && colorMatch(aboveIdx)) {
                                if (!spanAbove) {
                                    stack.push(aboveIdx);
                                    spanAbove = true;
                                }
                            } else {
                                spanAbove = false;
                            }
                        }
                        
                        // Check pixel below
                        if (y < height - 1) {
                            const belowIdx = idx + width;
                            if (!visited[belowIdx] && colorMatch(belowIdx)) {
                                if (!spanBelow) {
                                    stack.push(belowIdx);
                                    spanBelow = true;
                                }
                            } else {
                                spanBelow = false;
                            }
                        }
                        
                        x++;
                        idx++;
                    }
                }
                
                // Second pass: anti-alias edge blending
                // Only check pixels adjacent to filled pixels that weren't filled themselves
                if (filledCount > 0) {
                    // Collect edge pixels efficiently using the bitmap
                    const edgePixels = [];
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            if (visited[idx]) continue; // Skip filled pixels
                            
                            const pos = idx * 4;
                            const a = data[pos + 3];
                            if (a === 0 || a >= 200) continue; // Skip fully transparent or opaque
                            
                            // Check if any neighbor is filled (4-connected for speed)
                            let adjacentToFill = false;
                            if (x > 0 && visited[idx - 1]) adjacentToFill = true;
                            else if (x < width - 1 && visited[idx + 1]) adjacentToFill = true;
                            else if (y > 0 && visited[idx - width]) adjacentToFill = true;
                            else if (y < height - 1 && visited[idx + width]) adjacentToFill = true;
                            
                            if (adjacentToFill) {
                                edgePixels.push(pos);
                            }
                        }
                    }
                    
                    // Blend edge pixels
                    for (const pos of edgePixels) {
                        const oldR = data[pos];
                        const oldG = data[pos + 1];
                        const oldB = data[pos + 2];
                        const oldA = data[pos + 3];
                        
                        const blendFactor = oldA / 255;
                        data[pos] = Math.round(fillColor.r * (1 - blendFactor) + oldR * blendFactor);
                        data[pos + 1] = Math.round(fillColor.g * (1 - blendFactor) + oldG * blendFactor);
                        data[pos + 2] = Math.round(fillColor.b * (1 - blendFactor) + oldB * blendFactor);
                        data[pos + 3] = 255;
                    }
                }
                
                // Put modified image data back
                ctx.putImageData(imageData, 0, 0);
                this.render();
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 0, g: 0, b: 0};
            }
            
            play() {
                if (this.isPlaying) return;
                this.commitSelection();
                this.isPlaying = true;
                
                const layer = this.getCurrentLayer();
                const maxFrames = layer.frames.length;
                let frameIndex = 0;
                let lastFrameTime = performance.now();
                const frameDelay = 1000 / this.fps;
                
                const playbackLoop = (currentTime) => {
                    if (!this.isPlaying) return;
                    
                    const elapsed = currentTime - lastFrameTime;
                    
                    if (elapsed >= frameDelay) {
                        this.currentFrameIndex = frameIndex;
                        this.render();
                        frameIndex = (frameIndex + 1) % maxFrames;
                        lastFrameTime = currentTime - (elapsed % frameDelay);
                    }
                    
                    this.playbackAnimationFrame = requestAnimationFrame(playbackLoop);
                };
                
                this.playbackAnimationFrame = requestAnimationFrame(playbackLoop);
            }
            
            stop() {
                this.isPlaying = false;
                if (this.playbackInterval) {
                    clearInterval(this.playbackInterval);
                    this.playbackInterval = null;
                }
                if (this.playbackAnimationFrame) {
                    cancelAnimationFrame(this.playbackAnimationFrame);
                    this.playbackAnimationFrame = null;
                }
            }
            
            render() {
                // Position onion canvas
                this.positionOnionCanvas();
                
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Clear onion skin canvas
                this.onionCtx.clearRect(0, 0, this.onionCanvas.width, this.onionCanvas.height);
                
                // Draw onion skin (previous and next frames)
                if (this.onionSkinEnabled) {
                    const layer = this.getCurrentLayer();
                    
                    // Draw previous frames (tinted with prevColor)
                    for (let offset = 1; offset <= this.onionFramesBefore; offset++) {
                        const frameIdx = this.currentFrameIndex - offset;
                        if (frameIdx >= 0) {
                            const prevFrame = layer.frames[frameIdx];
                            if (prevFrame && layer.visible) {
                                // Fade opacity for frames further away
                                const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesBefore, 1));
                                this.drawOnionFrame(prevFrame, this.onionPrevColor, fadeOpacity);
                            }
                        }
                    }
                    
                    // Draw next frames (tinted with nextColor)
                    for (let offset = 1; offset <= this.onionFramesAfter; offset++) {
                        const frameIdx = this.currentFrameIndex + offset;
                        if (frameIdx < layer.frames.length) {
                            const nextFrame = layer.frames[frameIdx];
                            if (nextFrame && layer.visible) {
                                // Fade opacity for frames further away
                                const fadeOpacity = this.onionSkinOpacity * (1 - (offset - 1) / Math.max(this.onionFramesAfter, 1));
                                this.drawOnionFrame(nextFrame, this.onionNextColor, fadeOpacity);
                            }
                        }
                    }
                }
                
                // Draw all visible layers for current frame ON THE MAIN CANVAS
                for (const layer of this.layers) {
                    if (layer.visible && layer.frames[this.currentFrameIndex]) {
                        this.ctx.globalAlpha = layer.opacity || 1.0;
                        this.ctx.drawImage(layer.frames[this.currentFrameIndex], 0, 0);
                        this.ctx.globalAlpha = 1.0;
                    }
                }
                
                // Draw selection if it exists (with rotation)
                if (this.selection) {
                    const b = this.selection.bounds;
                    const rotation = this.selection.rotation || 0;
                    const anchorX = this.selection.anchorX || (b.x + b.width / 2);
                    const anchorY = this.selection.anchorY || (b.y + b.height / 2);
                    
                    // Save context state
                    this.ctx.save();
                    
                    // Apply rotation around anchor point
                    this.ctx.translate(anchorX, anchorY);
                    this.ctx.rotate(rotation);
                    this.ctx.translate(-anchorX, -anchorY);
                    
                    // Draw the selection
                    this.ctx.drawImage(
                        this.selection.imageData,
                        b.x, b.y, b.width, b.height
                    );
                    
                    // Restore context state
                    this.ctx.restore();
                }
                
                this.renderTimeline();
                this.renderLayers();
            }
            
            renderLayers() {
                const layersList = document.getElementById('layersList');
                layersList.innerHTML = '';
                
                [...this.layers].reverse().forEach((layer) => {
                    
                    const div = document.createElement('div');
                    div.className = 'layer-item' + (layer.id === this.currentLayerId ? ' active' : '');
                    div.dataset.layerId = layer.id;
                    
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'layer-header';
                    
                    // Drag handle (grip icon)
                    const dragHandle = document.createElement('span');
                    dragHandle.className = 'layer-drag-handle';
                    dragHandle.innerHTML = '<svg width="10" height="14" viewBox="0 0 10 14" fill="currentColor"><circle cx="3" cy="2" r="1.5"/><circle cx="7" cy="2" r="1.5"/><circle cx="3" cy="7" r="1.5"/><circle cx="7" cy="7" r="1.5"/><circle cx="3" cy="12" r="1.5"/><circle cx="7" cy="12" r="1.5"/></svg>';
                    
                    const visibilitySpan = document.createElement('span');
                    visibilitySpan.className = 'layer-visibility';
                    visibilitySpan.textContent = layer.visible ? '👁️' : '🚫';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'layer-name';
                    nameSpan.textContent = layer.name;
                    
                    headerDiv.appendChild(dragHandle);
                    headerDiv.appendChild(visibilitySpan);
                    headerDiv.appendChild(nameSpan);
                    
                    // Opacity control
                    const opacityDiv = document.createElement('div');
                    opacityDiv.className = 'layer-opacity-control';
                    
                    const opacityLabel = document.createElement('span');
                    opacityLabel.textContent = 'Opacity:';
                    
                    const opacitySlider = document.createElement('input');
                    opacitySlider.type = 'range';
                    opacitySlider.min = '0';
                    opacitySlider.max = '100';
                    opacitySlider.value = Math.round((layer.opacity || 1.0) * 100);
                    
                    const opacityValue = document.createElement('span');
                    opacityValue.className = 'layer-opacity-value';
                    opacityValue.textContent = Math.round((layer.opacity || 1.0) * 100) + '%';
                    
                    opacitySlider.addEventListener('input', (e) => {
                        e.stopPropagation();
                        const newOpacity = parseInt(e.target.value) / 100;
                        layer.opacity = newOpacity;
                        opacityValue.textContent = Math.round(newOpacity * 100) + '%';
                        this.render();
                    });
                    
                    opacityDiv.appendChild(opacityLabel);
                    opacityDiv.appendChild(opacitySlider);
                    opacityDiv.appendChild(opacityValue);
                    
                    div.appendChild(headerDiv);
                    div.appendChild(opacityDiv);
                    
                    // Click handlers
                    headerDiv.addEventListener('click', (e) => {
                        if (this._layerDragDidMove) return; // Ignore click after drag
                        if (e.target.classList.contains('layer-visibility')) {
                            layer.visible = !layer.visible;
                            this.render();
                        } else if (!e.target.closest('.layer-drag-handle')) {
                            this.commitSelection();
                            this.currentLayerId = layer.id;
                            this.initializeFrame();
                            this.render();
                        }
                    });
                    
                    // Pointer-based drag reordering (works on iPad + desktop)
                    const startDrag = (startY) => {
                        this._layerDragId = layer.id;
                        this._layerDragDidMove = false;
                        this._layerDragStartY = startY;
                        div.classList.add('dragging');
                    };
                    
                    dragHandle.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        startDrag(e.clientY);
                        
                        const onMove = (me) => {
                            if (this._layerDragId === null) return;
                            if (Math.abs(me.clientY - this._layerDragStartY) > 3) {
                                this._layerDragDidMove = true;
                            }
                            if (!this._layerDragDidMove) return;
                            
                            // Find which layer item we're over
                            const items = layersList.querySelectorAll('.layer-item');
                            items.forEach(item => item.classList.remove('drop-before', 'drop-after'));
                            
                            for (const item of items) {
                                if (item.dataset.layerId == this._layerDragId) continue;
                                const rect = item.getBoundingClientRect();
                                if (me.clientY >= rect.top && me.clientY <= rect.bottom) {
                                    const mid = rect.top + rect.height / 2;
                                    if (me.clientY < mid) {
                                        item.classList.add('drop-before');
                                        this._layerDropTarget = parseInt(item.dataset.layerId);
                                        this._layerDropPos = 'before';
                                    } else {
                                        item.classList.add('drop-after');
                                        this._layerDropTarget = parseInt(item.dataset.layerId);
                                        this._layerDropPos = 'after';
                                    }
                                    break;
                                }
                            }
                        };
                        
                        const onUp = () => {
                            document.removeEventListener('pointermove', onMove);
                            document.removeEventListener('pointerup', onUp);
                            document.removeEventListener('pointercancel', onUp);
                            
                            div.classList.remove('dragging');
                            layersList.querySelectorAll('.layer-item').forEach(item => {
                                item.classList.remove('drop-before', 'drop-after');
                            });
                            
                            if (this._layerDragDidMove && this._layerDropTarget != null) {
                                this._reorderLayer(this._layerDragId, this._layerDropTarget, this._layerDropPos);
                            }
                            
                            this._layerDragId = null;
                            this._layerDropTarget = null;
                            this._layerDropPos = null;
                            // Delay clearing flag so click handler can check it
                            setTimeout(() => { this._layerDragDidMove = false; }, 0);
                        };
                        
                        document.addEventListener('pointermove', onMove);
                        document.addEventListener('pointerup', onUp);
                        document.addEventListener('pointercancel', onUp);
                    });
                    
                    layersList.appendChild(div);
                });
            }
            
            _reorderLayer(dragId, targetId, position) {
                // The UI is reversed: top of list = top layer = end of array
                const dragIdx = this.layers.findIndex(l => l.id === dragId);
                const targetIdx = this.layers.findIndex(l => l.id === targetId);
                if (dragIdx === -1 || targetIdx === -1 || dragIdx === targetIdx) return;
                
                this.saveFullState();
                
                const [draggedLayer] = this.layers.splice(dragIdx, 1);
                
                // Recalculate target index after removal
                let newIdx = this.layers.findIndex(l => l.id === targetId);
                
                // UI is reversed: "before" in UI (above) = higher in stack = higher array index
                if (position === 'before') {
                    newIdx += 1; // Insert after in array = above in UI
                }
                
                this.layers.splice(newIdx, 0, draggedLayer);
                this.renderLayers();
                this.render();
            }
            
            renderTimeline() {
                const container = document.getElementById('framesContainer');
                container.innerHTML = '';
                
                // Re-append the drop indicator if it exists
                if (this._dropIndicator) {
                    this._dropIndicator.style.display = 'none';
                    container.appendChild(this._dropIndicator);
                }
                
                const layer = this.getCurrentLayer();
                const maxFrames = Math.max(layer.frames.length, this.currentFrameIndex + 1);
                
                for (let i = 0; i < maxFrames; i++) {
                    const frameDiv = document.createElement('div');
                    frameDiv.className = 'frame' + (i === this.currentFrameIndex ? ' active' : '');
                    frameDiv.dataset.frameIndex = i;
                    
                    if (layer.frames[i]) {
                        const thumbnail = document.createElement('canvas');
                        thumbnail.width = 80;
                        thumbnail.height = 60;
                        const thumbCtx = thumbnail.getContext('2d');
                        thumbCtx.drawImage(layer.frames[i], 0, 0, 80, 60);
                        frameDiv.appendChild(thumbnail);
                    }
                    
                    const frameNumber = document.createElement('div');
                    frameNumber.className = 'frame-number';
                    frameNumber.textContent = i + 1;
                    frameDiv.appendChild(frameNumber);
                    
                    // Pointer-based drag: pointerdown starts potential drag (works with mouse, touch, pencil)
                    frameDiv.addEventListener('pointerdown', (e) => {
                        if (e.button && e.button !== 0) return; // left click only for mouse
                        e.preventDefault();
                        
                        this._frameDragState = {
                            index: i,
                            startX: e.clientX,
                            startY: e.clientY,
                            started: false,
                            element: frameDiv
                        };
                    });
                    
                    // Right-click context menu
                    frameDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.contextMenuFrameIndex = i;
                        
                        const ctxMenu = document.getElementById('frameContextMenu');
                        const pasteItem = document.getElementById('ctxPasteFrame');
                        
                        // Enable/disable paste based on clipboard
                        if (this.copiedFrame) {
                            pasteItem.classList.remove('disabled');
                        } else {
                            pasteItem.classList.add('disabled');
                        }
                        
                        // Position the menu
                        ctxMenu.style.left = e.clientX + 'px';
                        ctxMenu.style.top = e.clientY + 'px';
                        ctxMenu.classList.add('show');
                        
                        // Keep menu within viewport
                        const menuRect = ctxMenu.getBoundingClientRect();
                        if (menuRect.right > window.innerWidth) {
                            ctxMenu.style.left = (e.clientX - menuRect.width) + 'px';
                        }
                        if (menuRect.bottom > window.innerHeight) {
                            ctxMenu.style.top = (e.clientY - menuRect.height) + 'px';
                        }
                    });
                    
                    container.appendChild(frameDiv);
                }
                
                // Set up document-level drag handlers (only once)
                if (!this._frameDragBound) {
                    this._frameDragBound = true;
                    
                    // Create reusable ghost and indicator elements
                    this._dragGhost = document.createElement('div');
                    this._dragGhost.className = 'frame-drag-ghost';
                    this._dragGhost.style.display = 'none';
                    document.body.appendChild(this._dragGhost);
                    
                    this._dropIndicator = document.createElement('div');
                    this._dropIndicator.className = 'frame-drop-indicator';
                    this._dropIndicator.style.display = 'none';
                    container.appendChild(this._dropIndicator);
                    
                    document.addEventListener('pointermove', (e) => {
                        if (!this._frameDragState) return;
                        
                        const state = this._frameDragState;
                        const dx = e.clientX - state.startX;
                        const dy = e.clientY - state.startY;
                        
                        // Require minimum movement to start drag (5px)
                        if (!state.started && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                            state.started = true;
                            state.element.classList.add('dragging');
                            
                            // Show ghost with thumbnail clone
                            const ghost = this._dragGhost;
                            ghost.innerHTML = '';
                            ghost.style.width = '80px';
                            ghost.style.height = '80px';
                            const thumb = state.element.querySelector('canvas');
                            if (thumb) {
                                const c = document.createElement('canvas');
                                c.width = 80; c.height = 60;
                                c.getContext('2d').drawImage(thumb, 0, 0);
                                c.style.width = '100%';
                                c.style.height = '100%';
                                c.style.objectFit = 'contain';
                                ghost.appendChild(c);
                            }
                            ghost.style.display = 'block';
                        }
                        
                        if (!state.started) return;
                        e.preventDefault();
                        
                        // Move ghost to cursor
                        this._dragGhost.style.left = e.clientX + 'px';
                        this._dragGhost.style.top = e.clientY + 'px';
                        
                        // Find insertion position
                        const containerEl = document.getElementById('framesContainer');
                        const frames = containerEl.querySelectorAll('.frame');
                        const containerRect = containerEl.getBoundingClientRect();
                        let bestInsert = null;
                        let bestDist = Infinity;
                        
                        for (const frame of frames) {
                            const rect = frame.getBoundingClientRect();
                            const idx = parseInt(frame.dataset.frameIndex);
                            
                            // Check left edge
                            const leftDist = Math.abs(e.clientX - rect.left);
                            if (leftDist < bestDist) {
                                bestDist = leftDist;
                                bestInsert = { idx, side: 'left', x: rect.left - containerRect.left };
                            }
                            // Check right edge
                            const rightDist = Math.abs(e.clientX - rect.right);
                            if (rightDist < bestDist) {
                                bestDist = rightDist;
                                bestInsert = { idx, side: 'right', x: rect.right - containerRect.left };
                            }
                        }
                        
                        if (bestInsert) {
                            const insertIdx = bestInsert.side === 'right' ? bestInsert.idx + 1 : bestInsert.idx;
                            // Don't show indicator adjacent to dragged frame's original position
                            if (insertIdx === state.index || insertIdx === state.index + 1) {
                                this._dropIndicator.style.display = 'none';
                                state.insertIdx = undefined;
                            } else {
                                this._dropIndicator.style.display = 'block';
                                this._dropIndicator.style.left = (bestInsert.x - 1) + 'px';
                                state.insertIdx = insertIdx;
                            }
                        }
                    });
                    
                    document.addEventListener('pointerup', (e) => {
                        if (!this._frameDragState) return;
                        
                        const state = this._frameDragState;
                        
                        // Clean up
                        state.element.classList.remove('dragging');
                        this._dragGhost.style.display = 'none';
                        this._dropIndicator.style.display = 'none';
                        
                        if (state.started && state.insertIdx !== undefined) {
                            // Convert insertion index to reorder target
                            const target = state.insertIdx > state.index ? state.insertIdx - 1 : state.insertIdx;
                            if (target !== state.index) {
                                this.reorderFrames(state.index, target);
                            }
                        } else if (!state.started) {
                            // It was just a click, not a drag — select the frame
                            this.commitSelection();
                            this.currentFrameIndex = state.index;
                            this.initializeFrame();
                            this.render();
                        }
                        
                        this._frameDragState = null;
                    });
                }
                
                // Add new frame button
                const addFrameDiv = document.createElement('div');
                addFrameDiv.className = 'add-frame';
                addFrameDiv.textContent = '+';
                addFrameDiv.title = 'Add new frame after current frame';
                addFrameDiv.addEventListener('click', () => this.nextFrame());
                container.appendChild(addFrameDiv);
            }
            
            reorderFrames(fromIndex, toIndex) {
                const layer = this.getCurrentLayer();
                
                // Remove the frame from its original position
                const [movedFrame] = layer.frames.splice(fromIndex, 1);
                
                // Insert it at the new position
                layer.frames.splice(toIndex, 0, movedFrame);
                
                // Update current frame index if needed
                if (this.currentFrameIndex === fromIndex) {
                    this.currentFrameIndex = toIndex;
                } else if (fromIndex < this.currentFrameIndex && toIndex >= this.currentFrameIndex) {
                    this.currentFrameIndex--;
                } else if (fromIndex > this.currentFrameIndex && toIndex <= this.currentFrameIndex) {
                    this.currentFrameIndex++;
                }
                
                this.render();
            }
            
            // === SAVE / LOAD (.fby FrameBoy format) ===
            
            async saveProject() {
                const defaultName = this._lastSaveName || 'my-animation';
                
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const originalText = fileMenuBtn.innerHTML;
                fileMenuBtn.textContent = 'Saving...';
                fileMenuBtn.disabled = true;
                
                try {
                    // Serialize all layers and frames to base64 PNG
                    const layerData = [];
                    for (const layer of this.layers) {
                        const frames = [];
                        for (const frame of layer.frames) {
                            if (frame) {
                                frames.push(frame.toDataURL('image/png'));
                            } else {
                                frames.push(null);
                            }
                        }
                        layerData.push({
                            id: layer.id,
                            name: layer.name,
                            visible: layer.visible,
                            opacity: layer.opacity,
                            frames: frames
                        });
                    }
                    
                    const project = {
                        format: 'FrameBoy',
                        version: 1,
                        canvasWidth: this.canvas.width,
                        canvasHeight: this.canvas.height,
                        fps: this.fps,
                        currentLayerId: this.currentLayerId,
                        currentFrameIndex: this.currentFrameIndex,
                        nextLayerId: this.nextLayerId,
                        layers: layerData
                    };
                    
                    const json = JSON.stringify(project);
                    const blob = new Blob([json], { type: 'application/json' });
                    
                    // Try native save picker (user chooses location + filename)
                    if ('showSaveFilePicker' in window) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: `${defaultName}.fby`,
                                types: [{
                                    description: 'FrameBoy Project',
                                    accept: { 'application/json': ['.fby'] }
                                }]
                            });
                            const writable = await handle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                            // Remember name user chose for next save
                            this._lastSaveName = handle.name.replace(/\.fby$/i, '');
                            
                            fileMenuBtn.textContent = '✓ Saved!';
                            setTimeout(() => {
                                fileMenuBtn.innerHTML = originalText;
                                fileMenuBtn.disabled = false;
                            }, 1500);
                            return;
                        } catch (err) {
                            if (err.name === 'AbortError') {
                                // User cancelled the picker
                                fileMenuBtn.innerHTML = originalText;
                                fileMenuBtn.disabled = false;
                                return;
                            }
                            // API failed — fall through to prompt + download
                        }
                    }
                    
                    // Fallback: prompt for name then download (Safari, Firefox, iPad)
                    const fileName = prompt('Name your project:', defaultName);
                    if (fileName === null) {
                        fileMenuBtn.innerHTML = originalText;
                        fileMenuBtn.disabled = false;
                        return;
                    }
                    const safeName = fileName.trim().replace(/[^\w\s\-]/g, '').replace(/\s+/g, '-') || 'my-animation';
                    this._lastSaveName = safeName;
                    this.downloadBlob(blob, `${safeName}.fby`);
                    
                    fileMenuBtn.textContent = '✓ Saved!';
                    setTimeout(() => {
                        fileMenuBtn.innerHTML = originalText;
                        fileMenuBtn.disabled = false;
                    }, 1500);
                } catch (err) {
                    console.error('Save failed:', err);
                    alert('Save failed: ' + err.message);
                    fileMenuBtn.innerHTML = originalText;
                    fileMenuBtn.disabled = false;
                }
            }
            
            async loadProject(file) {
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const originalText = fileMenuBtn.innerHTML;
                fileMenuBtn.textContent = 'Loading...';
                fileMenuBtn.disabled = true;
                
                try {
                    const text = await file.text();
                    const project = JSON.parse(text);
                    
                    // Extract project name from filename for re-saving
                    this._lastSaveName = file.name.replace(/\.fby$/i, '') || 'my-animation';
                    
                    // Validate format
                    if (project.format !== 'FrameBoy' || !project.layers) {
                        throw new Error('Not a valid FrameBoy project file.');
                    }
                    
                    // Commit any active selection
                    this.commitSelection();
                    this.hideTransformHandles();
                    
                    // Restore canvas dimensions
                    if (project.canvasWidth && project.canvasHeight) {
                        this.canvas.width = project.canvasWidth;
                        this.canvas.height = project.canvasHeight;
                        this.onionCanvas.width = project.canvasWidth;
                        this.onionCanvas.height = project.canvasHeight;
                        this.selectionCanvas.width = project.canvasWidth;
                        this.selectionCanvas.height = project.canvasHeight;
                    }
                    
                    // Restore FPS
                    if (project.fps) {
                        this.fps = project.fps;
                        document.getElementById('fpsInput').value = project.fps;
                    }
                    
                    // Load layers and frames from base64
                    const loadImage = (dataUrl) => {
                        return new Promise((resolve, reject) => {
                            const img = new Image();
                            img.onload = () => {
                                const c = document.createElement('canvas');
                                c.width = this.canvas.width;
                                c.height = this.canvas.height;
                                c.getContext('2d').drawImage(img, 0, 0);
                                resolve(c);
                            };
                            img.onerror = reject;
                            img.src = dataUrl;
                        });
                    };
                    
                    const layers = [];
                    for (const layerData of project.layers) {
                        const frames = [];
                        for (const frameData of layerData.frames) {
                            if (frameData) {
                                frames.push(await loadImage(frameData));
                            } else {
                                frames.push(null);
                            }
                        }
                        layers.push({
                            id: layerData.id,
                            name: layerData.name,
                            visible: layerData.visible,
                            opacity: layerData.opacity,
                            frames: frames
                        });
                    }
                    
                    // Apply loaded state
                    this.layers = layers;
                    this.currentLayerId = project.currentLayerId || layers[0].id;
                    this.currentFrameIndex = project.currentFrameIndex || 0;
                    this.nextLayerId = project.nextLayerId || (Math.max(...layers.map(l => l.id)) + 1);
                    
                    // Reset undo/redo
                    this.undoStack = [];
                    this.redoStack = [];
                    this.selectionUndoStack = [];
                    this.selectionRedoStack = [];
                    this.updateUndoRedoButtons();
                    
                    // Render
                    this.positionOnionCanvas();
                    this.renderLayers();
                    this.render();
                    
                    fileMenuBtn.textContent = '✓ Loaded!';
                    setTimeout(() => {
                        fileMenuBtn.innerHTML = originalText;
                        fileMenuBtn.disabled = false;
                    }, 1500);
                } catch (err) {
                    console.error('Load failed:', err);
                    alert('Load failed: ' + err.message);
                    fileMenuBtn.innerHTML = originalText;
                    fileMenuBtn.disabled = false;
                }
            }
            
            async importImageSequence(files) {
                if (!files || files.length === 0) return;
                
                // Natural sort: properly orders frame_2 before frame_10
                files.sort((a, b) => {
                    return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
                });
                
                const fileMenuBtn = document.getElementById('fileMenuBtn');
                const originalHTML = fileMenuBtn.innerHTML;
                fileMenuBtn.disabled = true;
                
                this.commitSelection();
                
                const layer = this.getCurrentLayer();
                const insertAt = this.currentFrameIndex + 1;
                const canvasW = this.canvas.width;
                const canvasH = this.canvas.height;
                
                const loadImageFile = (file) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const img = new Image();
                            img.onload = () => resolve(img);
                            img.onerror = () => reject(new Error(`Failed to load: ${file.name}`));
                            img.src = reader.result;
                        };
                        reader.onerror = () => reject(new Error(`Failed to read: ${file.name}`));
                        reader.readAsDataURL(file);
                    });
                };
                
                try {
                    const newFrames = [];
                    
                    for (let i = 0; i < files.length; i++) {
                        fileMenuBtn.textContent = `Importing ${i + 1}/${files.length}…`;
                        
                        const img = await loadImageFile(files[i]);
                        
                        // Create frame canvas and draw image scaled to fit, centered
                        const frame = document.createElement('canvas');
                        frame.width = canvasW;
                        frame.height = canvasH;
                        const ctx = frame.getContext('2d');
                        
                        // Compute scale to fit image within canvas (maintain aspect ratio)
                        const scale = Math.min(canvasW / img.width, canvasH / img.height);
                        const drawW = img.width * scale;
                        const drawH = img.height * scale;
                        const offsetX = (canvasW - drawW) / 2;
                        const offsetY = (canvasH - drawH) / 2;
                        
                        ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
                        newFrames.push(frame);
                    }
                    
                    // Insert frames into current layer after current position
                    layer.frames.splice(insertAt, 0, ...newFrames);
                    
                    // Pad other layers with empty frames to keep alignment
                    for (const otherLayer of this.layers) {
                        if (otherLayer.id === layer.id) continue;
                        const empties = [];
                        for (let i = 0; i < newFrames.length; i++) {
                            empties.push(this.createEmptyFrame());
                        }
                        otherLayer.frames.splice(insertAt, 0, ...empties);
                    }
                    
                    // Navigate to first imported frame
                    this.currentFrameIndex = insertAt;
                    this.render();
                    
                    fileMenuBtn.textContent = `✓ ${newFrames.length} frames imported`;
                    setTimeout(() => {
                        fileMenuBtn.innerHTML = originalHTML;
                        fileMenuBtn.disabled = false;
                    }, 2000);
                } catch (err) {
                    console.error('Import failed:', err);
                    alert('Import failed: ' + err.message);
                    fileMenuBtn.innerHTML = originalHTML;
                    fileMenuBtn.disabled = false;
                }
            }
            
            // Helper to trigger a file download from a blob
            downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            async exportGif() {
                const layer = this.getCurrentLayer();
                if (layer.frames.length === 0) {
                    alert('No frames to export!');
                    return;
                }
                
                // Export as PNG frames ZIP
                this.exportFramesAsPNG();
            }
            
            async exportFramesAsPNG() {
                const exportBtn = document.getElementById('fileMenuBtn');
                
                if (!exportBtn) {
                    alert('Export button not found. Please refresh the page.');
                    return;
                }
                
                const originalText = exportBtn.innerHTML;
                
                exportBtn.textContent = 'Creating ZIP...';
                exportBtn.disabled = true;
                
                try {
                    // Load JSZip library
                    if (typeof JSZip === 'undefined') {
                        await this.loadJSZip();
                    }
                    
                    const zip = new JSZip();
                    
                    // Calculate max frames
                    const maxFrames = Math.max(...this.layers.map(l => l.frames.length));
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Create a temporary canvas for compositing
                    const compositeCanvas = document.createElement('canvas');
                    compositeCanvas.width = this.canvas.width;
                    compositeCanvas.height = this.canvas.height;
                    const compositeCtx = compositeCanvas.getContext('2d');
                    
                    // Create folders for each layer and composite
                    const compositeFolderName = 'composite-all-layers';
                    const compositeFolder = zip.folder(compositeFolderName);
                    
                    // Export each layer into its own folder
                    for (const layer of this.layers) {
                        if (layer.frames.length > 0) {
                            const layerFolderName = layer.name.replace(/[^a-z0-9]/gi, '_');
                            const layerFolder = zip.folder(layerFolderName);
                            
                            for (let i = 0; i < layer.frames.length; i++) {
                                const frame = layer.frames[i];
                                if (frame) {
                                    // Convert frame to blob
                                    const blob = await new Promise(resolve => {
                                        frame.toBlob(resolve, 'image/png');
                                    });
                                    
                                    // Add to layer folder
                                    const filename = `frame_${String(i + 1).padStart(3, '0')}.png`;
                                    layerFolder.file(filename, blob);
                                }
                            }
                        }
                    }
                    
                    // Export composite frames (all visible layers combined)
                    for (let i = 0; i < maxFrames; i++) {
                        // Clear canvas with white background
                        compositeCtx.fillStyle = 'white';
                        compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
                        
                        // Draw all visible layers for this frame
                        for (const layer of this.layers) {
                            if (layer.visible && layer.frames[i]) {
                                compositeCtx.globalAlpha = layer.opacity || 1.0;
                                compositeCtx.drawImage(layer.frames[i], 0, 0);
                                compositeCtx.globalAlpha = 1.0;
                            }
                        }
                        
                        // Convert composite to blob
                        const blob = await new Promise(resolve => {
                            compositeCanvas.toBlob(resolve, 'image/png');
                        });
                        
                        // Add to composite folder
                        const filename = `frame_${String(i + 1).padStart(3, '0')}.png`;
                        compositeFolder.file(filename, blob);
                        
                        // Update progress
                        const totalProgress = Math.round((i / maxFrames) * 100);
                        exportBtn.textContent = `Creating composite... ${totalProgress}%`;
                    }
                    
                    // Generate zip file
                    exportBtn.textContent = 'Generating ZIP file...';
                    const zipBlob = await zip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: 6 }
                    }, (metadata) => {
                        const progress = Math.round(metadata.percent);
                        exportBtn.textContent = `Compressing... ${progress}%`;
                    });
                    
                    // Download the zip
                    this.downloadBlob(zipBlob, `animation-frames-${Date.now()}.zip`);
                    
                    exportBtn.textContent = '✓ ZIP Downloaded!';
                    setTimeout(() => {
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                    }, 2000);
                    
                } catch (error) {
                    console.error('ZIP export error:', error);
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    alert(`Failed to create ZIP file: ${error.message}\n\nFrames will download individually instead.`);
                    
                    // Fallback to individual downloads
                    this.exportFramesIndividually();
                }
            }
            
            async exportAsGif() {
                const exportBtn = document.getElementById('fileMenuBtn');
                
                if (!exportBtn) {
                    alert('Export button not found. Please refresh the page.');
                    return;
                }
                
                const originalText = exportBtn.innerHTML;
                
                try {
                    exportBtn.textContent = 'Preparing GIF...';
                    exportBtn.disabled = true;
                    
                    // Calculate total frames
                    const maxFrames = Math.max(...this.layers.map(l => l.frames.length));
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    // Check if gifshot is loaded
                    if (typeof gifshot === 'undefined') {
                        throw new Error('GIF library not loaded. Please refresh the page.');
                    }
                    
                    // Create temporary canvas for rendering
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.canvas.width;
                    tempCanvas.height = this.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Render all frames as data URLs
                    exportBtn.textContent = 'Rendering frames...';
                    const frameImages = [];
                    
                    for (let i = 0; i < maxFrames; i++) {
                        // White background for GIF export
                        tempCtx.fillStyle = '#ffffff';
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Render all visible layers for this frame
                        for (const layer of this.layers) {
                            if (!layer.visible) continue;
                            
                            const frame = layer.frames[i];
                            if (frame) {
                                tempCtx.globalAlpha = layer.opacity || 1.0;
                                tempCtx.drawImage(frame, 0, 0);
                                tempCtx.globalAlpha = 1.0;
                            }
                        }
                        
                        // Convert to data URL
                        frameImages.push(tempCanvas.toDataURL('image/png'));
                        
                        // Update progress
                        const progress = Math.round((i / maxFrames) * 50);
                        exportBtn.textContent = `Rendering frames... ${progress}%`;
                    }
                    
                    // Create GIF from frames
                    exportBtn.textContent = 'Creating GIF... 50%';
                    
                    gifshot.createGIF({
                        images: frameImages,
                        gifWidth: this.canvas.width,
                        gifHeight: this.canvas.height,
                        interval: 1 / this.fps,
                        numFrames: maxFrames,
                        frameDuration: 1,
                        sampleInterval: 10,
                        numWorkers: 2
                    }, (obj) => {
                        if (!obj.error) {
                            // Convert base64 to blob
                            const base64Data = obj.image.split(',')[1];
                            const byteCharacters = atob(base64Data);
                            const byteArrays = [];
                            
                            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                                const slice = byteCharacters.slice(offset, offset + 512);
                                const byteNumbers = new Array(slice.length);
                                for (let i = 0; i < slice.length; i++) {
                                    byteNumbers[i] = slice.charCodeAt(i);
                                }
                                byteArrays.push(new Uint8Array(byteNumbers));
                            }
                            
                            const blob = new Blob(byteArrays, { type: 'image/gif' });
                            
                            // Download
                            this.downloadBlob(blob, `frameboy-animation-${Date.now()}.gif`);
                            
                            // Restore button
                            exportBtn.textContent = '✓ GIF Downloaded!';
                            exportBtn.disabled = false;
                            setTimeout(() => {
                                exportBtn.innerHTML = originalText;
                            }, 2000);
                        } else {
                            throw new Error(obj.error);
                        }
                    });
                    
                } catch (error) {
                    console.error('GIF export error:', error);
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    alert(`Failed to create GIF: ${error.message}\n\nTry PNG ZIP export instead.`);
                }
            }
            
            async exportAsMp4() {
                const exportBtn = document.getElementById('fileMenuBtn');
                const originalText = exportBtn.innerHTML;
                
                try {
                    exportBtn.textContent = 'Creating MP4...';
                    exportBtn.disabled = true;
                    
                    const maxFrames = Math.max(...this.layers.map(l => l.frames.length));
                    
                    if (maxFrames === 0) {
                        alert('No frames to export!');
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        return;
                    }
                    
                    if (!window.MediaRecorder) {
                        throw new Error('Video recording not supported in this browser');
                    }
                    
                    // Create a temporary canvas for recording
                    const recordCanvas = document.createElement('canvas');
                    recordCanvas.width = this.canvas.width;
                    recordCanvas.height = this.canvas.height;
                    const recordCtx = recordCanvas.getContext('2d');
                    
                    // Try best available video format
                    let mimeType = 'video/webm;codecs=vp9';
                    let fileExt = 'webm';
                    
                    if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) {
                        mimeType = 'video/mp4;codecs=avc1';
                        fileExt = 'mp4';
                    } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                        mimeType = 'video/mp4';
                        fileExt = 'mp4';
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
                        mimeType = 'video/webm;codecs=h264';
                        fileExt = 'mp4';
                    }
                    
                    // Get canvas stream
                    const stream = recordCanvas.captureStream(this.fps);
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: 5000000
                    });
                    
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: mimeType.split(';')[0] });
                        this.downloadBlob(blob, `frameboy-animation-${Date.now()}.${fileExt}`);
                        
                        exportBtn.textContent = '✓ Video Downloaded!';
                        exportBtn.disabled = false;
                        setTimeout(() => {
                            exportBtn.innerHTML = originalText;
                        }, 2000);
                    };
                    
                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                        alert('Video recording failed.');
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    
                    // Play through all frames
                    const frameDelay = 1000 / this.fps;
                    let currentFrame = 0;
                    
                    const drawNextFrame = () => {
                        if (currentFrame < maxFrames) {
                            // White background
                            recordCtx.fillStyle = '#ffffff';
                            recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
                            
                            // Draw all visible layers for this frame
                            for (const layer of this.layers) {
                                if (layer.visible && layer.frames[currentFrame]) {
                                    recordCtx.globalAlpha = layer.opacity || 1.0;
                                    recordCtx.drawImage(layer.frames[currentFrame], 0, 0);
                                    recordCtx.globalAlpha = 1.0;
                                }
                            }
                            
                            const progress = Math.round((currentFrame / maxFrames) * 100);
                            exportBtn.textContent = `Recording MP4... ${progress}%`;
                            
                            currentFrame++;
                            setTimeout(drawNextFrame, frameDelay);
                        } else {
                            setTimeout(() => {
                                mediaRecorder.stop();
                            }, frameDelay * 2);
                        }
                    };
                    
                    drawNextFrame();
                    
                } catch (error) {
                    console.error('MP4 export error:', error);
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                    alert(`Video export failed: ${error.message}`);
                }
            }
            
            exportFramesIndividually() {
                const layer = this.getCurrentLayer();
                
                setTimeout(() => {
                    layer.frames.forEach((frame, index) => {
                        if (frame) {
                            setTimeout(() => {
                                frame.toBlob((blob) => {
                                    this.downloadBlob(blob, `frame_${String(index + 1).padStart(3, '0')}.png`);
                                });
                            }, index * 200);
                        }
                    });
                }, 100);
                
                alert(`Downloading ${layer.frames.length} frames as individual PNG files!`);
            }
            
            async loadJSZip() {
                return new Promise((resolve, reject) => {
                    if (typeof JSZip !== 'undefined') {
                        resolve();
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.async = true;
                    
                    const timeout = setTimeout(() => {
                        reject(new Error('JSZip library took too long to load'));
                    }, 10000);
                    
                    script.onload = () => {
                        clearTimeout(timeout);
                        setTimeout(() => {
                            if (typeof JSZip !== 'undefined') {
                                resolve();
                            } else {
                                reject(new Error('JSZip library loaded but not available'));
                            }
                        }, 100);
                    };
                    
                    script.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Failed to load JSZip library'));
                    };
                    
                    document.head.appendChild(script);
                });
            }
            
            exportSpriteSheet() {
                const layer = this.getCurrentLayer();
                const frameCount = layer.frames.length;
                
                if (frameCount === 0) return;
                
                // Create a sprite sheet with all frames in a row
                const frameWidth = this.canvas.width;
                const frameHeight = this.canvas.height;
                const spriteSheet = document.createElement('canvas');
                spriteSheet.width = frameWidth * frameCount;
                spriteSheet.height = frameHeight;
                const ctx = spriteSheet.getContext('2d');
                
                // Draw white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, spriteSheet.width, spriteSheet.height);
                
                // Draw each frame
                layer.frames.forEach((frame, index) => {
                    if (frame) {
                        ctx.drawImage(frame, index * frameWidth, 0);
                    }
                });
                
                // Download the sprite sheet
                spriteSheet.toBlob((blob) => {
                    this.downloadBlob(blob, 'animation_spritesheet.png');
                    alert('Sprite sheet downloaded! You can use this with CSS animations or game engines.');
                });
            }
        }
        
        // Initialize the app
        const app = new FrameBoy();
        
        // Apple Pencil tap fix:
        // iPadOS Safari sometimes delays or fails to fire click events from stylus.
        // Solution: fire click on pointerdown for pen, then suppress the delayed native click.
        const penTapState = { lastTarget: null, lastTime: 0, isManualClick: false };
        
        document.addEventListener('pointerdown', (e) => {
            if (e.pointerType !== 'pen') return;
            // Explicitly exclude canvas elements
            if (e.target.tagName === 'CANVAS') return;
            if (e.target.closest('canvas')) return;
            
            const btn = e.target.closest('button, .shape-icon, .dropdown-item, .add-frame, .add-layer-btn-inline, .delete-layer-btn-inline, input[type="checkbox"]');
            if (btn && !e.target.closest('canvas')) {
                // Mark that we're about to fire a manual click
                penTapState.isManualClick = true;
                // Fire the click synchronously first (handlers run immediately)
                btn.click();
                // Clear the flag after handlers complete
                penTapState.isManualClick = false;
                // THEN mark it so the delayed native click gets suppressed
                penTapState.lastTarget = btn;
                penTapState.lastTime = Date.now();
            }
        });
        
        // Capture-phase: suppress the delayed native click Safari sends ~300ms later
        document.addEventListener('click', (e) => {
            // Don't suppress if this is our own manual click
            if (penTapState.isManualClick) return;
            
            // Explicitly exclude canvas clicks
            if (e.target.tagName === 'CANVAS') return;
            if (e.target.closest('canvas')) return;
            
            if (!penTapState.lastTarget) return;
            if (Date.now() - penTapState.lastTime > 800) {
                penTapState.lastTarget = null;
                return;
            }
            const btn = e.target.closest('button, .shape-icon, .dropdown-item, .add-frame, .add-layer-btn-inline, .delete-layer-btn-inline, input[type="checkbox"]');
            if (btn === penTapState.lastTarget) {
                e.stopImmediatePropagation();
                e.preventDefault();
                penTapState.lastTarget = null;
            }
        }, true);
        
        // Mobile: close dropdown overlays when tapping outside
        document.addEventListener('pointerdown', (e) => {
            if (window.innerWidth > 768) return;
            // Don't close dropdowns when interacting with canvas
            if (e.target.tagName === 'CANVAS') return;
            if (e.target.closest('canvas')) return;
            
            const isDropdown = e.target.closest('.brush-dropdown, .dropdown-menu, .onion-skin-dropdown');
            const isToggle = e.target.closest('button');
            if (!isDropdown && !isToggle) {
                document.querySelectorAll('.brush-dropdown.show, .dropdown-menu.show, .onion-skin-dropdown.show')
                    .forEach(d => d.classList.remove('show'));
            }
        });
        
        // Prevent iOS double-tap selection menu and context menu globally for canvas
        document.addEventListener('dblclick', (e) => {
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, true);
        
        document.addEventListener('contextmenu', (e) => {
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, true);
        
        // Prevent text selection globally when on canvas or when actively drawing
        // This stops the Export button text from being selected during fast drawing
        document.addEventListener('selectstart', (e) => {
            // Always prevent selection on canvas
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return;
            }
            
            // Prevent selection globally when using brush/eraser tools (not just when drawing)
            // This stops fast strokes from accidentally selecting UI text
            if (app && (app.tool === 'brush' || app.tool === 'eraser')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return;
            }
            
            // Also prevent if we're actively drawing (backup check)
            if (app && app.isDrawing) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }, true);
        
        // Prevent drag gestures from interfering with drawing
        document.addEventListener('dragstart', (e) => {
            // Prevent drag on canvas
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            
            // Prevent drag globally when using brush/eraser
            if (app && (app.tool === 'brush' || app.tool === 'eraser')) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);
        
        // Prevent iOS gesture-based selection (like pinch-to-select)
        document.addEventListener('gesturestart', (e) => {
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('gesturechange', (e) => {
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('gestureend', (e) => {
            if (e.target.tagName === 'CANVAS' || e.target.closest('canvas') || e.target.closest('.canvas-container')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // === PWA: Service Worker + File Handling ===
        
        // Register service worker for PWA install (enables file_handlers in manifest)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {
                // SW not available (e.g. not served over HTTPS) — app still works fine
            });
        }
        
        // File Handling API: when .fby is opened via OS file association (PWA only)
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(async (launchParams) => {
                if (launchParams.files && launchParams.files.length > 0) {
                    const fileHandle = launchParams.files[0];
                    const file = await fileHandle.getFile();
                    if (file.name.endsWith('.fby')) {
                        app.loadProject(file);
                    }
                }
            });
        }
        
        // === Drag-and-Drop .fby file loading ===
        
        const dropOverlay = document.getElementById('dropOverlay');
        let dragCounter = 0; // Track nested enter/leave events
        
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            // Only show overlay if dragging files (not canvas elements)
            if (e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                dropOverlay.classList.add('active');
            }
        });
        
        document.addEventListener('dragover', (e) => {
            e.preventDefault(); // Required to allow drop
            if (e.dataTransfer) {
                e.dataTransfer.dropEffect = 'copy';
            }
        });
        
        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter <= 0) {
                dragCounter = 0;
                dropOverlay.classList.remove('active');
            }
        });
        
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter = 0;
            dropOverlay.classList.remove('active');
            
            if (e.dataTransfer && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.name.endsWith('.fby')) {
                    app.loadProject(file);
                } else {
                    alert('Please drop a .fby FrameBoy project file.');
                }
            }
        });
    </script>
</body>
</html>
